{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/img/my-favicon.ico","path":"img/my-favicon.ico","modified":0,"renderable":0},{"_id":"source/img/支付宝打赏.png","path":"img/支付宝打赏.png","modified":0,"renderable":0},{"_id":"source/img/微信打赏.png","path":"img/微信打赏.png","modified":0,"renderable":0},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/nexmoe/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"source/img/sky.jpg","path":"img/sky.jpg","modified":0,"renderable":0},{"_id":"source/img/sky.png","path":"img/sky.png","modified":0,"renderable":0},{"_id":"themes/nexmoe/source/lib/iconfont/demo.css","path":"lib/iconfont/demo.css","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/demo_index.html","path":"lib/iconfont/demo_index.html","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.css","path":"lib/iconfont/iconfont.css","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.eot","path":"lib/iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.js","path":"lib/iconfont/iconfont.js","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.json","path":"lib/iconfont/iconfont.json","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.svg","path":"lib/iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.ttf","path":"lib/iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff","path":"lib/iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff2","path":"lib/iconfont/iconfont.woff2","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/js/mdui.js","path":"lib/mdui_043tiny/js/mdui.js","modified":1,"renderable":1},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/css/mdui.css","path":"lib/mdui_043tiny/css/mdui.css","modified":1,"renderable":1}],"Cache":[{"_id":"themes/nexmoe/.gitignore","hash":"f6a42031a09ea2740831c7eb84e3431f331df957","modified":1592293921812},{"_id":"themes/nexmoe/CODE_OF_CONDUCT.md","hash":"71e211684f8840845f3d6491922e43778da8b829","modified":1568784444013},{"_id":"themes/nexmoe/README.md","hash":"e735a2205cff1c7cafcb2616713fbcb1e6e6b623","modified":1592293921815},{"_id":"themes/nexmoe/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1592293921814},{"_id":"themes/nexmoe/font.php","hash":"3e2674934094417aa94beac3ddca37e14a8a4e65","modified":1568784444046},{"_id":"source/_posts/es10新特性.md","hash":"445346f77bd5ab49a3691032bf3151e435f383c6","modified":1569722483995},{"_id":"source/_posts/first.md","hash":"96e746c31a946683c9a833ae971a9ba52ac93a64","modified":1568775617272},{"_id":"themes/nexmoe/_config.example.yml","hash":"6c4b6c0413cf0d2e690b943ddb648debc7abb9a6","modified":1592293921816},{"_id":"source/_posts/let命令和const命令.md","hash":"aed879c97ff1881fd6e14cf2861d02a671692451","modified":1570668770860},{"_id":"source/_posts/vue-router.md","hash":"3183f95b779875768115fe8f66e8efdc67904cd2","modified":1570588405016},{"_id":"themes/nexmoe/_config.yml","hash":"38b774d0dd1b42ee5d1c70c8360f55a68d4b14f8","modified":1592293609975},{"_id":"source/_posts/BFC及其应用.md","hash":"e3c9a468182ada46376826f343a4c6fae8b1313d","modified":1568948746328},{"_id":"source/_posts/gittalk安装使用教程.md","hash":"a1e7e3168b98e507fd09ed4b86bce535623f6daf","modified":1568857583615},{"_id":"source/_posts/【JS进阶】你真的掌握变量和类型了吗.md","hash":"f4e7e489c39ee4df2444522162267a993e48dbc4","modified":1568775617334},{"_id":"source/_posts/一些面试题.md","hash":"4d5f0a68471778c9f02b1f35b9e2d70a4c4854e2","modified":1568797389748},{"_id":"source/_posts/前端知识总谱.md","hash":"dfd8946f774e842bc8c3e9df24aad69440b8adae","modified":1568797356601},{"_id":"source/_posts/vue学习.md","hash":"371936423cf0080d659e8dfc810212c84b58f08d","modified":1568797399254},{"_id":"source/_posts/vuex学习.md","hash":"5fcd7f41f75aa23fae7777443ee0731944ca0005","modified":1570525215729},{"_id":"source/_posts/如何制作blog.md","hash":"efac8ebe279c25022489db85c637b41252a7e43d","modified":1568797378556},{"_id":"source/_posts/不同排序算法.md","hash":"2b14db73d3c0c3e97998e8bf985bfbc391233bb9","modified":1568797309492},{"_id":"source/_posts/微信小程序.md","hash":"91cdcdc92934e235766e63087a7271afd35bae3b","modified":1568797386266},{"_id":"source/_posts/常用的css技巧.md","hash":"d46545c73c09f7bf157fdf4cc921375f6cf488f9","modified":1568797514664},{"_id":"source/_posts/前端需要知道的Javascript技巧.md","hash":"1ba8fa7eeee4662e1c2b5f747ecadfaa84a36927","modified":1568797360879},{"_id":"source/_posts/函数防抖和函数节流.md","hash":"6045ba9a44a2db2399c401fa8bafb2e8583f3d38","modified":1568797365742},{"_id":"source/_posts/常见正则表达式.md","hash":"87d27079e25e80d3e763ed8eb2189e170fff4b17","modified":1568797302211},{"_id":"source/img/my-favicon.ico","hash":"1d50fca150de4005641031a233e0dd536f311703","modified":1558942621373},{"_id":"source/_data/melody.yml","hash":"de5cb551c81deb088febba7afcec46f361e89697","modified":1559548679835},{"_id":"source/_posts/数组的map.md","hash":"0f3eabb3cbc812867dc82d91957e777bf21e4712","modified":1568797382481},{"_id":"source/_posts/记一次换电脑之后hexo-怎么处理.md","hash":"6fcd31068bccb88d10b4519ebb68cd343338bd82","modified":1568797326921},{"_id":"source/about/index.md","hash":"f42f351d6d2b0b0b58569abb335ffe2298d524f8","modified":1568792270891},{"_id":"source/tags/index.md","hash":"13546dfa6945fdebc79260a2d1f09e937d118e16","modified":1568775617428},{"_id":"source/categories/index.md","hash":"4e143bf503aca7aca0140d05646e074d184fc2bd","modified":1568775617428},{"_id":"themes/nexmoe/README/english.md","hash":"44cb225c9abf00c41ffc229ff9407fe3643de351","modified":1568784444013},{"_id":"themes/nexmoe/WIKI/README.md","hash":"82ea9afaa0d1a61eefb4fd9a742a8f1f5f18a49d","modified":1568784444013},{"_id":"source/img/支付宝打赏.png","hash":"ada767e3e07db2f170d64d882c2c3df9f73d389b","modified":1559282072555},{"_id":"themes/nexmoe/WIKI/deploy.sh","hash":"695d79ccf8b459d63b48f583ff517f8bda56c0a2","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/package.json","hash":"12e2e1fcf88928935445c6c65664b58f9b3865e2","modified":1568784444030},{"_id":"themes/nexmoe/font/QQ.svg","hash":"195665f0d13e71bbbea8ecbe2e46c0e4e67341fe","modified":1568784444046},{"_id":"source/img/微信打赏.png","hash":"5bf0ce376732392d3a28fda92ff77d47b7471389","modified":1559282146762},{"_id":"themes/nexmoe/font/areachart.svg","hash":"71e8bef524be4ba17ac9918d8598a606b2bb26c9","modified":1568784444046},{"_id":"themes/nexmoe/font/appstore-fill.svg","hash":"6ecc527b424afb79bca7d26191c53ebc08091454","modified":1568784444046},{"_id":"themes/nexmoe/font/battlenet.svg","hash":"961c2592ed5ea31319bd476e481549d69e8d075d","modified":1568784444046},{"_id":"themes/nexmoe/font/calendar-fill.svg","hash":"05e5b979cf8d150731c0eab66a4394df9498f1d6","modified":1568784444046},{"_id":"themes/nexmoe/font/bilibili.svg","hash":"0f9d92835db855bf581b9858a8fc1e3380be8808","modified":1568784444046},{"_id":"themes/nexmoe/font/container.svg","hash":"851225195cff6589a5247cb383194057190dd842","modified":1568784444046},{"_id":"themes/nexmoe/font/ellipsis.svg","hash":"c4074867e95f14d55c3e44145ef6388f60684c5e","modified":1568784444046},{"_id":"themes/nexmoe/font/dribbble.svg","hash":"0785c0b322c849b0b4736b88fc5d4fed7fbaf07d","modified":1568784444046},{"_id":"themes/nexmoe/font/eye-fill.svg","hash":"158b8b01f5c43219b599799273a0f8d553e91723","modified":1568784444046},{"_id":"themes/nexmoe/font/home.svg","hash":"97ab890dc43804b584ce3bb407bdbbb32030391b","modified":1568784444046},{"_id":"themes/nexmoe/font/github.svg","hash":"b10f18d0644d120624c25b8ad5a2bc1ef5cff3a0","modified":1568784444046},{"_id":"themes/nexmoe/font/left.svg","hash":"3fa57b536daade473b90cd496a39962c90de12ab","modified":1568784444046},{"_id":"themes/nexmoe/font/mail-fill.svg","hash":"88ef0ea02f5449d7d24ce3f957847219e5205fa0","modified":1568784444046},{"_id":"themes/nexmoe/font/menu.svg","hash":"93c34d0e2156caa8dca37007da3647a6af0fa352","modified":1568784444046},{"_id":"themes/nexmoe/font/right.svg","hash":"640b5fad35d5b1b1052c2f44bb58b1db5446a296","modified":1568784444046},{"_id":"themes/nexmoe/font/info-circle.svg","hash":"016e0515fccbd158cd1094376910725f7325acd8","modified":1568784444046},{"_id":"themes/nexmoe/font/steam.svg","hash":"cf35facf841e5be58ac7c35945ae4a576d460b7c","modified":1568784444046},{"_id":"themes/nexmoe/font/tag-fill.svg","hash":"f4a7d7cb92e40295a6b4c37b8d06385cf024eb9d","modified":1568784444046},{"_id":"themes/nexmoe/font/telegram.svg","hash":"51d8f5b3fffb40696f5830608ce2abfcebf36e2c","modified":1568784444046},{"_id":"themes/nexmoe/font/tags-fill.svg","hash":"87f59d1b14a5160e726ec3edc6e06fbe953f40f4","modified":1568784444046},{"_id":"themes/nexmoe/font/twitter.svg","hash":"bfad6767a6cc6058f0e4798225dc8f5898a228ca","modified":1568784444046},{"_id":"themes/nexmoe/font/time-circle-fill.svg","hash":"ecdacea2e496c505a7d07770e54c503420ef9290","modified":1568784444046},{"_id":"themes/nexmoe/font/wechat-fill.svg","hash":"fdb6fa45343307af0d6ebb70a75688afbc4444b3","modified":1568784444046},{"_id":"themes/nexmoe/font/unorderedlist.svg","hash":"46722843f0674341bffd8ad7f2da1deabde2ba82","modified":1568784444046},{"_id":"themes/nexmoe/font/youtube.svg","hash":"fe59b1fb78e5661feae8775bdafe855f28092f0c","modified":1568784444046},{"_id":"themes/nexmoe/font/weibo.svg","hash":"277d4076a9d17b8762e66fe81cbf0ec9f99a59cd","modified":1568784444046},{"_id":"themes/nexmoe/font/zhihu.svg","hash":"78e11c8e8f9ba84ebb2043a8fdbc484b56db3a95","modified":1568784444046},{"_id":"themes/nexmoe/layout/index.ejs","hash":"607996991e4fccb02d0e11589fca397493ef44db","modified":1592293921876},{"_id":"themes/nexmoe/layout/archives.ejs","hash":"738dfd4af95cc4fefe2560ac30a7926a378d19fd","modified":1568784444061},{"_id":"themes/nexmoe/layout/layout.ejs","hash":"5a553a3108f1460cb3bc8ee1c9183b5f8ab8dd15","modified":1592293921877},{"_id":"themes/nexmoe/layout/post.ejs","hash":"529617cecd548734a5239130ad55533b0f335182","modified":1592293921878},{"_id":"themes/nexmoe/languages/default.yml","hash":"87a7e349b1b6783d843bb404701aa26f60fd6d3d","modified":1592293921824},{"_id":"themes/nexmoe/languages/en.yml","hash":"83430833744a430b49adec9298473ad2d32066e1","modified":1592293921825},{"_id":"themes/nexmoe/languages/zh-HK.yml","hash":"ce19cbbeb610e27645b3109414bf546c70629442","modified":1592293921829},{"_id":"themes/nexmoe/languages/zh-TW.yml","hash":"ce19cbbeb610e27645b3109414bf546c70629442","modified":1592293921830},{"_id":"themes/nexmoe/languages/zh-CN.yml","hash":"08782500dd6492ee6e4ab4b46b45b7739951e0a7","modified":1592293921828},{"_id":"themes/nexmoe/layout/py.ejs","hash":"6f398d44fe5b3b9c4ce1542ea3d082a9cf17f3f6","modified":1592293921879},{"_id":"themes/nexmoe/WIKI/.vuepress/enhanceApp.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1568784444013},{"_id":"source/_posts/gittalk安装使用教程/02.png","hash":"fb668ba11592143693eff69ec95ed3da36728be9","modified":1568855331600},{"_id":"source/_posts/vuex学习/flow.png","hash":"73bb62ebc338fcd64ee95bde18684ffe3b3bb379","modified":1569810877170},{"_id":"source/_posts/gittalk安装使用教程/01.png","hash":"233c027cdeb0bfb7ec2e05ab4fad368e408b910a","modified":1568855297064},{"_id":"source/_posts/vuex学习/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1569811343692},{"_id":"source/img/avatar.jpg","hash":"d1464e054e9043db62415d9fd1056f88a33f303e","modified":1558942621372},{"_id":"source/_posts/gittalk安装使用教程/03.png","hash":"847bee1de4130a3878d53d0fd27fde7a9c06be0e","modified":1568855667187},{"_id":"themes/nexmoe/WIKI/contribution/README.md","hash":"727c364d849d6210eb692c2f9615b65a9008928f","modified":1568784444013},{"_id":"source/_posts/BFC及其应用/01.png","hash":"02a2d7d70dba2520a9ebc0f22f5c74548f86d81a","modified":1568946877231},{"_id":"themes/nexmoe/WIKI/hexo/README.md","hash":"7023d4864ac570a4d13c83c742c76027beba6f21","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/hexo/comment.md","hash":"a86c3dc190b08ac9cf9e2bfa90107e6087aab84c","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/hexo/statistics.md","hash":"6cf6ae2060569d813573c00a060ef45cf153b635","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/hexo/notice.md","hash":"b38e3e64f21dad7fa6ffef75e1a4711ef2679b8a","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/hexo/math.md","hash":"2c58ff9e49eacf79adb4ad18a679ab0436b12b14","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/hexo/use.md","hash":"b26dbeff0f9eba56d74c2a3ea21373f4c8f22e13","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/.vuepress/config.js","hash":"0c9c1d6249ab1e0550073479cb8531aa9aa90d89","modified":1568784444013},{"_id":"themes/nexmoe/layout/_partial/comment.ejs","hash":"6e48ae4a79ad9e14d00244c15cd6e9ad04b99eb4","modified":1592293921860},{"_id":"themes/nexmoe/layout/_partial/analytics.ejs","hash":"e53883f2bb9921cb08437f433d5d4d5cf52ab297","modified":1592293921859},{"_id":"themes/nexmoe/layout/_partial/copyright.ejs","hash":"64f441c4936bcf2c02ca39313531d01ca68e135c","modified":1592293921861},{"_id":"themes/nexmoe/layout/_partial/sidebar.ejs","hash":"58c53d620cc0695b68c1e18a9f0d97fc888357cc","modified":1592293921864},{"_id":"themes/nexmoe/layout/_partial/paginator.ejs","hash":"20caf7c8ab390cfd125a12cbc71e51f868899050","modified":1592293921863},{"_id":"themes/nexmoe/layout/_partial/site-verification.ejs","hash":"600319729da09e366c05e104fe68a821b087c027","modified":1592293921865},{"_id":"themes/nexmoe/layout/_partial/after-footer.ejs","hash":"acc0049b059f69bc9aae2787a26f5ccd67c8c6f9","modified":1592293921858},{"_id":"source/_posts/gittalk安装使用教程/04.png","hash":"5cd67b481d5a64a29be47eccbd7a1b19c46e87c8","modified":1568855740241},{"_id":"themes/nexmoe/WIKI/en/README.md","hash":"1e13b8bdc8328ac5c149e44189bb5e989ecd97ab","modified":1568784444030},{"_id":"themes/nexmoe/layout/_partial/header.ejs","hash":"f2309ed542d080ed816e540cffa48038545036a6","modified":1592293921862},{"_id":"themes/nexmoe/layout/_widget/archive.ejs","hash":"eb9890c7bf2441722af87a9593b82708bdef62db","modified":1592293921867},{"_id":"themes/nexmoe/layout/_widget/social.ejs","hash":"3ad3fc3cb32cd24adf00e959e4afd26aa55c8522","modified":1592293921871},{"_id":"themes/nexmoe/layout/_widget/recent_posts.ejs","hash":"7d9eaf8228eda803aa4956e55432f78e056d6a01","modified":1592293921869},{"_id":"themes/nexmoe/scripts/helper/css_auto_version.js","hash":"1df4e02d36ae52e64f4f4e709e488d6e413d9d0c","modified":1568784444061},{"_id":"themes/nexmoe/scripts/helper/js_auto_version.js","hash":"912dfbe49c51614ef886c967349d3cb054de6f2d","modified":1568784444061},{"_id":"themes/nexmoe/layout/_widget/tag.ejs","hash":"be2cbf60fe1be5591a53312a36558723816d605b","modified":1592293921872},{"_id":"themes/nexmoe/source/css/style.styl","hash":"f67ae2bad3151c48e5d30964de03a988b1f411bd","modified":1592293921887},{"_id":"themes/nexmoe/source/js/app.js","hash":"9a1581c99ce0ff46c0a15df9a249a24af33b8790","modified":1592293921889},{"_id":"themes/nexmoe/layout/_widget/tagcloud.ejs","hash":"eeea9f86ed422762ce6c04d96bf143c980d90635","modified":1592293921873},{"_id":"themes/nexmoe/layout/_widget/category.ejs","hash":"99113b9f2cb4ffefdda3e3a343647ac6a5083091","modified":1592293921868},{"_id":"themes/nexmoe/WIKI/.vuepress/public/manifest.json","hash":"be8f17b689ddfab04d39b08f9b295a6f144a6bf5","modified":1568784444013},{"_id":"themes/nexmoe/WIKI/.vuepress/styles/palette.styl","hash":"678603df862e062eee3e229839ec0dab3e6b316c","modified":1568784444013},{"_id":"themes/nexmoe/WIKI/component/basic/icon.md","hash":"ba90c85053ce4c7f8e35964810fd6bf173ae2adb","modified":1568784444013},{"_id":"themes/nexmoe/WIKI/component/basic/color.md","hash":"967e5e2a645fc93b028c3da83e601dc026450c8b","modified":1568784444013},{"_id":"themes/nexmoe/WIKI/en/Hexo/README.md","hash":"55e0dfdc52fa4cb133f8182cf29f5edd16dca34d","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/en/Hexo/notice.md","hash":"9fc526aff1afdcd6d4a74fdd051810101d490f01","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/en/Hexo/comment.md","hash":"445034e0ec92af4c7184f7db65d6c3f7863b4775","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/en/Hexo/use.md","hash":"c3e51cb400d61bf02724a7a4577c239c9a301f25","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/yarn.lock","hash":"a80010dc99f0f27af7c90c0aaa4e81f332b77d26","modified":1568784444030},{"_id":"themes/nexmoe/layout/_partial/_analytics/cnzz.ejs","hash":"345ed559b76930bed05e1b393c12f09d42c2312e","modified":1592293921836},{"_id":"themes/nexmoe/layout/_partial/_analytics/google.ejs","hash":"97f3a717495c8cc71d5d3c7ab69ddd589a69a038","modified":1592293921837},{"_id":"themes/nexmoe/layout/_partial/_analytics/baidu.ejs","hash":"cc782e1363c8bbb6277c3825bb9eac83762bc26d","modified":1592293921834},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtags.ejs","hash":"2c429eef83e712531a08de370b06f1f00ac7398b","modified":1592293921838},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtm-head.ejs","hash":"5638bed9cfe2e86aeee77adc883b2a3e1ecd76ff","modified":1592293921841},{"_id":"themes/nexmoe/layout/_partial/_analytics/la.ejs","hash":"e08b1f111068c62e625b6790e66d8a5f625246ba","modified":1592293921842},{"_id":"themes/nexmoe/layout/_partial/_analytics/tencent.ejs","hash":"6f7d514f157fbdb505e52dda2dc4f35dcdb2685e","modified":1592293921843},{"_id":"themes/nexmoe/layout/_partial/_comment/DiscussBot.ejs","hash":"92fb25b5204b325eb18eea0c15ddb4f4116e35e2","modified":1592293921845},{"_id":"themes/nexmoe/layout/_partial/_comment/disqusjs.ejs","hash":"7518e88f2504b9844f71190e079df07f51847472","modified":1592293921849},{"_id":"themes/nexmoe/layout/_partial/_comment/changyan.ejs","hash":"8a520fd9a9704208c23abcb689bae33acd1167db","modified":1592293921847},{"_id":"themes/nexmoe/layout/_partial/_comment/livere.ejs","hash":"e96e1510ba2a8ccb1edebc378c566fadaed09e50","modified":1592293921853},{"_id":"themes/nexmoe/layout/_partial/_comment/gitalk.ejs","hash":"a3a33112234fee49646a9c11fcbdf2ed1a7777a8","modified":1592293921850},{"_id":"themes/nexmoe/layout/_partial/_comment/disqus.ejs","hash":"e1e70a619cf3499ef8b054c8fb4b23865a554b6b","modified":1592293921848},{"_id":"themes/nexmoe/layout/_partial/_comment/gitment.ejs","hash":"d4a99db9f2daf7bcdbcf637f478d925d5d840fe4","modified":1592293921852},{"_id":"themes/nexmoe/layout/_partial/_comment/valine.ejs","hash":"97a699da23500cd6b16c857a60d123064d1653f9","modified":1592293921854},{"_id":"themes/nexmoe/layout/_partial/_analytics/gtm-body.ejs","hash":"1471e3a49ad6c93fd33b18545b43805c48695e23","modified":1592293921840},{"_id":"themes/nexmoe/cover.png","hash":"6a09620b1b5b71d481230bd75a2ef6c23b92f7c5","modified":1586139136000},{"_id":"themes/nexmoe/WIKI/package-lock.json","hash":"1997109d6b824afbdb21bed498a60417aa3e0356","modified":1568784444030},{"_id":"source/img/sky.jpg","hash":"0c23cd31377f34580345b386dc86f1335c1614bc","modified":1568712195945},{"_id":"themes/nexmoe/WIKI/en/component/basic/color.md","hash":"7d7c6a408b7d38a5f7cd608d0e852e4d0ac0bca4","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/en/component/basic/icon.md","hash":"3101ced9978917c9869fd99693a4eb73a29a25b2","modified":1568784444030},{"_id":"themes/nexmoe/WIKI/cover.png","hash":"933112bf55ba0dfff98fd8f3e670f12fe83d3c9f","modified":1568784444030},{"_id":"source/img/sky.png","hash":"b3a4f25d3deb45de8e2c6c02d16967d1f30ae404","modified":1568711923428},{"_id":"themes/nexmoe/layout/archive.ejs","hash":"334c024ff9357a0af10d3bbe1058e2860c9fa580","modified":1592293921875},{"_id":"themes/nexmoe/layout/_widget/search.ejs","hash":"588b01cf982e18a59e869f1cbf793511c219d89e","modified":1592293921870},{"_id":"themes/nexmoe/scripts/helper/image_auto_lazyload.js","hash":"7ccb73f9076d3b4e7ee27d10ed13a58ded631461","modified":1592293921883},{"_id":"themes/nexmoe/layout/_partial/_post/meta.ejs","hash":"1a6d6facbe095031341ccfe186b272d2c851a373","modified":1592293921856},{"_id":"themes/nexmoe/layout/_partial/_post/tag.ejs","hash":"c265ae74f31bb046922a052bb7d5eef4416d1357","modified":1592293921857},{"_id":"themes/nexmoe/source/lib/iconfont/demo.css","hash":"53456972a11d52af67187fc17999e6665f9f06fe","modified":1592293921892},{"_id":"themes/nexmoe/source/lib/iconfont/demo_index.html","hash":"41ff1559a0160b544758af3b3fdea42539a3401c","modified":1592293921893},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.css","hash":"b00fb806ddd7f3c348c072f8a7d4cc85eccc5e5d","modified":1592293921894},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.eot","hash":"023e66c7bf46aab7b1fe62c460ce1dd7101e716e","modified":1592293921895},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.js","hash":"72f02227a7e5dde54d127251ca8384f3379e9df0","modified":1592293921896},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.json","hash":"04f38ca7164acc5a34f78008e0c00146426f9a22","modified":1592293921898},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.svg","hash":"f79b9b4b00db3c44422b221d15c3bde64ee84625","modified":1592293921899},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.ttf","hash":"f4c12e214c6c20ff51d9a999c7d730fbacfdb988","modified":1592293921901},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff","hash":"7a4a3567ba960d969b4e2687927fcfd5aab32fbf","modified":1592293921902},{"_id":"themes/nexmoe/source/lib/iconfont/iconfont.woff2","hash":"527ae8a335a495d833dc3d77e65cc80c0945635c","modified":1592293921903},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/js/mdui.js","hash":"1b3f4e4b7d1b944dd2a8ca09cc60614435195c67","modified":1592293921910},{"_id":"themes/nexmoe/source/lib/mdui_043tiny/css/mdui.css","hash":"1500b5d27b8ce2e7c543bb6d7205de43059378db","modified":1592293921907},{"_id":"themes/nexmoe/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1592293921760},{"_id":"themes/nexmoe/.git/config","hash":"f6703c280dd8b9c6be5221ff230843588d3645ce","modified":1592293921780},{"_id":"themes/nexmoe/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1592293911813},{"_id":"themes/nexmoe/.git/index","hash":"208132aaeb63e1d450cc66ebd786b25ebccf9f88","modified":1592293921911},{"_id":"themes/nexmoe/.git/packed-refs","hash":"e727c2b19bcf8f0eedad9c5f39d80cd82b2f50f2","modified":1592293921742},{"_id":"themes/nexmoe/languages/ja.yml","hash":"9e133c840b2ec1b8da8a042b6e0bb814e33ee094","modified":1592293921826},{"_id":"themes/nexmoe/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1592293911923},{"_id":"themes/nexmoe/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1592293911950},{"_id":"themes/nexmoe/.git/hooks/fsmonitor-watchman.sample","hash":"a04bcd7925e722826245dd3085ddbc739ccf12ac","modified":1592293912026},{"_id":"themes/nexmoe/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1592293912076},{"_id":"themes/nexmoe/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1592293912084},{"_id":"themes/nexmoe/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1592293912092},{"_id":"themes/nexmoe/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1592293912099},{"_id":"themes/nexmoe/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1592293912104},{"_id":"themes/nexmoe/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1592293912106},{"_id":"themes/nexmoe/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1592293912108},{"_id":"themes/nexmoe/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1592293912141},{"_id":"themes/nexmoe/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1592293912155},{"_id":"themes/nexmoe/.git/logs/HEAD","hash":"11aa982fe02ed587838688da9f49e933ad3dee99","modified":1592293921767},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/bug_report_en.md","hash":"557484415c610222b16b58df470c2a768782c4fc","modified":1592293921807},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"d6c77dbb2a3d638d748280fb37dd29375aebe98c","modified":1592293921808},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/feature_request_en.md","hash":"803f6736473a122ed78867e64681defcd2edd954","modified":1592293921809},{"_id":"themes/nexmoe/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"843abf5e1d7b06cb1feddd75f7025150d46a91c2","modified":1592293921811},{"_id":"themes/nexmoe/.git/objects/pack/pack-6a9dd025356d6e9294f7e4623ea3cde17621df80.idx","hash":"7423bbfda9c98f7676d8d5fa49e911cb9c077581","modified":1592293921439},{"_id":"themes/nexmoe/.git/refs/heads/master","hash":"eca045dfc70287ccb0384dee401b08f2c0d2f9a2","modified":1592293921766},{"_id":"themes/nexmoe/.git/logs/refs/heads/master","hash":"11aa982fe02ed587838688da9f49e933ad3dee99","modified":1592293921770},{"_id":"themes/nexmoe/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1592293921756},{"_id":"themes/nexmoe/.git/logs/refs/remotes/origin/HEAD","hash":"11aa982fe02ed587838688da9f49e933ad3dee99","modified":1592293921756},{"_id":"themes/nexmoe/.git/objects/pack/pack-6a9dd025356d6e9294f7e4623ea3cde17621df80.pack","hash":"ff7842072d0576aabcd76d533b2efa82b6a911a7","modified":1592293921488}],"Category":[{"name":"JS","_id":"ck1jzmx6h0002egqnnofxcri8"},{"name":"杂记","_id":"ck1jzmx6n0007egqn9wo3qf6n"},{"name":"CSS","_id":"ck1jzmx6t000degqneq5ujw9q"}],"Data":[{"_id":"melody","data":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}],"Page":[{"title":"about","date":"2019-09-18T02:50:38.000Z","layout":"about","comments":1,"reward":false,"_content":"\n养狗撸狗的铲屎官\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-09-18 10:50:38\nlayout: about\ncomments: true\nreward: false\npermalink: about.html\n---\n\n养狗撸狗的铲屎官\n","updated":"2019-09-18T07:37:50.891Z","path":"about.html","_id":"ck1jzmx7i000tegqnh49il8cx","content":"<p>养狗撸狗的铲屎官</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>养狗撸狗的铲屎官</p>\n"},{"title":"分类","date":"2018-07-27T02:20:19.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-07-27 10:20:19\ntype: \"categories\"\n---\n","updated":"2019-09-18T03:00:17.428Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck1jzmx7p000vegqnvpphvg8p","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""},{"title":"标签","date":"2018-07-27T02:19:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-07-27 10:19:17\ntype: \"tags\"\n---\n","updated":"2019-09-18T03:00:17.428Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck1jzmx7t000yegqnygehlte6","content":"","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":""}],"Post":[{"title":"es10 新特性","date":"2019-09-29T01:14:22.000Z","_content":"\n本文主要介绍 es10 的新特性。\n\n<!-- more -->\n\n1. 数组方法 Array.flat() 和 Array.flatMap\n```Array.flat()``` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n```Array.flatMap()``` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\n```\n//  Array.flat() 示例：\nlet arr = [1, 2, [3, 4, [5, 6, 7, [8, 9]], 10]]\narr.flat(); // [1, 2, 3, 4, Array(4), 10] 效果等于 arr.flat(1)\narr.flat(2); // [1, 2, 3, 4, 5, 6, 7, Array(2), 10]\narr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n// Array.flatMap() 示例：\nlet arr1 = [1, 2, 3, 4, 5];\narr1.map(x => [x, x * 2]); \n// [Array(2), Array(2), Array(2), Array(2), Array(2)]\n// 0: (2) [1, 2]\n// 1: (2) [2, 4]\n// 2: (2) [3, 6]\n// 3: (2) [4, 8]\n// 4: (2) [5, 10]\narr1.flatMap(x => [x, x * 2]); //[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]\n```\n\n2. Object.fromEntries()\n```Object.fromEntries()``` 方法把键值对列表转换为一个对象。\n```\nlet obj = { apple : 10, orange : 20, banana : 30 };\nlet entries = Object.entries(obj);\n// 0: (2) [\"apple\", 10]\n// 1: (2) [\"orange\", 20]\n// 2: (2) [\"banana\", 30]\nlet fromEntries = Object.fromEntries(entries); // {apple: 10, orange: 20, banana: 30}\n```\n3. 字符串方法：trimStart 和 trimEnd\n```trimStart() ``` 删除字符串的开头空格。\n```trimEnd()``` 删除字符串末尾的空格。\n```\nlet s1 = '  你好呀~   ';\ns1.trimStart() // \"你好呀~   \"\ns1.trimEnd() // \"  你好呀~\"\ns1.trimStart().trimEnd() // \"你好呀~\"\n```\n4. try { } catch {} // catch 的参数可以省略了\n在过去，```try/catch``` 语句中的 ```catch``` 语句需要一个变量。 ```try/catch``` 语句帮助捕获终端级别的错误。在 ES10 中，捕获错误的变量是可选的，现在可以跳过错误变量：\n```\ntry {\n    return true;\n}\ncatch\n{\n    return false;\n}\n```","source":"_posts/es10新特性.md","raw":"---\ntitle: es10 新特性\ndate: 2019-09-29 09:14:22\ntags: ES10\ncategories: JS\n---\n\n本文主要介绍 es10 的新特性。\n\n<!-- more -->\n\n1. 数组方法 Array.flat() 和 Array.flatMap\n```Array.flat()``` 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。\n```Array.flatMap()``` 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。\n```\n//  Array.flat() 示例：\nlet arr = [1, 2, [3, 4, [5, 6, 7, [8, 9]], 10]]\narr.flat(); // [1, 2, 3, 4, Array(4), 10] 效果等于 arr.flat(1)\narr.flat(2); // [1, 2, 3, 4, 5, 6, 7, Array(2), 10]\narr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n// Array.flatMap() 示例：\nlet arr1 = [1, 2, 3, 4, 5];\narr1.map(x => [x, x * 2]); \n// [Array(2), Array(2), Array(2), Array(2), Array(2)]\n// 0: (2) [1, 2]\n// 1: (2) [2, 4]\n// 2: (2) [3, 6]\n// 3: (2) [4, 8]\n// 4: (2) [5, 10]\narr1.flatMap(x => [x, x * 2]); //[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]\n```\n\n2. Object.fromEntries()\n```Object.fromEntries()``` 方法把键值对列表转换为一个对象。\n```\nlet obj = { apple : 10, orange : 20, banana : 30 };\nlet entries = Object.entries(obj);\n// 0: (2) [\"apple\", 10]\n// 1: (2) [\"orange\", 20]\n// 2: (2) [\"banana\", 30]\nlet fromEntries = Object.fromEntries(entries); // {apple: 10, orange: 20, banana: 30}\n```\n3. 字符串方法：trimStart 和 trimEnd\n```trimStart() ``` 删除字符串的开头空格。\n```trimEnd()``` 删除字符串末尾的空格。\n```\nlet s1 = '  你好呀~   ';\ns1.trimStart() // \"你好呀~   \"\ns1.trimEnd() // \"  你好呀~\"\ns1.trimStart().trimEnd() // \"你好呀~\"\n```\n4. try { } catch {} // catch 的参数可以省略了\n在过去，```try/catch``` 语句中的 ```catch``` 语句需要一个变量。 ```try/catch``` 语句帮助捕获终端级别的错误。在 ES10 中，捕获错误的变量是可选的，现在可以跳过错误变量：\n```\ntry {\n    return true;\n}\ncatch\n{\n    return false;\n}\n```","slug":"es10新特性","published":1,"updated":"2019-09-29T02:01:23.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx690000egqno7r1g2ae","content":"<p>本文主要介绍 es10 的新特性。</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>数组方法 Array.flat() 和 Array.flatMap<br><code>Array.flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<br><code>Array.flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。</p>\n<pre><code>//  Array.flat() 示例：\nlet arr = [1, 2, [3, 4, [5, 6, 7, [8, 9]], 10]]\narr.flat(); // [1, 2, 3, 4, Array(4), 10] 效果等于 arr.flat(1)\narr.flat(2); // [1, 2, 3, 4, 5, 6, 7, Array(2), 10]\narr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n// Array.flatMap() 示例：\nlet arr1 = [1, 2, 3, 4, 5];\narr1.map(x =&gt; [x, x * 2]); \n// [Array(2), Array(2), Array(2), Array(2), Array(2)]\n// 0: (2) [1, 2]\n// 1: (2) [2, 4]\n// 2: (2) [3, 6]\n// 3: (2) [4, 8]\n// 4: (2) [5, 10]\narr1.flatMap(x =&gt; [x, x * 2]); //[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]\n</code></pre></li>\n<li><p>Object.fromEntries()<br><code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象。</p>\n<pre><code>let obj = { apple : 10, orange : 20, banana : 30 };\nlet entries = Object.entries(obj);\n// 0: (2) [&quot;apple&quot;, 10]\n// 1: (2) [&quot;orange&quot;, 20]\n// 2: (2) [&quot;banana&quot;, 30]\nlet fromEntries = Object.fromEntries(entries); // {apple: 10, orange: 20, banana: 30}\n</code></pre></li>\n<li>字符串方法：trimStart 和 trimEnd<br><code>trimStart()</code> 删除字符串的开头空格。<br><code>trimEnd()</code> 删除字符串末尾的空格。<pre><code>let s1 = &#39;  你好呀~   &#39;;\ns1.trimStart() // &quot;你好呀~   &quot;\ns1.trimEnd() // &quot;  你好呀~&quot;\ns1.trimStart().trimEnd() // &quot;你好呀~&quot;\n</code></pre></li>\n<li>try { } catch {} // catch 的参数可以省略了<br>在过去，<code>try/catch</code> 语句中的 <code>catch</code> 语句需要一个变量。 <code>try/catch</code> 语句帮助捕获终端级别的错误。在 ES10 中，捕获错误的变量是可选的，现在可以跳过错误变量：<pre><code>try {\n return true;\n}\ncatch\n{\n return false;\n}\n</code></pre></li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>本文主要介绍 es10 的新特性。</p>","more":"<ol>\n<li><p>数组方法 Array.flat() 和 Array.flatMap<br><code>Array.flat()</code> 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。<br><code>Array.flatMap()</code> 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。它与 map 和 深度值1的 flat 几乎相同，但 flatMap 通常在合并成一种方法的效率稍微高一些。</p>\n<pre><code>//  Array.flat() 示例：\nlet arr = [1, 2, [3, 4, [5, 6, 7, [8, 9]], 10]]\narr.flat(); // [1, 2, 3, 4, Array(4), 10] 效果等于 arr.flat(1)\narr.flat(2); // [1, 2, 3, 4, 5, 6, 7, Array(2), 10]\narr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\narr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n// Array.flatMap() 示例：\nlet arr1 = [1, 2, 3, 4, 5];\narr1.map(x =&gt; [x, x * 2]); \n// [Array(2), Array(2), Array(2), Array(2), Array(2)]\n// 0: (2) [1, 2]\n// 1: (2) [2, 4]\n// 2: (2) [3, 6]\n// 3: (2) [4, 8]\n// 4: (2) [5, 10]\narr1.flatMap(x =&gt; [x, x * 2]); //[1, 2, 2, 4, 3, 6, 4, 8, 5, 10]\n</code></pre></li>\n<li><p>Object.fromEntries()<br><code>Object.fromEntries()</code> 方法把键值对列表转换为一个对象。</p>\n<pre><code>let obj = { apple : 10, orange : 20, banana : 30 };\nlet entries = Object.entries(obj);\n// 0: (2) [&quot;apple&quot;, 10]\n// 1: (2) [&quot;orange&quot;, 20]\n// 2: (2) [&quot;banana&quot;, 30]\nlet fromEntries = Object.fromEntries(entries); // {apple: 10, orange: 20, banana: 30}\n</code></pre></li>\n<li>字符串方法：trimStart 和 trimEnd<br><code>trimStart()</code> 删除字符串的开头空格。<br><code>trimEnd()</code> 删除字符串末尾的空格。<pre><code>let s1 = &#39;  你好呀~   &#39;;\ns1.trimStart() // &quot;你好呀~   &quot;\ns1.trimEnd() // &quot;  你好呀~&quot;\ns1.trimStart().trimEnd() // &quot;你好呀~&quot;\n</code></pre></li>\n<li>try { } catch {} // catch 的参数可以省略了<br>在过去，<code>try/catch</code> 语句中的 <code>catch</code> 语句需要一个变量。 <code>try/catch</code> 语句帮助捕获终端级别的错误。在 ES10 中，捕获错误的变量是可选的，现在可以跳过错误变量：<pre><code>try {\n return true;\n}\ncatch\n{\n return false;\n}\n</code></pre></li>\n</ol>"},{"title":"创建我的博客啦","date":"2018-07-26T08:50:53.000Z","_content":"\n✿✿ヽ(°▽°)ノ✿创建我的新的博客啦~ 诶嘿嘿~\n","source":"_posts/first.md","raw":"---\ntitle: 创建我的博客啦\ndate: 2018-07-26 16:50:53\ntags: 杂记\ncategories: 杂记\n---\n\n✿✿ヽ(°▽°)ノ✿创建我的新的博客啦~ 诶嘿嘿~\n","slug":"first","published":1,"updated":"2019-09-18T03:00:17.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx6f0001egqn9t2ndkhq","content":"<p>✿✿ヽ(°▽°)ノ✿创建我的新的博客啦~ 诶嘿嘿~</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"","more":"<p>✿✿ヽ(°▽°)ノ✿创建我的新的博客啦~ 诶嘿嘿~</p>\n"},{"title":"BFC及其应用","date":"2019-09-20T01:43:21.000Z","_content":"\n本章内容将介绍下 BFC 的相关内容，带领大家去了解什么事 BFC。\n\n<!-- more -->\n\n1. 首先介绍下什么是 BFC？\nBFC（Block Formatting Context）块级格式上下文，是页面盒模型布局的一种 CSS 的渲染模式。BFC 可以相当于一个独立的容器，里面的元素与外面的元素互不影响。\n\n2. 如何形成 BFC？\n1) 根元素，即 HTML 元素\n2) float 的值不为 none 的元素\n3) overflow 的值不为 visible 的元素\n4) display 的值为 inline-block、table-cell、table-caption 的元素\n5) position 的值为 absolute 或 fixed 的元素\n\n3. BFC 的特性及应用\n1) 在同一个 BFC 下的两个元素之间的外边距会发生折叠\n```\n<style>\n    div{\n        width: 100px;\n        height: 100px;\n        background: rgb(226, 158, 158);\n        margin: 100px;\n    }\n</style>\n<body>\n    <div></div>\n    <div></div>\n</body>\n```\n![01](./01.png)\n效果如图，当两个 div 元素在同一个容器中时，边距会发生重叠，如果要两个边距不发生重叠，我们可以将两个元素放在不同的BFC中。\n2) 在 BFC 中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)\n3) 形成了 BFC 的区域不会与 float box 重叠，即BFC可以阻止元素被浮动元素覆盖。\n4) 计算 BFC 高度时，浮动元素也参与计算\n\n","source":"_posts/BFC及其应用.md","raw":"---\ntitle: BFC及其应用\ndate: 2019-09-20 09:43:21\ntags: CSS\ncategories: CSS\n---\n\n本章内容将介绍下 BFC 的相关内容，带领大家去了解什么事 BFC。\n\n<!-- more -->\n\n1. 首先介绍下什么是 BFC？\nBFC（Block Formatting Context）块级格式上下文，是页面盒模型布局的一种 CSS 的渲染模式。BFC 可以相当于一个独立的容器，里面的元素与外面的元素互不影响。\n\n2. 如何形成 BFC？\n1) 根元素，即 HTML 元素\n2) float 的值不为 none 的元素\n3) overflow 的值不为 visible 的元素\n4) display 的值为 inline-block、table-cell、table-caption 的元素\n5) position 的值为 absolute 或 fixed 的元素\n\n3. BFC 的特性及应用\n1) 在同一个 BFC 下的两个元素之间的外边距会发生折叠\n```\n<style>\n    div{\n        width: 100px;\n        height: 100px;\n        background: rgb(226, 158, 158);\n        margin: 100px;\n    }\n</style>\n<body>\n    <div></div>\n    <div></div>\n</body>\n```\n![01](./01.png)\n效果如图，当两个 div 元素在同一个容器中时，边距会发生重叠，如果要两个边距不发生重叠，我们可以将两个元素放在不同的BFC中。\n2) 在 BFC 中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)\n3) 形成了 BFC 的区域不会与 float box 重叠，即BFC可以阻止元素被浮动元素覆盖。\n4) 计算 BFC 高度时，浮动元素也参与计算\n\n","slug":"BFC及其应用","published":1,"updated":"2019-09-20T03:05:46.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx6j0004egqnu7nuyjt3","content":"<p>本章内容将介绍下 BFC 的相关内容，带领大家去了解什么事 BFC。</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>首先介绍下什么是 BFC？<br>BFC（Block Formatting Context）块级格式上下文，是页面盒模型布局的一种 CSS 的渲染模式。BFC 可以相当于一个独立的容器，里面的元素与外面的元素互不影响。</p>\n</li>\n<li><p>如何形成 BFC？<br>1) 根元素，即 HTML 元素<br>2) float 的值不为 none 的元素<br>3) overflow 的值不为 visible 的元素<br>4) display 的值为 inline-block、table-cell、table-caption 的元素<br>5) position 的值为 absolute 或 fixed 的元素</p>\n</li>\n<li><p>BFC 的特性及应用<br>1) 在同一个 BFC 下的两个元素之间的外边距会发生折叠</p>\n<pre><code>&lt;style&gt;\n div{\n     width: 100px;\n     height: 100px;\n     background: rgb(226, 158, 158);\n     margin: 100px;\n }\n&lt;/style&gt;\n&lt;body&gt;\n &lt;div&gt;&lt;/div&gt;\n &lt;div&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src=\"./01.png\" alt=\"01\"><br>效果如图，当两个 div 元素在同一个容器中时，边距会发生重叠，如果要两个边距不发生重叠，我们可以将两个元素放在不同的BFC中。<br>2) 在 BFC 中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)<br>3) 形成了 BFC 的区域不会与 float box 重叠，即BFC可以阻止元素被浮动元素覆盖。<br>4) 计算 BFC 高度时，浮动元素也参与计算</p>\n</li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>本章内容将介绍下 BFC 的相关内容，带领大家去了解什么事 BFC。</p>","more":"<ol>\n<li><p>首先介绍下什么是 BFC？<br>BFC（Block Formatting Context）块级格式上下文，是页面盒模型布局的一种 CSS 的渲染模式。BFC 可以相当于一个独立的容器，里面的元素与外面的元素互不影响。</p>\n</li>\n<li><p>如何形成 BFC？<br>1) 根元素，即 HTML 元素<br>2) float 的值不为 none 的元素<br>3) overflow 的值不为 visible 的元素<br>4) display 的值为 inline-block、table-cell、table-caption 的元素<br>5) position 的值为 absolute 或 fixed 的元素</p>\n</li>\n<li><p>BFC 的特性及应用<br>1) 在同一个 BFC 下的两个元素之间的外边距会发生折叠</p>\n<pre><code>&lt;style&gt;\n div{\n     width: 100px;\n     height: 100px;\n     background: rgb(226, 158, 158);\n     margin: 100px;\n }\n&lt;/style&gt;\n&lt;body&gt;\n &lt;div&gt;&lt;/div&gt;\n &lt;div&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src=\"./01.png\" alt=\"01\"><br>效果如图，当两个 div 元素在同一个容器中时，边距会发生重叠，如果要两个边距不发生重叠，我们可以将两个元素放在不同的BFC中。<br>2) 在 BFC 中，每一个盒子的左外边缘(margin-left)会触碰到容器的左边缘(border-left)(对于从右到左的格式来说，则触碰到右边缘)<br>3) 形成了 BFC 的区域不会与 float box 重叠，即BFC可以阻止元素被浮动元素覆盖。<br>4) 计算 BFC 高度时，浮动元素也参与计算</p>\n</li>\n</ol>"},{"title":"如何制作blog","date":"2018-07-27T02:37:55.000Z","_content":"\n> 这是一篇关于如何用 github page 和 hexo 搭建博客的文章，因为技术太菜我打了一天才搭好，哭唧唧~(；д；) 今天就写出来告诉大家怎么搭建吧~ \n\n<!-- more -->\n\n1. 首先你要有个 github 账号，没有账号就去注册一个，不知道怎么注册的话去百度或者 google 一下。\n2. 然后你要新建一个仓库~ 仓库名称需要遵循一个规则，格式必须是：yourusername.github.io\n3. 准备 hexo 环境：\n    * 安装 node 环境(这一个步骤自己上网找怎么安装哈~ヾ(◍°∇°◍)ﾉﾞ)\n    * 安装 Hexo \n    ```\n        sudo npm install -g hexo-cl\n    ```\n    * 检查是否安装 \n    ```\n        hexo version\n    ```\n    * 手动创建一个放置 blog 的文件夹，创建完成后初始化 blog 目录\n    ```\n        hexo init <yourFloder>\n    ```\n    * hexo 的一些常用命令\n    ```\n        hexo new \"postName\" #新建文章\n        hexo new page \"pageName\" #新建页面\n        hexo generate #生成静态页面至public目录\n        hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n        hexo deploy #将.deploy目录部署到GitHub\n        hexo help #查看帮助\n    ```\n4. 配置你的 hexo\n   在创建完成之后，你会在对应的文件夹里面看到一个文件名为\"_config.yml\"的文件，在里面可以修改你的配置。\n   这边有一个对该文件的说明[ hexo 配置](https://hexo.io/zh-cn/docs/configuration.html)，参照文档进行修改~\n5. 关联 hexo 与 github\n   * 安装扩展\n    ```\n    npm install hexo-deployer-git --save\n    ```\n    * 修改\"_config.yml\"文件，配置如下：\n    ```\n    deploy:\n        type: git\n        repo: 刚刚步骤 '2' 中你创建的 github 地址\n        branch: master\n    ```\n    * 执行下列代码之后你写的博客内容就会上传至 github 了\n    ```\n    hexo clean \n    hexo generate\n    hexo deploy\n    ```\n\n","source":"_posts/如何制作blog.md","raw":"---\ntitle: 如何制作blog\ndate: 2018-07-27 10:37:55\ntags: hexo\ncategories: JS\n---\n\n> 这是一篇关于如何用 github page 和 hexo 搭建博客的文章，因为技术太菜我打了一天才搭好，哭唧唧~(；д；) 今天就写出来告诉大家怎么搭建吧~ \n\n<!-- more -->\n\n1. 首先你要有个 github 账号，没有账号就去注册一个，不知道怎么注册的话去百度或者 google 一下。\n2. 然后你要新建一个仓库~ 仓库名称需要遵循一个规则，格式必须是：yourusername.github.io\n3. 准备 hexo 环境：\n    * 安装 node 环境(这一个步骤自己上网找怎么安装哈~ヾ(◍°∇°◍)ﾉﾞ)\n    * 安装 Hexo \n    ```\n        sudo npm install -g hexo-cl\n    ```\n    * 检查是否安装 \n    ```\n        hexo version\n    ```\n    * 手动创建一个放置 blog 的文件夹，创建完成后初始化 blog 目录\n    ```\n        hexo init <yourFloder>\n    ```\n    * hexo 的一些常用命令\n    ```\n        hexo new \"postName\" #新建文章\n        hexo new page \"pageName\" #新建页面\n        hexo generate #生成静态页面至public目录\n        hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n        hexo deploy #将.deploy目录部署到GitHub\n        hexo help #查看帮助\n    ```\n4. 配置你的 hexo\n   在创建完成之后，你会在对应的文件夹里面看到一个文件名为\"_config.yml\"的文件，在里面可以修改你的配置。\n   这边有一个对该文件的说明[ hexo 配置](https://hexo.io/zh-cn/docs/configuration.html)，参照文档进行修改~\n5. 关联 hexo 与 github\n   * 安装扩展\n    ```\n    npm install hexo-deployer-git --save\n    ```\n    * 修改\"_config.yml\"文件，配置如下：\n    ```\n    deploy:\n        type: git\n        repo: 刚刚步骤 '2' 中你创建的 github 地址\n        branch: master\n    ```\n    * 执行下列代码之后你写的博客内容就会上传至 github 了\n    ```\n    hexo clean \n    hexo generate\n    hexo deploy\n    ```\n\n","slug":"如何制作blog","published":1,"updated":"2019-09-18T09:02:58.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx6l0006egqn7lwo5g3x","content":"<blockquote>\n<p>这是一篇关于如何用 github page 和 hexo 搭建博客的文章，因为技术太菜我打了一天才搭好，哭唧唧~(；д；) 今天就写出来告诉大家怎么搭建吧~ </p>\n</blockquote>\n<a id=\"more\"></a>\n<ol>\n<li>首先你要有个 github 账号，没有账号就去注册一个，不知道怎么注册的话去百度或者 google 一下。</li>\n<li>然后你要新建一个仓库~ 仓库名称需要遵循一个规则，格式必须是：yourusername.github.io</li>\n<li>准备 hexo 环境：<ul>\n<li>安装 node 环境(这一个步骤自己上网找怎么安装哈~ヾ(◍°∇°◍)ﾉﾞ)</li>\n<li>安装 Hexo <pre><code>  sudo npm install -g hexo-cl\n</code></pre></li>\n<li>检查是否安装 <pre><code>  hexo version\n</code></pre></li>\n<li>手动创建一个放置 blog 的文件夹，创建完成后初始化 blog 目录<pre><code>  hexo init &lt;yourFloder&gt;\n</code></pre></li>\n<li>hexo 的一些常用命令<pre><code>  hexo new &quot;postName&quot; #新建文章\n  hexo new page &quot;pageName&quot; #新建页面\n  hexo generate #生成静态页面至public目录\n  hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\n  hexo deploy #将.deploy目录部署到GitHub\n  hexo help #查看帮助\n</code></pre></li>\n</ul>\n</li>\n<li>配置你的 hexo<br>在创建完成之后，你会在对应的文件夹里面看到一个文件名为”_config.yml”的文件，在里面可以修改你的配置。<br>这边有一个对该文件的说明<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\"> hexo 配置</a>，参照文档进行修改~</li>\n<li>关联 hexo 与 github<ul>\n<li>安装扩展<pre><code>npm install hexo-deployer-git --save\n</code></pre><ul>\n<li>修改”_config.yml”文件，配置如下：<pre><code>deploy:\n type: git\n repo: 刚刚步骤 &#39;2&#39; 中你创建的 github 地址\n branch: master\n</code></pre></li>\n<li>执行下列代码之后你写的博客内容就会上传至 github 了<pre><code>hexo clean \nhexo generate\nhexo deploy\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>这是一篇关于如何用 github page 和 hexo 搭建博客的文章，因为技术太菜我打了一天才搭好，哭唧唧~(；д；) 今天就写出来告诉大家怎么搭建吧~ </p>\n</blockquote>","more":"<ol>\n<li>首先你要有个 github 账号，没有账号就去注册一个，不知道怎么注册的话去百度或者 google 一下。</li>\n<li>然后你要新建一个仓库~ 仓库名称需要遵循一个规则，格式必须是：yourusername.github.io</li>\n<li>准备 hexo 环境：<ul>\n<li>安装 node 环境(这一个步骤自己上网找怎么安装哈~ヾ(◍°∇°◍)ﾉﾞ)</li>\n<li>安装 Hexo <pre><code>  sudo npm install -g hexo-cl\n</code></pre></li>\n<li>检查是否安装 <pre><code>  hexo version\n</code></pre></li>\n<li>手动创建一个放置 blog 的文件夹，创建完成后初始化 blog 目录<pre><code>  hexo init &lt;yourFloder&gt;\n</code></pre></li>\n<li>hexo 的一些常用命令<pre><code>  hexo new &quot;postName&quot; #新建文章\n  hexo new page &quot;pageName&quot; #新建页面\n  hexo generate #生成静态页面至public目录\n  hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）\n  hexo deploy #将.deploy目录部署到GitHub\n  hexo help #查看帮助\n</code></pre></li>\n</ul>\n</li>\n<li>配置你的 hexo<br>在创建完成之后，你会在对应的文件夹里面看到一个文件名为”_config.yml”的文件，在里面可以修改你的配置。<br>这边有一个对该文件的说明<a href=\"https://hexo.io/zh-cn/docs/configuration.html\" target=\"_blank\" rel=\"noopener\"> hexo 配置</a>，参照文档进行修改~</li>\n<li>关联 hexo 与 github<ul>\n<li>安装扩展<pre><code>npm install hexo-deployer-git --save\n</code></pre><ul>\n<li>修改”_config.yml”文件，配置如下：<pre><code>deploy:\n type: git\n repo: 刚刚步骤 &#39;2&#39; 中你创建的 github 地址\n branch: master\n</code></pre></li>\n<li>执行下列代码之后你写的博客内容就会上传至 github 了<pre><code>hexo clean \nhexo generate\nhexo deploy\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>"},{"title":"gittalk安装使用教程","date":"2019-09-19T00:57:23.000Z","_content":"\n引用了新的主题之后，加入了评论功能，评论使用的是gittalk，下面介绍下gittalk的使用教程。\n\n<!-- more -->\n\n1. gittalk 需要你有自己的 github 账号，这一步请大家自己上网百度如何有自己的 github 账号。\n\n2. 拥有 github 账号之后， 点击头像，点击 settings\n![settings](./01.png)\n\n3. 点击 Developer settings\n![Developer settings](./02.png)\n\n4. 点击 OAuth Apps，点击 New OAuth Apps\n![OAuth Apps](./03.png)\n\n5. 接下来我们会看到这个页面\n![New OAuth Apps](./04.png)\n* ```Application name```： 填写你的应用的名称\n* ```Homepage URL```：填写你博客仓库的地址\n* ```Application description```：填写应用的表述\n* ```Authorization callback URL```：填写博客的地址\n这边要注意两个 url 内容不要填错了，填错的话可能就会出问题哦。\n\n6. 有时你会遇到 gittalk error: validation failed. 这个错误。\n遇到这个错误时，需要找到你这边主题创建 gittalk 的地方，找到 id，增加 decodeURI。\n```\nvar gitalk = new Gitalk({\n    clientID: '<%= theme.gitalk.clientID %>',\n    clientSecret: '<%= theme.gitalk.clientSecret %>',\n    id: decodeURI(window.location.pathname),\n    repo: '<%= theme.gitalk.repo %>',\n    owner: '<%= theme.gitalk.owner %>',\n    admin: '<%= theme.gitalk.admin %>'\n})\ngitalk.render('gitalk')\n```\n\n7. 有时你会遇到 Error:Not found 这个错误.\n这个错误的产生主要是第5步内容填写的不对，url内容需要按照上面的正确填写哦。  \n\n✿✿ヽ(°▽°)ノ✿","source":"_posts/gittalk安装使用教程.md","raw":"---\ntitle: gittalk安装使用教程\ndate: 2019-09-19 08:57:23\ntags: hexo\ncategories: JS\n---\n\n引用了新的主题之后，加入了评论功能，评论使用的是gittalk，下面介绍下gittalk的使用教程。\n\n<!-- more -->\n\n1. gittalk 需要你有自己的 github 账号，这一步请大家自己上网百度如何有自己的 github 账号。\n\n2. 拥有 github 账号之后， 点击头像，点击 settings\n![settings](./01.png)\n\n3. 点击 Developer settings\n![Developer settings](./02.png)\n\n4. 点击 OAuth Apps，点击 New OAuth Apps\n![OAuth Apps](./03.png)\n\n5. 接下来我们会看到这个页面\n![New OAuth Apps](./04.png)\n* ```Application name```： 填写你的应用的名称\n* ```Homepage URL```：填写你博客仓库的地址\n* ```Application description```：填写应用的表述\n* ```Authorization callback URL```：填写博客的地址\n这边要注意两个 url 内容不要填错了，填错的话可能就会出问题哦。\n\n6. 有时你会遇到 gittalk error: validation failed. 这个错误。\n遇到这个错误时，需要找到你这边主题创建 gittalk 的地方，找到 id，增加 decodeURI。\n```\nvar gitalk = new Gitalk({\n    clientID: '<%= theme.gitalk.clientID %>',\n    clientSecret: '<%= theme.gitalk.clientSecret %>',\n    id: decodeURI(window.location.pathname),\n    repo: '<%= theme.gitalk.repo %>',\n    owner: '<%= theme.gitalk.owner %>',\n    admin: '<%= theme.gitalk.admin %>'\n})\ngitalk.render('gitalk')\n```\n\n7. 有时你会遇到 Error:Not found 这个错误.\n这个错误的产生主要是第5步内容填写的不对，url内容需要按照上面的正确填写哦。  \n\n✿✿ヽ(°▽°)ノ✿","slug":"gittalk安装使用教程","published":1,"updated":"2019-09-19T01:46:23.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx6p000aegqnr2ynd53l","content":"<p>引用了新的主题之后，加入了评论功能，评论使用的是gittalk，下面介绍下gittalk的使用教程。</p>\n<a id=\"more\"></a>\n<ol>\n<li><p>gittalk 需要你有自己的 github 账号，这一步请大家自己上网百度如何有自己的 github 账号。</p>\n</li>\n<li><p>拥有 github 账号之后， 点击头像，点击 settings<br><img src=\"./01.png\" alt=\"settings\"></p>\n</li>\n<li><p>点击 Developer settings<br><img src=\"./02.png\" alt=\"Developer settings\"></p>\n</li>\n<li><p>点击 OAuth Apps，点击 New OAuth Apps<br><img src=\"./03.png\" alt=\"OAuth Apps\"></p>\n</li>\n<li><p>接下来我们会看到这个页面<br><img src=\"./04.png\" alt=\"New OAuth Apps\"></p>\n</li>\n</ol>\n<ul>\n<li><code>Application name</code>： 填写你的应用的名称</li>\n<li><code>Homepage URL</code>：填写你博客仓库的地址</li>\n<li><code>Application description</code>：填写应用的表述</li>\n<li><code>Authorization callback URL</code>：填写博客的地址<br>这边要注意两个 url 内容不要填错了，填错的话可能就会出问题哦。</li>\n</ul>\n<ol start=\"6\">\n<li><p>有时你会遇到 gittalk error: validation failed. 这个错误。<br>遇到这个错误时，需要找到你这边主题创建 gittalk 的地方，找到 id，增加 decodeURI。</p>\n<pre><code>var gitalk = new Gitalk({\n clientID: &#39;&lt;%= theme.gitalk.clientID %&gt;&#39;,\n clientSecret: &#39;&lt;%= theme.gitalk.clientSecret %&gt;&#39;,\n id: decodeURI(window.location.pathname),\n repo: &#39;&lt;%= theme.gitalk.repo %&gt;&#39;,\n owner: &#39;&lt;%= theme.gitalk.owner %&gt;&#39;,\n admin: &#39;&lt;%= theme.gitalk.admin %&gt;&#39;\n})\ngitalk.render(&#39;gitalk&#39;)\n</code></pre></li>\n<li><p>有时你会遇到 Error:Not found 这个错误.<br>这个错误的产生主要是第5步内容填写的不对，url内容需要按照上面的正确填写哦。  </p>\n</li>\n</ol>\n<p>✿✿ヽ(°▽°)ノ✿</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>引用了新的主题之后，加入了评论功能，评论使用的是gittalk，下面介绍下gittalk的使用教程。</p>","more":"<ol>\n<li><p>gittalk 需要你有自己的 github 账号，这一步请大家自己上网百度如何有自己的 github 账号。</p>\n</li>\n<li><p>拥有 github 账号之后， 点击头像，点击 settings<br><img src=\"./01.png\" alt=\"settings\"></p>\n</li>\n<li><p>点击 Developer settings<br><img src=\"./02.png\" alt=\"Developer settings\"></p>\n</li>\n<li><p>点击 OAuth Apps，点击 New OAuth Apps<br><img src=\"./03.png\" alt=\"OAuth Apps\"></p>\n</li>\n<li><p>接下来我们会看到这个页面<br><img src=\"./04.png\" alt=\"New OAuth Apps\"></p>\n</li>\n</ol>\n<ul>\n<li><code>Application name</code>： 填写你的应用的名称</li>\n<li><code>Homepage URL</code>：填写你博客仓库的地址</li>\n<li><code>Application description</code>：填写应用的表述</li>\n<li><code>Authorization callback URL</code>：填写博客的地址<br>这边要注意两个 url 内容不要填错了，填错的话可能就会出问题哦。</li>\n</ul>\n<ol start=\"6\">\n<li><p>有时你会遇到 gittalk error: validation failed. 这个错误。<br>遇到这个错误时，需要找到你这边主题创建 gittalk 的地方，找到 id，增加 decodeURI。</p>\n<pre><code>var gitalk = new Gitalk({\n clientID: &#39;&lt;%= theme.gitalk.clientID %&gt;&#39;,\n clientSecret: &#39;&lt;%= theme.gitalk.clientSecret %&gt;&#39;,\n id: decodeURI(window.location.pathname),\n repo: &#39;&lt;%= theme.gitalk.repo %&gt;&#39;,\n owner: &#39;&lt;%= theme.gitalk.owner %&gt;&#39;,\n admin: &#39;&lt;%= theme.gitalk.admin %&gt;&#39;\n})\ngitalk.render(&#39;gitalk&#39;)\n</code></pre></li>\n<li><p>有时你会遇到 Error:Not found 这个错误.<br>这个错误的产生主要是第5步内容填写的不对，url内容需要按照上面的正确填写哦。  </p>\n</li>\n</ol>\n<p>✿✿ヽ(°▽°)ノ✿</p>"},{"title":"【JS进阶】你真的掌握变量和类型了吗","date":"2019-05-28T01:29:12.000Z","_content":"\n> 【JS进阶】你真的掌握变量和类型了吗, [参考地址](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)\n\n<!-- more -->\n\n这篇文章记录了变量和类型的一些内容，我觉得内容还挺好的，在这边分享给大家。\n\n## [JavaScript数据类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-1)\n### 原始类型\nNull：只包含一个值：null\nUndefined：只包含一个值：undefined\nBoolean：包含两个值：true 和 false\nNumber：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）\nString：一串表示文本值的字符序列\nSymbol：一种实例是唯一且不可改变的数据类型\n\n(在es10中加入了第七种原始类型 BigInt，现已被最新 Chrome 支持)\n### 对象类型\n\nObject：除了常用的 Object，Array、Function 等都属于特殊的对象\n\n## [为什么区分原始类型和对象类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-2)\n### 不可变性\n### 引用类型\n### 复制\n### 比较\n### 值传递和引用传递\n\n## [分不清的 Null 和 Undefined](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-8)\n\n## [不太熟的 Symbol 类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-9)\n### Symbol 的特性\n### Symbol 的应用场景\n\n## [不老实的 Number 类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-12)\n### 精度丢失\n### 对结果的分析—更多的问题\n### js 对二进制小数的存储方式\n### IEEE 754\n### js中的toString(2)\n### JavaScript能表示的最大数字\n### 最大安全数字\n\n## [还有哪些引用类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-20)\n### 包装类型\n### 装箱和拆箱\n\n## [类型转换](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-23)\n### 类型转换规则\n### if 语句和逻辑语句\n### 各种运数学算符\n### ==\n### 一道有意思的面试题\n\n## [判断 JavaScript 数据类型的方式](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-29)\n### typeof\n### instanceof\n### toString\n### jquery\n","source":"_posts/【JS进阶】你真的掌握变量和类型了吗.md","raw":"---\ntitle: 【JS进阶】你真的掌握变量和类型了吗\ndate: 2019-05-28 09:29:12\ntags: JS\ncategories: JS\n---\n\n> 【JS进阶】你真的掌握变量和类型了吗, [参考地址](https://juejin.im/post/5cec1bcff265da1b8f1aa08f)\n\n<!-- more -->\n\n这篇文章记录了变量和类型的一些内容，我觉得内容还挺好的，在这边分享给大家。\n\n## [JavaScript数据类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-1)\n### 原始类型\nNull：只包含一个值：null\nUndefined：只包含一个值：undefined\nBoolean：包含两个值：true 和 false\nNumber：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）\nString：一串表示文本值的字符序列\nSymbol：一种实例是唯一且不可改变的数据类型\n\n(在es10中加入了第七种原始类型 BigInt，现已被最新 Chrome 支持)\n### 对象类型\n\nObject：除了常用的 Object，Array、Function 等都属于特殊的对象\n\n## [为什么区分原始类型和对象类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-2)\n### 不可变性\n### 引用类型\n### 复制\n### 比较\n### 值传递和引用传递\n\n## [分不清的 Null 和 Undefined](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-8)\n\n## [不太熟的 Symbol 类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-9)\n### Symbol 的特性\n### Symbol 的应用场景\n\n## [不老实的 Number 类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-12)\n### 精度丢失\n### 对结果的分析—更多的问题\n### js 对二进制小数的存储方式\n### IEEE 754\n### js中的toString(2)\n### JavaScript能表示的最大数字\n### 最大安全数字\n\n## [还有哪些引用类型](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-20)\n### 包装类型\n### 装箱和拆箱\n\n## [类型转换](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-23)\n### 类型转换规则\n### if 语句和逻辑语句\n### 各种运数学算符\n### ==\n### 一道有意思的面试题\n\n## [判断 JavaScript 数据类型的方式](https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-29)\n### typeof\n### instanceof\n### toString\n### jquery\n","slug":"【JS进阶】你真的掌握变量和类型了吗","published":1,"updated":"2019-09-18T03:00:17.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx6r000begqn367l1la9","content":"<blockquote>\n<p>【JS进阶】你真的掌握变量和类型了吗, <a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f\" target=\"_blank\" rel=\"noopener\">参考地址</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<p>这篇文章记录了变量和类型的一些内容，我觉得内容还挺好的，在这边分享给大家。</p>\n<h2 id=\"JavaScript数据类型\"><a href=\"#JavaScript数据类型\" class=\"headerlink\" title=\"JavaScript数据类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-1\" target=\"_blank\" rel=\"noopener\">JavaScript数据类型</a></h2><h3 id=\"原始类型\"><a href=\"#原始类型\" class=\"headerlink\" title=\"原始类型\"></a>原始类型</h3><p>Null：只包含一个值：null<br>Undefined：只包含一个值：undefined<br>Boolean：包含两个值：true 和 false<br>Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）<br>String：一串表示文本值的字符序列<br>Symbol：一种实例是唯一且不可改变的数据类型</p>\n<p>(在es10中加入了第七种原始类型 BigInt，现已被最新 Chrome 支持)</p>\n<h3 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h3><p>Object：除了常用的 Object，Array、Function 等都属于特殊的对象</p>\n<h2 id=\"为什么区分原始类型和对象类型\"><a href=\"#为什么区分原始类型和对象类型\" class=\"headerlink\" title=\"为什么区分原始类型和对象类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-2\" target=\"_blank\" rel=\"noopener\">为什么区分原始类型和对象类型</a></h2><h3 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h3><h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h3 id=\"值传递和引用传递\"><a href=\"#值传递和引用传递\" class=\"headerlink\" title=\"值传递和引用传递\"></a>值传递和引用传递</h3><h2 id=\"分不清的-Null-和-Undefined\"><a href=\"#分不清的-Null-和-Undefined\" class=\"headerlink\" title=\"分不清的 Null 和 Undefined\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-8\" target=\"_blank\" rel=\"noopener\">分不清的 Null 和 Undefined</a></h2><h2 id=\"不太熟的-Symbol-类型\"><a href=\"#不太熟的-Symbol-类型\" class=\"headerlink\" title=\"不太熟的 Symbol 类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-9\" target=\"_blank\" rel=\"noopener\">不太熟的 Symbol 类型</a></h2><h3 id=\"Symbol-的特性\"><a href=\"#Symbol-的特性\" class=\"headerlink\" title=\"Symbol 的特性\"></a>Symbol 的特性</h3><h3 id=\"Symbol-的应用场景\"><a href=\"#Symbol-的应用场景\" class=\"headerlink\" title=\"Symbol 的应用场景\"></a>Symbol 的应用场景</h3><h2 id=\"不老实的-Number-类型\"><a href=\"#不老实的-Number-类型\" class=\"headerlink\" title=\"不老实的 Number 类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-12\" target=\"_blank\" rel=\"noopener\">不老实的 Number 类型</a></h2><h3 id=\"精度丢失\"><a href=\"#精度丢失\" class=\"headerlink\" title=\"精度丢失\"></a>精度丢失</h3><h3 id=\"对结果的分析—更多的问题\"><a href=\"#对结果的分析—更多的问题\" class=\"headerlink\" title=\"对结果的分析—更多的问题\"></a>对结果的分析—更多的问题</h3><h3 id=\"js-对二进制小数的存储方式\"><a href=\"#js-对二进制小数的存储方式\" class=\"headerlink\" title=\"js 对二进制小数的存储方式\"></a>js 对二进制小数的存储方式</h3><h3 id=\"IEEE-754\"><a href=\"#IEEE-754\" class=\"headerlink\" title=\"IEEE 754\"></a>IEEE 754</h3><h3 id=\"js中的toString-2\"><a href=\"#js中的toString-2\" class=\"headerlink\" title=\"js中的toString(2)\"></a>js中的toString(2)</h3><h3 id=\"JavaScript能表示的最大数字\"><a href=\"#JavaScript能表示的最大数字\" class=\"headerlink\" title=\"JavaScript能表示的最大数字\"></a>JavaScript能表示的最大数字</h3><h3 id=\"最大安全数字\"><a href=\"#最大安全数字\" class=\"headerlink\" title=\"最大安全数字\"></a>最大安全数字</h3><h2 id=\"还有哪些引用类型\"><a href=\"#还有哪些引用类型\" class=\"headerlink\" title=\"还有哪些引用类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-20\" target=\"_blank\" rel=\"noopener\">还有哪些引用类型</a></h2><h3 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h3><h3 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h3><h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-23\" target=\"_blank\" rel=\"noopener\">类型转换</a></h2><h3 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h3><h3 id=\"if-语句和逻辑语句\"><a href=\"#if-语句和逻辑语句\" class=\"headerlink\" title=\"if 语句和逻辑语句\"></a>if 语句和逻辑语句</h3><h3 id=\"各种运数学算符\"><a href=\"#各种运数学算符\" class=\"headerlink\" title=\"各种运数学算符\"></a>各种运数学算符</h3><h3 id><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h3><h3 id=\"一道有意思的面试题\"><a href=\"#一道有意思的面试题\" class=\"headerlink\" title=\"一道有意思的面试题\"></a>一道有意思的面试题</h3><h2 id=\"判断-JavaScript-数据类型的方式\"><a href=\"#判断-JavaScript-数据类型的方式\" class=\"headerlink\" title=\"判断 JavaScript 数据类型的方式\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-29\" target=\"_blank\" rel=\"noopener\">判断 JavaScript 数据类型的方式</a></h2><h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>【JS进阶】你真的掌握变量和类型了吗, <a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f\" target=\"_blank\" rel=\"noopener\">参考地址</a></p>\n</blockquote>","more":"<p>这篇文章记录了变量和类型的一些内容，我觉得内容还挺好的，在这边分享给大家。</p>\n<h2 id=\"JavaScript数据类型\"><a href=\"#JavaScript数据类型\" class=\"headerlink\" title=\"JavaScript数据类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-1\" target=\"_blank\" rel=\"noopener\">JavaScript数据类型</a></h2><h3 id=\"原始类型\"><a href=\"#原始类型\" class=\"headerlink\" title=\"原始类型\"></a>原始类型</h3><p>Null：只包含一个值：null<br>Undefined：只包含一个值：undefined<br>Boolean：包含两个值：true 和 false<br>Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN）<br>String：一串表示文本值的字符序列<br>Symbol：一种实例是唯一且不可改变的数据类型</p>\n<p>(在es10中加入了第七种原始类型 BigInt，现已被最新 Chrome 支持)</p>\n<h3 id=\"对象类型\"><a href=\"#对象类型\" class=\"headerlink\" title=\"对象类型\"></a>对象类型</h3><p>Object：除了常用的 Object，Array、Function 等都属于特殊的对象</p>\n<h2 id=\"为什么区分原始类型和对象类型\"><a href=\"#为什么区分原始类型和对象类型\" class=\"headerlink\" title=\"为什么区分原始类型和对象类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-2\" target=\"_blank\" rel=\"noopener\">为什么区分原始类型和对象类型</a></h2><h3 id=\"不可变性\"><a href=\"#不可变性\" class=\"headerlink\" title=\"不可变性\"></a>不可变性</h3><h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h3 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h3><h3 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h3><h3 id=\"值传递和引用传递\"><a href=\"#值传递和引用传递\" class=\"headerlink\" title=\"值传递和引用传递\"></a>值传递和引用传递</h3><h2 id=\"分不清的-Null-和-Undefined\"><a href=\"#分不清的-Null-和-Undefined\" class=\"headerlink\" title=\"分不清的 Null 和 Undefined\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-8\" target=\"_blank\" rel=\"noopener\">分不清的 Null 和 Undefined</a></h2><h2 id=\"不太熟的-Symbol-类型\"><a href=\"#不太熟的-Symbol-类型\" class=\"headerlink\" title=\"不太熟的 Symbol 类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-9\" target=\"_blank\" rel=\"noopener\">不太熟的 Symbol 类型</a></h2><h3 id=\"Symbol-的特性\"><a href=\"#Symbol-的特性\" class=\"headerlink\" title=\"Symbol 的特性\"></a>Symbol 的特性</h3><h3 id=\"Symbol-的应用场景\"><a href=\"#Symbol-的应用场景\" class=\"headerlink\" title=\"Symbol 的应用场景\"></a>Symbol 的应用场景</h3><h2 id=\"不老实的-Number-类型\"><a href=\"#不老实的-Number-类型\" class=\"headerlink\" title=\"不老实的 Number 类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-12\" target=\"_blank\" rel=\"noopener\">不老实的 Number 类型</a></h2><h3 id=\"精度丢失\"><a href=\"#精度丢失\" class=\"headerlink\" title=\"精度丢失\"></a>精度丢失</h3><h3 id=\"对结果的分析—更多的问题\"><a href=\"#对结果的分析—更多的问题\" class=\"headerlink\" title=\"对结果的分析—更多的问题\"></a>对结果的分析—更多的问题</h3><h3 id=\"js-对二进制小数的存储方式\"><a href=\"#js-对二进制小数的存储方式\" class=\"headerlink\" title=\"js 对二进制小数的存储方式\"></a>js 对二进制小数的存储方式</h3><h3 id=\"IEEE-754\"><a href=\"#IEEE-754\" class=\"headerlink\" title=\"IEEE 754\"></a>IEEE 754</h3><h3 id=\"js中的toString-2\"><a href=\"#js中的toString-2\" class=\"headerlink\" title=\"js中的toString(2)\"></a>js中的toString(2)</h3><h3 id=\"JavaScript能表示的最大数字\"><a href=\"#JavaScript能表示的最大数字\" class=\"headerlink\" title=\"JavaScript能表示的最大数字\"></a>JavaScript能表示的最大数字</h3><h3 id=\"最大安全数字\"><a href=\"#最大安全数字\" class=\"headerlink\" title=\"最大安全数字\"></a>最大安全数字</h3><h2 id=\"还有哪些引用类型\"><a href=\"#还有哪些引用类型\" class=\"headerlink\" title=\"还有哪些引用类型\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-20\" target=\"_blank\" rel=\"noopener\">还有哪些引用类型</a></h2><h3 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h3><h3 id=\"装箱和拆箱\"><a href=\"#装箱和拆箱\" class=\"headerlink\" title=\"装箱和拆箱\"></a>装箱和拆箱</h3><h2 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-23\" target=\"_blank\" rel=\"noopener\">类型转换</a></h2><h3 id=\"类型转换规则\"><a href=\"#类型转换规则\" class=\"headerlink\" title=\"类型转换规则\"></a>类型转换规则</h3><h3 id=\"if-语句和逻辑语句\"><a href=\"#if-语句和逻辑语句\" class=\"headerlink\" title=\"if 语句和逻辑语句\"></a>if 语句和逻辑语句</h3><h3 id=\"各种运数学算符\"><a href=\"#各种运数学算符\" class=\"headerlink\" title=\"各种运数学算符\"></a>各种运数学算符</h3><h3 id><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h3><h3 id=\"一道有意思的面试题\"><a href=\"#一道有意思的面试题\" class=\"headerlink\" title=\"一道有意思的面试题\"></a>一道有意思的面试题</h3><h2 id=\"判断-JavaScript-数据类型的方式\"><a href=\"#判断-JavaScript-数据类型的方式\" class=\"headerlink\" title=\"判断 JavaScript 数据类型的方式\"></a><a href=\"https://juejin.im/post/5cec1bcff265da1b8f1aa08f#heading-29\" target=\"_blank\" rel=\"noopener\">判断 JavaScript 数据类型的方式</a></h2><h3 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h3><h3 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h3><h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><h3 id=\"jquery\"><a href=\"#jquery\" class=\"headerlink\" title=\"jquery\"></a>jquery</h3>"},{"title":"不同排序算法","date":"2019-02-20T05:40:06.000Z","_content":"\n> 记录各种不同的排序算法\n\n<!-- more -->\n\n```\nconst arr = [44, 92, 82, 48, 2, 51];\n\n/********* 1、冒泡排序 **********/\n// 很常见很容易理解的排序算法， 排序思路：遍历数组，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少\nconst bubbleSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n      }\n    }\n  }\n  return list;\n}\n\n/********* 2、改进版冒泡排序 **********/\n// 对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。\nconst bubbleSort2 = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    let exchange = false;\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n        exchange = true;\n      }\n    }\n    if (!exchange) return list\n  }\n  return list;\n}\n\n/********* 3、选择排序 **********/\n// 在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。\nconst selectionSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    let k = i\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[k]) k = j;\n    }\n    if (k !== i) {\n      const tmp = list[k];\n      list[k] = list[i];\n      list[i] = tmp;\n    }\n  }\n  return list;\n}\n\n/********* 4、插入排序 **********/\n// 最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；\nconst insertSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 1; i < len; i++) {\n    const tmp = list[i];\n    let j = i - 1;\n    while (j >= 0 && tmp < list[j]) {\n      list[j + 1] = list[j];\n      j--;\n    }\n    list[j + 1] = tmp;\n  }\n  return list;\n}\n\n/********* 5、快速排序 **********/\nfunction quickSort(arr) {\n  const list = arr.slice(); //为了保证这个函数是纯函数，拷贝一次数组\n  if (list.length <= 1) return list;\n  const pivot = list.splice(0, 1)[0]; //选第一个作为基数\n  const left = [];\n  const right = [];\n  for (let i = 0, len = list.length; i < len; i++) {\n    if (list[i] < pivot) {\n      left.push(list[i]);\n    } else {\n      right.push(list[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right))\n}\n\n```","source":"_posts/不同排序算法.md","raw":"---\ntitle: 不同排序算法\ndate: 2019-02-20 13:40:06\ntags: 算法\ncategories: JS\n---\n\n> 记录各种不同的排序算法\n\n<!-- more -->\n\n```\nconst arr = [44, 92, 82, 48, 2, 51];\n\n/********* 1、冒泡排序 **********/\n// 很常见很容易理解的排序算法， 排序思路：遍历数组，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少\nconst bubbleSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n      }\n    }\n  }\n  return list;\n}\n\n/********* 2、改进版冒泡排序 **********/\n// 对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。\nconst bubbleSort2 = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    let exchange = false;\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n        exchange = true;\n      }\n    }\n    if (!exchange) return list\n  }\n  return list;\n}\n\n/********* 3、选择排序 **********/\n// 在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。\nconst selectionSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i < len; i++) {\n    let k = i\n    for (let j = len - 1; j > i; j--) {\n      if (list[j] < list[k]) k = j;\n    }\n    if (k !== i) {\n      const tmp = list[k];\n      list[k] = list[i];\n      list[i] = tmp;\n    }\n  }\n  return list;\n}\n\n/********* 4、插入排序 **********/\n// 最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；\nconst insertSort = arr => {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 1; i < len; i++) {\n    const tmp = list[i];\n    let j = i - 1;\n    while (j >= 0 && tmp < list[j]) {\n      list[j + 1] = list[j];\n      j--;\n    }\n    list[j + 1] = tmp;\n  }\n  return list;\n}\n\n/********* 5、快速排序 **********/\nfunction quickSort(arr) {\n  const list = arr.slice(); //为了保证这个函数是纯函数，拷贝一次数组\n  if (list.length <= 1) return list;\n  const pivot = list.splice(0, 1)[0]; //选第一个作为基数\n  const left = [];\n  const right = [];\n  for (let i = 0, len = list.length; i < len; i++) {\n    if (list[i] < pivot) {\n      left.push(list[i]);\n    } else {\n      right.push(list[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right))\n}\n\n```","slug":"不同排序算法","published":1,"updated":"2019-09-18T09:01:49.492Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx7g000segqnf128givu","content":"<blockquote>\n<p>记录各种不同的排序算法</p>\n</blockquote>\n<a id=\"more\"></a>\n<pre><code>const arr = [44, 92, 82, 48, 2, 51];\n\n/********* 1、冒泡排序 **********/\n// 很常见很容易理解的排序算法， 排序思路：遍历数组，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少\nconst bubbleSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n      }\n    }\n  }\n  return list;\n}\n\n/********* 2、改进版冒泡排序 **********/\n// 对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。\nconst bubbleSort2 = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    let exchange = false;\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n        exchange = true;\n      }\n    }\n    if (!exchange) return list\n  }\n  return list;\n}\n\n/********* 3、选择排序 **********/\n// 在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。\nconst selectionSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    let k = i\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[k]) k = j;\n    }\n    if (k !== i) {\n      const tmp = list[k];\n      list[k] = list[i];\n      list[i] = tmp;\n    }\n  }\n  return list;\n}\n\n/********* 4、插入排序 **********/\n// 最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；\nconst insertSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 1; i &lt; len; i++) {\n    const tmp = list[i];\n    let j = i - 1;\n    while (j &gt;= 0 &amp;&amp; tmp &lt; list[j]) {\n      list[j + 1] = list[j];\n      j--;\n    }\n    list[j + 1] = tmp;\n  }\n  return list;\n}\n\n/********* 5、快速排序 **********/\nfunction quickSort(arr) {\n  const list = arr.slice(); //为了保证这个函数是纯函数，拷贝一次数组\n  if (list.length &lt;= 1) return list;\n  const pivot = list.splice(0, 1)[0]; //选第一个作为基数\n  const left = [];\n  const right = [];\n  for (let i = 0, len = list.length; i &lt; len; i++) {\n    if (list[i] &lt; pivot) {\n      left.push(list[i]);\n    } else {\n      right.push(list[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right))\n}\n\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>记录各种不同的排序算法</p>\n</blockquote>","more":"<pre><code>const arr = [44, 92, 82, 48, 2, 51];\n\n/********* 1、冒泡排序 **********/\n// 很常见很容易理解的排序算法， 排序思路：遍历数组，每次遍历就将最大（或最小）值推至最前。越往后遍历查询次数越少\nconst bubbleSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n      }\n    }\n  }\n  return list;\n}\n\n/********* 2、改进版冒泡排序 **********/\n// 对上述冒泡排序的一种优化， 优化思路：当一次遍历前后数组不产生变化时，说明该数组已经有序，结束排序。\nconst bubbleSort2 = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    let exchange = false;\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[j - 1]) {\n        const tmp = list[j - 1];\n        list[j - 1] = list[j];\n        list[j] = tmp;\n        exchange = true;\n      }\n    }\n    if (!exchange) return list\n  }\n  return list;\n}\n\n/********* 3、选择排序 **********/\n// 在无序区中选出最小的元素，然后将它和无序区的第一个元素交换位置。\nconst selectionSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 0; i &lt; len; i++) {\n    let k = i\n    for (let j = len - 1; j &gt; i; j--) {\n      if (list[j] &lt; list[k]) k = j;\n    }\n    if (k !== i) {\n      const tmp = list[k];\n      list[k] = list[i];\n      list[i] = tmp;\n    }\n  }\n  return list;\n}\n\n/********* 4、插入排序 **********/\n// 最普通的排序算法， 从数组下标1开始每增1项排序一次，越往后遍历次数越多；\nconst insertSort = arr =&gt; {\n  const list = arr.slice(); //保证函数为纯函数\n  const len = list.length;\n  for (let i = 1; i &lt; len; i++) {\n    const tmp = list[i];\n    let j = i - 1;\n    while (j &gt;= 0 &amp;&amp; tmp &lt; list[j]) {\n      list[j + 1] = list[j];\n      j--;\n    }\n    list[j + 1] = tmp;\n  }\n  return list;\n}\n\n/********* 5、快速排序 **********/\nfunction quickSort(arr) {\n  const list = arr.slice(); //为了保证这个函数是纯函数，拷贝一次数组\n  if (list.length &lt;= 1) return list;\n  const pivot = list.splice(0, 1)[0]; //选第一个作为基数\n  const left = [];\n  const right = [];\n  for (let i = 0, len = list.length; i &lt; len; i++) {\n    if (list[i] &lt; pivot) {\n      left.push(list[i]);\n    } else {\n      right.push(list[i]);\n    }\n  }\n  return quickSort(left).concat([pivot], quickSort(right))\n}\n\n</code></pre>"},{"title":"微信小程序","date":"2019-02-12T02:44:49.000Z","_content":"\n> 记录小程序的学习\n\n<!-- more -->\n\n1. 小程序api网址：https://developers.weixin.qq.com/miniprogram/dev/api/\n2. 不能操作dom节点，只能通过操作数据来操作\n3. project.config.json 设置配置文件存储的地方","source":"_posts/微信小程序.md","raw":"---\ntitle: 微信小程序\ndate: 2019-02-12 10:44:49\ntags: js知识\ncategories: JS\n---\n\n> 记录小程序的学习\n\n<!-- more -->\n\n1. 小程序api网址：https://developers.weixin.qq.com/miniprogram/dev/api/\n2. 不能操作dom节点，只能通过操作数据来操作\n3. project.config.json 设置配置文件存储的地方","slug":"微信小程序","published":1,"updated":"2019-09-18T09:03:06.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx7l000uegqncjxoljlb","content":"<blockquote>\n<p>记录小程序的学习</p>\n</blockquote>\n<a id=\"more\"></a>\n<ol>\n<li>小程序api网址：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/\" target=\"_blank\" rel=\"noopener\">https://developers.weixin.qq.com/miniprogram/dev/api/</a></li>\n<li>不能操作dom节点，只能通过操作数据来操作</li>\n<li>project.config.json 设置配置文件存储的地方</li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>记录小程序的学习</p>\n</blockquote>","more":"<ol>\n<li>小程序api网址：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/\" target=\"_blank\" rel=\"noopener\">https://developers.weixin.qq.com/miniprogram/dev/api/</a></li>\n<li>不能操作dom节点，只能通过操作数据来操作</li>\n<li>project.config.json 设置配置文件存储的地方</li>\n</ol>"},{"title":"常用的css技巧","date":"2019-08-21T08:43:02.000Z","_content":"日常中可能会遇到各种各样的css问题， 常见的一些比如垂直居中，图片居中，清除浮动，按钮样式，滚动条自定义等，这边整理一些可能会比较常用的技巧，希望大家能够喜欢。\n<!-- more -->\n\n1. 清除浮动\n   文档元素浮动情况下，会出现各种问题，这时候需要清除浮动： \n\n```\n.clearfix:after {\n     content: \".\"; \n     display: block;\n     clear: both;\n     visibility: hidden;\n     line-height: 0;\n     height: 0; \n}\n.clearfix { display: inline-block; }\nhtml[xmlns] .clearfix { display: block; }\n* html .clearfix { height: 1%; }\n```\n\n2. 文本省略显示...\n   文本超过一定宽度时，需要显示省略号。\n   单行省略（需要设置外层宽度）： \n\n```\n.text-overflow {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden；\n}\n```\n  多行省略（css多行省略在chrome生效需要设置高度、宽度）：\n    \n    ```\n    .text-overflow-more {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        display: -webkit-box;\n        -webkit-line-clamp: 3;\n        -webkit-box-orient: vertical;\n    }\n    ```\n\n\n3. 透明效果，兼容不同浏览器\n\n```\n.transparent {\n    filter: alpha(opacity=50); /* internet explorer */\n    -khtml-opacity: 0.5;      /* khtml, old safari */\n    -moz-opacity: 0.5;       /* mozilla, netscape */\n    opacity: 0.5;           /* fx, safari, opera */\n}\n```\n\n4. 制作三角形\n\n```\n.triangle { \n    border-color: transparent transparent green transparent; \n    border-style: solid; \n    border-width: 0px 300px 300px 300px; \n    height: 0px; \n    width: 0px; \n}\n```\n\n5. 禁止换行, 文字只在一行内显示不换行\n\n```\n.nowrap {white-space:nowrap;}\n```\n\n6. 文字渐变效果\n\n```\n.text-gradient{\n    background-image: linear-gradient(135deg, deeppink, deepskyblue);\n    -webkit-background-clip: text;\n    color: transparent;\n}\n```\n\n7. 背景渐变\n\n```\n.gradient{\n    background: #e6e6e6;   //当浏览器不支持背景渐变时该语句将会被执行\n    background: -o-linear-gradient(top, #fdfdfd,  #e6e6e6); \n    background: -moz-linear-gradient(top, #fdfdfd, #e6e6e6); \n    background: -webkit-linear-gradient(top, #fdfdfd, #e6e6e6);   //最新发布语法\n    background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fdfdfd), #e6e6e6);   //老式语法\n}\n```\n\n8. 自定义滚动条\n\ncss元素(针对chrome浏览器，其他浏览器可能不生效)\n>整体部分 ::-webkit-scrollbar\n>两端按钮 ::-webkit-scrollbar-button\n>外层轨道 ::-webkit-scrollbar-track\n>内层轨道 ::-webkit-scrollbar-track-piece\n>滚动滑块 ::-webkit-scrollbar-thumb\n>边角 ::-webkit-scrollbar-corner\n>边角拖动块的样式 ::-webkit-resizer\n\n    ```\n\n    .scroll-horizontal::-webkit-scrollbar{\n        height: 10px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button{\n        display: block;\n        width: 5px;\n        border: 5px solid transparent;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:start:decrement{\n        border-right-color: red;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:end:increment{\n        border-left-color: red;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:end:decrement{\n        display: none;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:start:increment{\n        display: none;\n    }\n    .scroll-horizontal::-webkit-scrollbar-thumb{\n        background-color: green;\n        border-radius: 30px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-track-piece{\n        /* background-color: #0898b2; */\n        border-radius: 30px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-track{\n        border: 1px solid #721f1f;\n        border-radius: 30px;\n        margin: 0 5px;\n    }\n    ```\n\n","source":"_posts/常用的css技巧.md","raw":"---\ntitle: 常用的css技巧\ndate: 2019-08-21 16:43:02\ntags: CSS\ncategories: CSS\n---\n日常中可能会遇到各种各样的css问题， 常见的一些比如垂直居中，图片居中，清除浮动，按钮样式，滚动条自定义等，这边整理一些可能会比较常用的技巧，希望大家能够喜欢。\n<!-- more -->\n\n1. 清除浮动\n   文档元素浮动情况下，会出现各种问题，这时候需要清除浮动： \n\n```\n.clearfix:after {\n     content: \".\"; \n     display: block;\n     clear: both;\n     visibility: hidden;\n     line-height: 0;\n     height: 0; \n}\n.clearfix { display: inline-block; }\nhtml[xmlns] .clearfix { display: block; }\n* html .clearfix { height: 1%; }\n```\n\n2. 文本省略显示...\n   文本超过一定宽度时，需要显示省略号。\n   单行省略（需要设置外层宽度）： \n\n```\n.text-overflow {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden；\n}\n```\n  多行省略（css多行省略在chrome生效需要设置高度、宽度）：\n    \n    ```\n    .text-overflow-more {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        display: -webkit-box;\n        -webkit-line-clamp: 3;\n        -webkit-box-orient: vertical;\n    }\n    ```\n\n\n3. 透明效果，兼容不同浏览器\n\n```\n.transparent {\n    filter: alpha(opacity=50); /* internet explorer */\n    -khtml-opacity: 0.5;      /* khtml, old safari */\n    -moz-opacity: 0.5;       /* mozilla, netscape */\n    opacity: 0.5;           /* fx, safari, opera */\n}\n```\n\n4. 制作三角形\n\n```\n.triangle { \n    border-color: transparent transparent green transparent; \n    border-style: solid; \n    border-width: 0px 300px 300px 300px; \n    height: 0px; \n    width: 0px; \n}\n```\n\n5. 禁止换行, 文字只在一行内显示不换行\n\n```\n.nowrap {white-space:nowrap;}\n```\n\n6. 文字渐变效果\n\n```\n.text-gradient{\n    background-image: linear-gradient(135deg, deeppink, deepskyblue);\n    -webkit-background-clip: text;\n    color: transparent;\n}\n```\n\n7. 背景渐变\n\n```\n.gradient{\n    background: #e6e6e6;   //当浏览器不支持背景渐变时该语句将会被执行\n    background: -o-linear-gradient(top, #fdfdfd,  #e6e6e6); \n    background: -moz-linear-gradient(top, #fdfdfd, #e6e6e6); \n    background: -webkit-linear-gradient(top, #fdfdfd, #e6e6e6);   //最新发布语法\n    background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fdfdfd), #e6e6e6);   //老式语法\n}\n```\n\n8. 自定义滚动条\n\ncss元素(针对chrome浏览器，其他浏览器可能不生效)\n>整体部分 ::-webkit-scrollbar\n>两端按钮 ::-webkit-scrollbar-button\n>外层轨道 ::-webkit-scrollbar-track\n>内层轨道 ::-webkit-scrollbar-track-piece\n>滚动滑块 ::-webkit-scrollbar-thumb\n>边角 ::-webkit-scrollbar-corner\n>边角拖动块的样式 ::-webkit-resizer\n\n    ```\n\n    .scroll-horizontal::-webkit-scrollbar{\n        height: 10px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button{\n        display: block;\n        width: 5px;\n        border: 5px solid transparent;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:start:decrement{\n        border-right-color: red;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:end:increment{\n        border-left-color: red;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:end:decrement{\n        display: none;\n    }\n    .scroll-horizontal::-webkit-scrollbar-button:start:increment{\n        display: none;\n    }\n    .scroll-horizontal::-webkit-scrollbar-thumb{\n        background-color: green;\n        border-radius: 30px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-track-piece{\n        /* background-color: #0898b2; */\n        border-radius: 30px;\n    }\n    .scroll-horizontal::-webkit-scrollbar-track{\n        border: 1px solid #721f1f;\n        border-radius: 30px;\n        margin: 0 5px;\n    }\n    ```\n\n","slug":"常用的css技巧","published":1,"updated":"2019-09-18T09:05:14.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx7s000xegqnebq9rb6r","content":"<p>日常中可能会遇到各种各样的css问题， 常见的一些比如垂直居中，图片居中，清除浮动，按钮样式，滚动条自定义等，这边整理一些可能会比较常用的技巧，希望大家能够喜欢。<br><a id=\"more\"></a></p>\n<ol>\n<li>清除浮动<br>文档元素浮动情况下，会出现各种问题，这时候需要清除浮动： </li>\n</ol>\n<pre><code>.clearfix:after {\n     content: &quot;.&quot;; \n     display: block;\n     clear: both;\n     visibility: hidden;\n     line-height: 0;\n     height: 0; \n}\n.clearfix { display: inline-block; }\nhtml[xmlns] .clearfix { display: block; }\n* html .clearfix { height: 1%; }\n</code></pre><ol start=\"2\">\n<li>文本省略显示…<br>文本超过一定宽度时，需要显示省略号。<br>单行省略（需要设置外层宽度）： </li>\n</ol>\n<pre><code>.text-overflow {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden；\n}\n</code></pre><p>  多行省略（css多行省略在chrome生效需要设置高度、宽度）：</p>\n<pre><code>```\n.text-overflow-more {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n}\n```\n</code></pre><ol start=\"3\">\n<li>透明效果，兼容不同浏览器</li>\n</ol>\n<pre><code>.transparent {\n    filter: alpha(opacity=50); /* internet explorer */\n    -khtml-opacity: 0.5;      /* khtml, old safari */\n    -moz-opacity: 0.5;       /* mozilla, netscape */\n    opacity: 0.5;           /* fx, safari, opera */\n}\n</code></pre><ol start=\"4\">\n<li>制作三角形</li>\n</ol>\n<pre><code>.triangle { \n    border-color: transparent transparent green transparent; \n    border-style: solid; \n    border-width: 0px 300px 300px 300px; \n    height: 0px; \n    width: 0px; \n}\n</code></pre><ol start=\"5\">\n<li>禁止换行, 文字只在一行内显示不换行</li>\n</ol>\n<pre><code>.nowrap {white-space:nowrap;}\n</code></pre><ol start=\"6\">\n<li>文字渐变效果</li>\n</ol>\n<pre><code>.text-gradient{\n    background-image: linear-gradient(135deg, deeppink, deepskyblue);\n    -webkit-background-clip: text;\n    color: transparent;\n}\n</code></pre><ol start=\"7\">\n<li>背景渐变</li>\n</ol>\n<pre><code>.gradient{\n    background: #e6e6e6;   //当浏览器不支持背景渐变时该语句将会被执行\n    background: -o-linear-gradient(top, #fdfdfd,  #e6e6e6); \n    background: -moz-linear-gradient(top, #fdfdfd, #e6e6e6); \n    background: -webkit-linear-gradient(top, #fdfdfd, #e6e6e6);   //最新发布语法\n    background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fdfdfd), #e6e6e6);   //老式语法\n}\n</code></pre><ol start=\"8\">\n<li>自定义滚动条</li>\n</ol>\n<p>css元素(针对chrome浏览器，其他浏览器可能不生效)</p>\n<blockquote>\n<p>整体部分 ::-webkit-scrollbar<br>两端按钮 ::-webkit-scrollbar-button<br>外层轨道 ::-webkit-scrollbar-track<br>内层轨道 ::-webkit-scrollbar-track-piece<br>滚动滑块 ::-webkit-scrollbar-thumb<br>边角 ::-webkit-scrollbar-corner<br>边角拖动块的样式 ::-webkit-resizer</p>\n</blockquote>\n<pre><code>```\n\n.scroll-horizontal::-webkit-scrollbar{\n    height: 10px;\n}\n.scroll-horizontal::-webkit-scrollbar-button{\n    display: block;\n    width: 5px;\n    border: 5px solid transparent;\n}\n.scroll-horizontal::-webkit-scrollbar-button:start:decrement{\n    border-right-color: red;\n}\n.scroll-horizontal::-webkit-scrollbar-button:end:increment{\n    border-left-color: red;\n}\n.scroll-horizontal::-webkit-scrollbar-button:end:decrement{\n    display: none;\n}\n.scroll-horizontal::-webkit-scrollbar-button:start:increment{\n    display: none;\n}\n.scroll-horizontal::-webkit-scrollbar-thumb{\n    background-color: green;\n    border-radius: 30px;\n}\n.scroll-horizontal::-webkit-scrollbar-track-piece{\n    /* background-color: #0898b2; */\n    border-radius: 30px;\n}\n.scroll-horizontal::-webkit-scrollbar-track{\n    border: 1px solid #721f1f;\n    border-radius: 30px;\n    margin: 0 5px;\n}\n```\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>日常中可能会遇到各种各样的css问题， 常见的一些比如垂直居中，图片居中，清除浮动，按钮样式，滚动条自定义等，这边整理一些可能会比较常用的技巧，希望大家能够喜欢。<br>","more":"</p>\n<ol>\n<li>清除浮动<br>文档元素浮动情况下，会出现各种问题，这时候需要清除浮动： </li>\n</ol>\n<pre><code>.clearfix:after {\n     content: &quot;.&quot;; \n     display: block;\n     clear: both;\n     visibility: hidden;\n     line-height: 0;\n     height: 0; \n}\n.clearfix { display: inline-block; }\nhtml[xmlns] .clearfix { display: block; }\n* html .clearfix { height: 1%; }\n</code></pre><ol start=\"2\">\n<li>文本省略显示…<br>文本超过一定宽度时，需要显示省略号。<br>单行省略（需要设置外层宽度）： </li>\n</ol>\n<pre><code>.text-overflow {\n    text-overflow: ellipsis;\n    white-space: nowrap;\n    overflow: hidden；\n}\n</code></pre><p>  多行省略（css多行省略在chrome生效需要设置高度、宽度）：</p>\n<pre><code>```\n.text-overflow-more {\n    overflow: hidden;\n    text-overflow: ellipsis;\n    display: -webkit-box;\n    -webkit-line-clamp: 3;\n    -webkit-box-orient: vertical;\n}\n```\n</code></pre><ol start=\"3\">\n<li>透明效果，兼容不同浏览器</li>\n</ol>\n<pre><code>.transparent {\n    filter: alpha(opacity=50); /* internet explorer */\n    -khtml-opacity: 0.5;      /* khtml, old safari */\n    -moz-opacity: 0.5;       /* mozilla, netscape */\n    opacity: 0.5;           /* fx, safari, opera */\n}\n</code></pre><ol start=\"4\">\n<li>制作三角形</li>\n</ol>\n<pre><code>.triangle { \n    border-color: transparent transparent green transparent; \n    border-style: solid; \n    border-width: 0px 300px 300px 300px; \n    height: 0px; \n    width: 0px; \n}\n</code></pre><ol start=\"5\">\n<li>禁止换行, 文字只在一行内显示不换行</li>\n</ol>\n<pre><code>.nowrap {white-space:nowrap;}\n</code></pre><ol start=\"6\">\n<li>文字渐变效果</li>\n</ol>\n<pre><code>.text-gradient{\n    background-image: linear-gradient(135deg, deeppink, deepskyblue);\n    -webkit-background-clip: text;\n    color: transparent;\n}\n</code></pre><ol start=\"7\">\n<li>背景渐变</li>\n</ol>\n<pre><code>.gradient{\n    background: #e6e6e6;   //当浏览器不支持背景渐变时该语句将会被执行\n    background: -o-linear-gradient(top, #fdfdfd,  #e6e6e6); \n    background: -moz-linear-gradient(top, #fdfdfd, #e6e6e6); \n    background: -webkit-linear-gradient(top, #fdfdfd, #e6e6e6);   //最新发布语法\n    background: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#fdfdfd), #e6e6e6);   //老式语法\n}\n</code></pre><ol start=\"8\">\n<li>自定义滚动条</li>\n</ol>\n<p>css元素(针对chrome浏览器，其他浏览器可能不生效)</p>\n<blockquote>\n<p>整体部分 ::-webkit-scrollbar<br>两端按钮 ::-webkit-scrollbar-button<br>外层轨道 ::-webkit-scrollbar-track<br>内层轨道 ::-webkit-scrollbar-track-piece<br>滚动滑块 ::-webkit-scrollbar-thumb<br>边角 ::-webkit-scrollbar-corner<br>边角拖动块的样式 ::-webkit-resizer</p>\n</blockquote>\n<pre><code>```\n\n.scroll-horizontal::-webkit-scrollbar{\n    height: 10px;\n}\n.scroll-horizontal::-webkit-scrollbar-button{\n    display: block;\n    width: 5px;\n    border: 5px solid transparent;\n}\n.scroll-horizontal::-webkit-scrollbar-button:start:decrement{\n    border-right-color: red;\n}\n.scroll-horizontal::-webkit-scrollbar-button:end:increment{\n    border-left-color: red;\n}\n.scroll-horizontal::-webkit-scrollbar-button:end:decrement{\n    display: none;\n}\n.scroll-horizontal::-webkit-scrollbar-button:start:increment{\n    display: none;\n}\n.scroll-horizontal::-webkit-scrollbar-thumb{\n    background-color: green;\n    border-radius: 30px;\n}\n.scroll-horizontal::-webkit-scrollbar-track-piece{\n    /* background-color: #0898b2; */\n    border-radius: 30px;\n}\n.scroll-horizontal::-webkit-scrollbar-track{\n    border: 1px solid #721f1f;\n    border-radius: 30px;\n    margin: 0 5px;\n}\n```\n</code></pre>"},{"title":"前端需要知道的Javascript技巧","date":"2019-05-31T06:19:52.000Z","_content":"\n> 前端需要知道的 JavaScript 技巧，会常常补充进来\n\n<!-- more -->\n\n## 判断对象的数据类型\n使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入 type 参数时首字母大写）\n不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上,因为 call 会将第一个参数进行装箱操作\n```\nconst isType = type => target => `[object ${type}]` === Object.prototype.tpString.call(target)\nconst isArray = isType('Array)\n\nconsole.log(isArray([]))\n\n```\n\n## 数组去重\n```\nconst a = [...new Set([1, 2, 3, 3])]\n>> [1, 2, 3]\n```\n\n## 合并对象\n```\nconst a = {m: 1, n: 2}\nconst b = {n: 3, x: 5}\n\ncons res = {\n    ...a,\n    ...b\n}\n\n/*\nres = {\n  m: 1,\n  n: 3,\n  x: 5\n}\n*/  \n```\n\n## 简单的判断逻辑书写方式\n短路求值（Short-Circuit Evaluation）， 三目运算符是一个很方便快捷的书写一些简单的逻辑语句的方式\n```\nx > 100 ? 'Above 100' : 'Below 100';\nx > 100 ? (x > 200 ? 'Above 200' : 'Between 100-200') : 'Below 100';\n```\n但是有些时候当逻辑复杂之后，三目运算符书写起来可读性也会很难。这个时候，我们就可以使用逻辑与（&&）和逻辑或（||）运算符来改写我们的表达式。\n\n逻辑与和逻辑或操作符总是先计算其做操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。这被称为“短路求值（Short-Circuit Evaluation）”\n\n### 工作原理\n* 与（&&）运算符将会返回第一个false/‘falsy’的值。当所有的操作数都是true时，将返回最后一个表达式的结果。\n```\nlet one = 1, two = 2, three = 3;\nconsole.log(one && two && three); // Result: 3\n\nconsole.log(0 && null); // Result: 0\n```\n* 或（||）运算符将返回第一个true/‘truthy’的值。当所有的操作数都是false时，将返回最后一个表达式的结果。\n```\nlet one = 1, two = 2, three = 3;\nconsole.log(one || two || three); // Result: 1\n\nconsole.log(0 || null); // Result: null\n```","source":"_posts/前端需要知道的Javascript技巧.md","raw":"---\ntitle: 前端需要知道的Javascript技巧\ndate: 2019-05-31 14:19:52\ntags: js知识\ncategories: JS\n---\n\n> 前端需要知道的 JavaScript 技巧，会常常补充进来\n\n<!-- more -->\n\n## 判断对象的数据类型\n使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入 type 参数时首字母大写）\n不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上,因为 call 会将第一个参数进行装箱操作\n```\nconst isType = type => target => `[object ${type}]` === Object.prototype.tpString.call(target)\nconst isArray = isType('Array)\n\nconsole.log(isArray([]))\n\n```\n\n## 数组去重\n```\nconst a = [...new Set([1, 2, 3, 3])]\n>> [1, 2, 3]\n```\n\n## 合并对象\n```\nconst a = {m: 1, n: 2}\nconst b = {n: 3, x: 5}\n\ncons res = {\n    ...a,\n    ...b\n}\n\n/*\nres = {\n  m: 1,\n  n: 3,\n  x: 5\n}\n*/  \n```\n\n## 简单的判断逻辑书写方式\n短路求值（Short-Circuit Evaluation）， 三目运算符是一个很方便快捷的书写一些简单的逻辑语句的方式\n```\nx > 100 ? 'Above 100' : 'Below 100';\nx > 100 ? (x > 200 ? 'Above 200' : 'Between 100-200') : 'Below 100';\n```\n但是有些时候当逻辑复杂之后，三目运算符书写起来可读性也会很难。这个时候，我们就可以使用逻辑与（&&）和逻辑或（||）运算符来改写我们的表达式。\n\n逻辑与和逻辑或操作符总是先计算其做操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。这被称为“短路求值（Short-Circuit Evaluation）”\n\n### 工作原理\n* 与（&&）运算符将会返回第一个false/‘falsy’的值。当所有的操作数都是true时，将返回最后一个表达式的结果。\n```\nlet one = 1, two = 2, three = 3;\nconsole.log(one && two && three); // Result: 3\n\nconsole.log(0 && null); // Result: 0\n```\n* 或（||）运算符将返回第一个true/‘truthy’的值。当所有的操作数都是false时，将返回最后一个表达式的结果。\n```\nlet one = 1, two = 2, three = 3;\nconsole.log(one || two || three); // Result: 1\n\nconsole.log(0 || null); // Result: null\n```","slug":"前端需要知道的Javascript技巧","published":1,"updated":"2019-09-18T09:02:40.879Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx7v000zegqnszp9u3un","content":"<blockquote>\n<p>前端需要知道的 JavaScript 技巧，会常常补充进来</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"判断对象的数据类型\"><a href=\"#判断对象的数据类型\" class=\"headerlink\" title=\"判断对象的数据类型\"></a>判断对象的数据类型</h2><p>使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入 type 参数时首字母大写）<br>不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上,因为 call 会将第一个参数进行装箱操作</p>\n<pre><code>const isType = type =&gt; target =&gt; `[object ${type}]` === Object.prototype.tpString.call(target)\nconst isArray = isType(&#39;Array)\n\nconsole.log(isArray([]))\n\n</code></pre><h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><pre><code>const a = [...new Set([1, 2, 3, 3])]\n&gt;&gt; [1, 2, 3]\n</code></pre><h2 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h2><pre><code>const a = {m: 1, n: 2}\nconst b = {n: 3, x: 5}\n\ncons res = {\n    ...a,\n    ...b\n}\n\n/*\nres = {\n  m: 1,\n  n: 3,\n  x: 5\n}\n*/  \n</code></pre><h2 id=\"简单的判断逻辑书写方式\"><a href=\"#简单的判断逻辑书写方式\" class=\"headerlink\" title=\"简单的判断逻辑书写方式\"></a>简单的判断逻辑书写方式</h2><p>短路求值（Short-Circuit Evaluation）， 三目运算符是一个很方便快捷的书写一些简单的逻辑语句的方式</p>\n<pre><code>x &gt; 100 ? &#39;Above 100&#39; : &#39;Below 100&#39;;\nx &gt; 100 ? (x &gt; 200 ? &#39;Above 200&#39; : &#39;Between 100-200&#39;) : &#39;Below 100&#39;;\n</code></pre><p>但是有些时候当逻辑复杂之后，三目运算符书写起来可读性也会很难。这个时候，我们就可以使用逻辑与（&amp;&amp;）和逻辑或（||）运算符来改写我们的表达式。</p>\n<p>逻辑与和逻辑或操作符总是先计算其做操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。这被称为“短路求值（Short-Circuit Evaluation）”</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ul>\n<li>与（&amp;&amp;）运算符将会返回第一个false/‘falsy’的值。当所有的操作数都是true时，将返回最后一个表达式的结果。<br><code>`</code><br>let one = 1, two = 2, three = 3;<br>console.log(one &amp;&amp; two &amp;&amp; three); // Result: 3</li>\n</ul>\n<p>console.log(0 &amp;&amp; null); // Result: 0</p>\n<pre><code>* 或（||）运算符将返回第一个true/‘truthy’的值。当所有的操作数都是false时，将返回最后一个表达式的结果。\n</code></pre><p>let one = 1, two = 2, three = 3;<br>console.log(one || two || three); // Result: 1</p>\n<p>console.log(0 || null); // Result: null<br><code>`</code></p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>前端需要知道的 JavaScript 技巧，会常常补充进来</p>\n</blockquote>","more":"<h2 id=\"判断对象的数据类型\"><a href=\"#判断对象的数据类型\" class=\"headerlink\" title=\"判断对象的数据类型\"></a>判断对象的数据类型</h2><p>使用 Object.prototype.toString 配合闭包，通过传入不同的判断类型来返回不同的判断函数，一行代码，简洁优雅灵活（注意传入 type 参数时首字母大写）<br>不推荐将这个函数用来检测可能会产生包装类型的基本数据类型上,因为 call 会将第一个参数进行装箱操作</p>\n<pre><code>const isType = type =&gt; target =&gt; `[object ${type}]` === Object.prototype.tpString.call(target)\nconst isArray = isType(&#39;Array)\n\nconsole.log(isArray([]))\n\n</code></pre><h2 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h2><pre><code>const a = [...new Set([1, 2, 3, 3])]\n&gt;&gt; [1, 2, 3]\n</code></pre><h2 id=\"合并对象\"><a href=\"#合并对象\" class=\"headerlink\" title=\"合并对象\"></a>合并对象</h2><pre><code>const a = {m: 1, n: 2}\nconst b = {n: 3, x: 5}\n\ncons res = {\n    ...a,\n    ...b\n}\n\n/*\nres = {\n  m: 1,\n  n: 3,\n  x: 5\n}\n*/  \n</code></pre><h2 id=\"简单的判断逻辑书写方式\"><a href=\"#简单的判断逻辑书写方式\" class=\"headerlink\" title=\"简单的判断逻辑书写方式\"></a>简单的判断逻辑书写方式</h2><p>短路求值（Short-Circuit Evaluation）， 三目运算符是一个很方便快捷的书写一些简单的逻辑语句的方式</p>\n<pre><code>x &gt; 100 ? &#39;Above 100&#39; : &#39;Below 100&#39;;\nx &gt; 100 ? (x &gt; 200 ? &#39;Above 200&#39; : &#39;Between 100-200&#39;) : &#39;Below 100&#39;;\n</code></pre><p>但是有些时候当逻辑复杂之后，三目运算符书写起来可读性也会很难。这个时候，我们就可以使用逻辑与（&amp;&amp;）和逻辑或（||）运算符来改写我们的表达式。</p>\n<p>逻辑与和逻辑或操作符总是先计算其做操作数，只有在仅靠左操作数的值无法确定该逻辑表达式的结果时，才会求解其右操作数。这被称为“短路求值（Short-Circuit Evaluation）”</p>\n<h3 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h3><ul>\n<li>与（&amp;&amp;）运算符将会返回第一个false/‘falsy’的值。当所有的操作数都是true时，将返回最后一个表达式的结果。<br><code>`</code><br>let one = 1, two = 2, three = 3;<br>console.log(one &amp;&amp; two &amp;&amp; three); // Result: 3</li>\n</ul>\n<p>console.log(0 &amp;&amp; null); // Result: 0</p>\n<pre><code>* 或（||）运算符将返回第一个true/‘truthy’的值。当所有的操作数都是false时，将返回最后一个表达式的结果。\n</code></pre><p>let one = 1, two = 2, three = 3;<br>console.log(one || two || three); // Result: 1</p>\n<p>console.log(0 || null); // Result: null<br><code>`</code></p>"},{"title":"函数防抖和函数节流","date":"2018-07-31T06:01:04.000Z","_content":"\n# 概念解释\n函数节流和函数防抖，两者都是优化高频率执行 js 代码的一种手段。\n\n在一定时间内，代码执行的次数不一定要非常多，达到一定的频率就足够了。有些情况下，代码运行频率达到一定程度时，超过那个频率所带来的效果是一样的，还不如把js代码执行的次数控制在一个合理的范围之内。既能够节省浏览器CPU的资源，又能够让页面浏览起来更加的顺畅，不会因为js的执行而发生卡顿。这就是我们要将的函数节流和函数防抖要做的事情。\n\n**函数防抖**是指在频繁触发的情况下，只有再有足够的空闲时间时，才执行一代码一次。比如生活中做公交车，在一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有没人刷卡了，司机才会开车。\n**函数节流**是指在一定时间内 js 只会执行一次。比如人眨眼睛，就是一定时间内眨一次。\n\n<!-- more -->\n# 示例\n防抖\n```\n// 简单示例\nwindow.addEventListener('resize',function(e){\n    var t;\n    return function(){\n        if(t) clearTimeout(t);\n        t = setTimeout(function(){\n            // do something...\n        },500);\n    }\n}());\n```\n\n节流\n```\n// 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime >= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n};\n// 实际想绑定在 scroll 事件上的 handler\nfunction realFunc(){\n    console.log(\"Success\");\n}\n// 采用了节流函数\nwindow.addEventListener('scroll',throttle(realFunc,500,1000));\n```\n","source":"_posts/函数防抖和函数节流.md","raw":"---\ntitle: 函数防抖和函数节流\ndate: 2018-07-31 14:01:04\ntags: js知识\ncategories: JS\n---\n\n# 概念解释\n函数节流和函数防抖，两者都是优化高频率执行 js 代码的一种手段。\n\n在一定时间内，代码执行的次数不一定要非常多，达到一定的频率就足够了。有些情况下，代码运行频率达到一定程度时，超过那个频率所带来的效果是一样的，还不如把js代码执行的次数控制在一个合理的范围之内。既能够节省浏览器CPU的资源，又能够让页面浏览起来更加的顺畅，不会因为js的执行而发生卡顿。这就是我们要将的函数节流和函数防抖要做的事情。\n\n**函数防抖**是指在频繁触发的情况下，只有再有足够的空闲时间时，才执行一代码一次。比如生活中做公交车，在一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有没人刷卡了，司机才会开车。\n**函数节流**是指在一定时间内 js 只会执行一次。比如人眨眼睛，就是一定时间内眨一次。\n\n<!-- more -->\n# 示例\n防抖\n```\n// 简单示例\nwindow.addEventListener('resize',function(e){\n    var t;\n    return function(){\n        if(t) clearTimeout(t);\n        t = setTimeout(function(){\n            // do something...\n        },500);\n    }\n}());\n```\n\n节流\n```\n// 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime >= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n};\n// 实际想绑定在 scroll 事件上的 handler\nfunction realFunc(){\n    console.log(\"Success\");\n}\n// 采用了节流函数\nwindow.addEventListener('scroll',throttle(realFunc,500,1000));\n```\n","slug":"函数防抖和函数节流","published":1,"updated":"2019-09-18T09:02:45.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx7z0012egqnsxztr2ky","content":"<h1 id=\"概念解释\"><a href=\"#概念解释\" class=\"headerlink\" title=\"概念解释\"></a>概念解释</h1><p>函数节流和函数防抖，两者都是优化高频率执行 js 代码的一种手段。</p>\n<p>在一定时间内，代码执行的次数不一定要非常多，达到一定的频率就足够了。有些情况下，代码运行频率达到一定程度时，超过那个频率所带来的效果是一样的，还不如把js代码执行的次数控制在一个合理的范围之内。既能够节省浏览器CPU的资源，又能够让页面浏览起来更加的顺畅，不会因为js的执行而发生卡顿。这就是我们要将的函数节流和函数防抖要做的事情。</p>\n<p><strong>函数防抖</strong>是指在频繁触发的情况下，只有再有足够的空闲时间时，才执行一代码一次。比如生活中做公交车，在一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有没人刷卡了，司机才会开车。<br><strong>函数节流</strong>是指在一定时间内 js 只会执行一次。比如人眨眼睛，就是一定时间内眨一次。</p>\n<a id=\"more\"></a>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>防抖</p>\n<pre><code>// 简单示例\nwindow.addEventListener(&#39;resize&#39;,function(e){\n    var t;\n    return function(){\n        if(t) clearTimeout(t);\n        t = setTimeout(function(){\n            // do something...\n        },500);\n    }\n}());\n</code></pre><p>节流</p>\n<pre><code>// 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime &gt;= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n};\n// 实际想绑定在 scroll 事件上的 handler\nfunction realFunc(){\n    console.log(&quot;Success&quot;);\n}\n// 采用了节流函数\nwindow.addEventListener(&#39;scroll&#39;,throttle(realFunc,500,1000));\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<h1 id=\"概念解释\"><a href=\"#概念解释\" class=\"headerlink\" title=\"概念解释\"></a>概念解释</h1><p>函数节流和函数防抖，两者都是优化高频率执行 js 代码的一种手段。</p>\n<p>在一定时间内，代码执行的次数不一定要非常多，达到一定的频率就足够了。有些情况下，代码运行频率达到一定程度时，超过那个频率所带来的效果是一样的，还不如把js代码执行的次数控制在一个合理的范围之内。既能够节省浏览器CPU的资源，又能够让页面浏览起来更加的顺畅，不会因为js的执行而发生卡顿。这就是我们要将的函数节流和函数防抖要做的事情。</p>\n<p><strong>函数防抖</strong>是指在频繁触发的情况下，只有再有足够的空闲时间时，才执行一代码一次。比如生活中做公交车，在一定时间内，如果有人陆续刷卡上车，司机就不会开车。只有没人刷卡了，司机才会开车。<br><strong>函数节流</strong>是指在一定时间内 js 只会执行一次。比如人眨眼睛，就是一定时间内眨一次。</p>","more":"<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>防抖</p>\n<pre><code>// 简单示例\nwindow.addEventListener(&#39;resize&#39;,function(e){\n    var t;\n    return function(){\n        if(t) clearTimeout(t);\n        t = setTimeout(function(){\n            // do something...\n        },500);\n    }\n}());\n</code></pre><p>节流</p>\n<pre><code>// 简单的节流函数\nfunction throttle(func, wait, mustRun) {\n    var timeout,\n        startTime = new Date();\n\n    return function() {\n        var context = this,\n            args = arguments,\n            curTime = new Date();\n\n        clearTimeout(timeout);\n        // 如果达到了规定的触发时间间隔，触发 handler\n        if(curTime - startTime &gt;= mustRun){\n            func.apply(context,args);\n            startTime = curTime;\n        // 没达到触发间隔，重新设定定时器\n        }else{\n            timeout = setTimeout(func, wait);\n        }\n    };\n};\n// 实际想绑定在 scroll 事件上的 handler\nfunction realFunc(){\n    console.log(&quot;Success&quot;);\n}\n// 采用了节流函数\nwindow.addEventListener(&#39;scroll&#39;,throttle(realFunc,500,1000));\n</code></pre>"},{"title":"常见正则表达式","date":"2019-08-29T00:47:41.000Z","_content":"\n常见正则表达式\n\n<!-- more -->\n\n\n* 判断用户名——4到16位（字母，数字，下划线，减号）\n\n```\nvar pattern = /^[a-zA-Z0-9_-]{4,16}$/;\n```\n\n* 判断纯数字\n\n```\nvar pattern = /^\\d{1,}$/;\n```\n\n* 判断是否由数字和字母组成\n\n```\nvar pattern = /^[A-Za-z0-9]+$/;\n```\n\n* 判断是否由字母组成（大小写）\n\n```\nvar pattern  = /^[a-zA-Z]+$/;\n```\n\n* 判断是否由纯小写字母组成\n\n```\nvar pattern = /^[a-z]+$/;\n```\n\n* 判断是否由纯大写字母组成\n\n```\nvar pattern  = /^[A-Z]+$/;\n```\n\n* 判断是否由中文和数字组成\n\n```\nvar pattern  = /^((?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])|(\\d))+$/\n```\n\n* 判断不允许包含字母\n\n```\nvar pattern = /^[^A-Za-z]*$/;\n```\n\n* 判断是否纯中文\n\n```\nvar  pattern = /^(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])+$/;\n```\n\n* 判断是否是小数\n\n```\nvar pattern = /^\\d+\\.\\d+$/;\n```\n\n* 判断是否正整数\n\n```\nvar pattern = /^\\d+$/;\n```\n\n* 判断是否负整数\n\n```\nvar pattern = /^-\\d+$/;\n```\n\n* 判断是否整数\n\n```\nvar pattern = /^-?\\d+$/;\n```\n\n* 判断是否正数（包含整数和小数）\n\n```\nvar pattern = /^\\d*\\.?\\d+$/;\n```\n\n* 判断是否负数（包含整数和小数）\n\n```\nvar pattern = /^-\\d*\\.?\\d+$/;\n```\n\n* 判断是否数字（包含整数和小数）\n\n```\nvar pattern = /^-?\\d*\\.?\\d+$/;\n```\n\n* 判断是否是邮箱\n\n```\nvar pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n```","source":"_posts/常见正则表达式.md","raw":"---\ntitle: 常见正则表达式\ndate: 2019-08-29 08:47:41\ntags: 正则\ncategories: JS\n---\n\n常见正则表达式\n\n<!-- more -->\n\n\n* 判断用户名——4到16位（字母，数字，下划线，减号）\n\n```\nvar pattern = /^[a-zA-Z0-9_-]{4,16}$/;\n```\n\n* 判断纯数字\n\n```\nvar pattern = /^\\d{1,}$/;\n```\n\n* 判断是否由数字和字母组成\n\n```\nvar pattern = /^[A-Za-z0-9]+$/;\n```\n\n* 判断是否由字母组成（大小写）\n\n```\nvar pattern  = /^[a-zA-Z]+$/;\n```\n\n* 判断是否由纯小写字母组成\n\n```\nvar pattern = /^[a-z]+$/;\n```\n\n* 判断是否由纯大写字母组成\n\n```\nvar pattern  = /^[A-Z]+$/;\n```\n\n* 判断是否由中文和数字组成\n\n```\nvar pattern  = /^((?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])|(\\d))+$/\n```\n\n* 判断不允许包含字母\n\n```\nvar pattern = /^[^A-Za-z]*$/;\n```\n\n* 判断是否纯中文\n\n```\nvar  pattern = /^(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])+$/;\n```\n\n* 判断是否是小数\n\n```\nvar pattern = /^\\d+\\.\\d+$/;\n```\n\n* 判断是否正整数\n\n```\nvar pattern = /^\\d+$/;\n```\n\n* 判断是否负整数\n\n```\nvar pattern = /^-\\d+$/;\n```\n\n* 判断是否整数\n\n```\nvar pattern = /^-?\\d+$/;\n```\n\n* 判断是否正数（包含整数和小数）\n\n```\nvar pattern = /^\\d*\\.?\\d+$/;\n```\n\n* 判断是否负数（包含整数和小数）\n\n```\nvar pattern = /^-\\d*\\.?\\d+$/;\n```\n\n* 判断是否数字（包含整数和小数）\n\n```\nvar pattern = /^-?\\d*\\.?\\d+$/;\n```\n\n* 判断是否是邮箱\n\n```\nvar pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n```","slug":"常见正则表达式","published":1,"updated":"2019-09-18T09:01:42.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx830016egqn9xkikmhy","content":"<p>常见正则表达式</p>\n<a id=\"more\"></a>\n<ul>\n<li>判断用户名——4到16位（字母，数字，下划线，减号）</li>\n</ul>\n<pre><code>var pattern = /^[a-zA-Z0-9_-]{4,16}$/;\n</code></pre><ul>\n<li>判断纯数字</li>\n</ul>\n<pre><code>var pattern = /^\\d{1,}$/;\n</code></pre><ul>\n<li>判断是否由数字和字母组成</li>\n</ul>\n<pre><code>var pattern = /^[A-Za-z0-9]+$/;\n</code></pre><ul>\n<li>判断是否由字母组成（大小写）</li>\n</ul>\n<pre><code>var pattern  = /^[a-zA-Z]+$/;\n</code></pre><ul>\n<li>判断是否由纯小写字母组成</li>\n</ul>\n<pre><code>var pattern = /^[a-z]+$/;\n</code></pre><ul>\n<li>判断是否由纯大写字母组成</li>\n</ul>\n<pre><code>var pattern  = /^[A-Z]+$/;\n</code></pre><ul>\n<li>判断是否由中文和数字组成</li>\n</ul>\n<pre><code>var pattern  = /^((?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])|(\\d))+$/\n</code></pre><ul>\n<li>判断不允许包含字母</li>\n</ul>\n<pre><code>var pattern = /^[^A-Za-z]*$/;\n</code></pre><ul>\n<li>判断是否纯中文</li>\n</ul>\n<pre><code>var  pattern = /^(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])+$/;\n</code></pre><ul>\n<li>判断是否是小数</li>\n</ul>\n<pre><code>var pattern = /^\\d+\\.\\d+$/;\n</code></pre><ul>\n<li>判断是否正整数</li>\n</ul>\n<pre><code>var pattern = /^\\d+$/;\n</code></pre><ul>\n<li>判断是否负整数</li>\n</ul>\n<pre><code>var pattern = /^-\\d+$/;\n</code></pre><ul>\n<li>判断是否整数</li>\n</ul>\n<pre><code>var pattern = /^-?\\d+$/;\n</code></pre><ul>\n<li>判断是否正数（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否负数（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^-\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否数字（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^-?\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否是邮箱</li>\n</ul>\n<pre><code>var pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>常见正则表达式</p>","more":"<ul>\n<li>判断用户名——4到16位（字母，数字，下划线，减号）</li>\n</ul>\n<pre><code>var pattern = /^[a-zA-Z0-9_-]{4,16}$/;\n</code></pre><ul>\n<li>判断纯数字</li>\n</ul>\n<pre><code>var pattern = /^\\d{1,}$/;\n</code></pre><ul>\n<li>判断是否由数字和字母组成</li>\n</ul>\n<pre><code>var pattern = /^[A-Za-z0-9]+$/;\n</code></pre><ul>\n<li>判断是否由字母组成（大小写）</li>\n</ul>\n<pre><code>var pattern  = /^[a-zA-Z]+$/;\n</code></pre><ul>\n<li>判断是否由纯小写字母组成</li>\n</ul>\n<pre><code>var pattern = /^[a-z]+$/;\n</code></pre><ul>\n<li>判断是否由纯大写字母组成</li>\n</ul>\n<pre><code>var pattern  = /^[A-Z]+$/;\n</code></pre><ul>\n<li>判断是否由中文和数字组成</li>\n</ul>\n<pre><code>var pattern  = /^((?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])|(\\d))+$/\n</code></pre><ul>\n<li>判断不允许包含字母</li>\n</ul>\n<pre><code>var pattern = /^[^A-Za-z]*$/;\n</code></pre><ul>\n<li>判断是否纯中文</li>\n</ul>\n<pre><code>var  pattern = /^(?:[\\u3400-\\u4DB5\\u4E00-\\u9FEA\\uFA0E\\uFA0F\\uFA11\\uFA13\\uFA14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29]|[\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879][\\uDC00-\\uDFFF]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0])+$/;\n</code></pre><ul>\n<li>判断是否是小数</li>\n</ul>\n<pre><code>var pattern = /^\\d+\\.\\d+$/;\n</code></pre><ul>\n<li>判断是否正整数</li>\n</ul>\n<pre><code>var pattern = /^\\d+$/;\n</code></pre><ul>\n<li>判断是否负整数</li>\n</ul>\n<pre><code>var pattern = /^-\\d+$/;\n</code></pre><ul>\n<li>判断是否整数</li>\n</ul>\n<pre><code>var pattern = /^-?\\d+$/;\n</code></pre><ul>\n<li>判断是否正数（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否负数（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^-\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否数字（包含整数和小数）</li>\n</ul>\n<pre><code>var pattern = /^-?\\d*\\.?\\d+$/;\n</code></pre><ul>\n<li>判断是否是邮箱</li>\n</ul>\n<pre><code>var pattern = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n</code></pre>"},{"title":"数组的 map、filter、sort 和 reduce 的用法","date":"2018-08-01T03:54:05.000Z","_content":"\n> 本文文章来讲述一下关于map、filter、sort 和 reduce 的用法，如果有错误的地方欢迎下伙伴来指正、\n\n<!-- more -->\n\n# 基本概念\n\n1. map 遍历数组返回一个新的数组，返回的是加工之后的值。\n2. filter 遍历过滤出一个新的子数组， 返回条件为true的值。\n3. sort 数组排序。\n4. reduce 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n    reduce() 可以作为一个高阶函数，用于函数的 compose。\n    reduce() 对于空数组是不会执行对调函数的。\n\n# 通过一些题目来更加熟悉这些东西吧~\n## 题目\n这个题目是网上获取的，可以再浏览器控制台打印结果。这边给出两个数组\n* 第一个数组\n```\nconst inventors = [\n    { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },\n    { first: 'wawa', last: 'fs', year: 1830, passed: 1905 },\n    { first: 'grvd', last: 'xcvxcv', year:1900, passed: 1977 },\n    { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 }\n];\n```\n* 第二个数组\n```\n['Albert, Einstein', 'wawa, fs', 'grvd, xcvxcv', 'Hanna, Hammarström']\n```\n\n**题目如下：**\n* 筛选出生于1800-1900的发明家；\n* 以数组形式，列出其名与姓；\n* 根据其出生日期，并从大到小排序；\n* 计算所有的发明家加起来一共活了几岁；\n\n## 解决方法\n* 第一个问题：筛选出生于1800-1900的人。\n  这边因为是筛选，可以用 filter 方法。\n  **注意**：filter 不会对空数组进行检测\n  **注意**：filter 不会改变原始数组\n  ```\n  funtction born(inventor) {\n      return inventor.year >= 1800 && inventor.year < 1900;\n  }\n  var person = inventors.filter(born); // filter 参数是一个函数，做筛选用。\n  console.log(person);\n  // 简化的写法\n  var person = inventors.filter(inventor => (inventor.year >= 1800 && inventor.year < 1900));\n  ```\n\n* 第二个问题：以数组形式，列出其名与姓。\n  以数组形式返回，可以对原数组进行处理，这边用 map 方法。\n  **注意**：map 不会对空数组进行检测\n  **注意**：map 不会改变原始数组\n  ```\n   const fullnames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);\n   console.log(fullnames);\n  ```\n* 第三个问题：根据其出生日期，并从大到小排序。\n  按照出生日期进行排序，采用 sort 方法。\n  ```\n   const birthdate = inventors.sort((inventora, inventorb) => (inventorb.year - inventora.year));\n   console.log(birthdate)\n  ```\n* 第四个问题：计算所有的发明家加起来一共活了几岁。\n  计算总过获得岁数，采用 reduce 方法\n  ```\n  const totalyears = inventors.reduce(\n      (total, inventor) => { return total + (inventor.passed - inventor.year); }, 0\n      );\n  console.log(totalyears);\n  ```\n\n","source":"_posts/数组的map.md","raw":"---\ntitle: 数组的 map、filter、sort 和 reduce 的用法\ndate: 2018-08-01 11:54:05\ntags: js知识\ncategories: JS\n---\n\n> 本文文章来讲述一下关于map、filter、sort 和 reduce 的用法，如果有错误的地方欢迎下伙伴来指正、\n\n<!-- more -->\n\n# 基本概念\n\n1. map 遍历数组返回一个新的数组，返回的是加工之后的值。\n2. filter 遍历过滤出一个新的子数组， 返回条件为true的值。\n3. sort 数组排序。\n4. reduce 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。\n    reduce() 可以作为一个高阶函数，用于函数的 compose。\n    reduce() 对于空数组是不会执行对调函数的。\n\n# 通过一些题目来更加熟悉这些东西吧~\n## 题目\n这个题目是网上获取的，可以再浏览器控制台打印结果。这边给出两个数组\n* 第一个数组\n```\nconst inventors = [\n    { first: 'Albert', last: 'Einstein', year: 1879, passed: 1955 },\n    { first: 'wawa', last: 'fs', year: 1830, passed: 1905 },\n    { first: 'grvd', last: 'xcvxcv', year:1900, passed: 1977 },\n    { first: 'Hanna', last: 'Hammarström', year: 1829, passed: 1909 }\n];\n```\n* 第二个数组\n```\n['Albert, Einstein', 'wawa, fs', 'grvd, xcvxcv', 'Hanna, Hammarström']\n```\n\n**题目如下：**\n* 筛选出生于1800-1900的发明家；\n* 以数组形式，列出其名与姓；\n* 根据其出生日期，并从大到小排序；\n* 计算所有的发明家加起来一共活了几岁；\n\n## 解决方法\n* 第一个问题：筛选出生于1800-1900的人。\n  这边因为是筛选，可以用 filter 方法。\n  **注意**：filter 不会对空数组进行检测\n  **注意**：filter 不会改变原始数组\n  ```\n  funtction born(inventor) {\n      return inventor.year >= 1800 && inventor.year < 1900;\n  }\n  var person = inventors.filter(born); // filter 参数是一个函数，做筛选用。\n  console.log(person);\n  // 简化的写法\n  var person = inventors.filter(inventor => (inventor.year >= 1800 && inventor.year < 1900));\n  ```\n\n* 第二个问题：以数组形式，列出其名与姓。\n  以数组形式返回，可以对原数组进行处理，这边用 map 方法。\n  **注意**：map 不会对空数组进行检测\n  **注意**：map 不会改变原始数组\n  ```\n   const fullnames = inventors.map(inventor => `${inventor.first} ${inventor.last}`);\n   console.log(fullnames);\n  ```\n* 第三个问题：根据其出生日期，并从大到小排序。\n  按照出生日期进行排序，采用 sort 方法。\n  ```\n   const birthdate = inventors.sort((inventora, inventorb) => (inventorb.year - inventora.year));\n   console.log(birthdate)\n  ```\n* 第四个问题：计算所有的发明家加起来一共活了几岁。\n  计算总过获得岁数，采用 reduce 方法\n  ```\n  const totalyears = inventors.reduce(\n      (total, inventor) => { return total + (inventor.passed - inventor.year); }, 0\n      );\n  console.log(totalyears);\n  ```\n\n","slug":"数组的map","published":1,"updated":"2019-09-18T09:03:02.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx850018egqni4nkpwl1","content":"<blockquote>\n<p>本文文章来讲述一下关于map、filter、sort 和 reduce 的用法，如果有错误的地方欢迎下伙伴来指正、</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>map 遍历数组返回一个新的数组，返回的是加工之后的值。</li>\n<li>filter 遍历过滤出一个新的子数组， 返回条件为true的值。</li>\n<li>sort 数组排序。</li>\n<li>reduce 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br> reduce() 可以作为一个高阶函数，用于函数的 compose。<br> reduce() 对于空数组是不会执行对调函数的。</li>\n</ol>\n<h1 id=\"通过一些题目来更加熟悉这些东西吧\"><a href=\"#通过一些题目来更加熟悉这些东西吧\" class=\"headerlink\" title=\"通过一些题目来更加熟悉这些东西吧~\"></a>通过一些题目来更加熟悉这些东西吧~</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>这个题目是网上获取的，可以再浏览器控制台打印结果。这边给出两个数组</p>\n<ul>\n<li>第一个数组<pre><code>const inventors = [\n  { first: &#39;Albert&#39;, last: &#39;Einstein&#39;, year: 1879, passed: 1955 },\n  { first: &#39;wawa&#39;, last: &#39;fs&#39;, year: 1830, passed: 1905 },\n  { first: &#39;grvd&#39;, last: &#39;xcvxcv&#39;, year:1900, passed: 1977 },\n  { first: &#39;Hanna&#39;, last: &#39;Hammarström&#39;, year: 1829, passed: 1909 }\n];\n</code></pre></li>\n<li>第二个数组<pre><code>[&#39;Albert, Einstein&#39;, &#39;wawa, fs&#39;, &#39;grvd, xcvxcv&#39;, &#39;Hanna, Hammarström&#39;]\n</code></pre></li>\n</ul>\n<p><strong>题目如下：</strong></p>\n<ul>\n<li>筛选出生于1800-1900的发明家；</li>\n<li>以数组形式，列出其名与姓；</li>\n<li>根据其出生日期，并从大到小排序；</li>\n<li>计算所有的发明家加起来一共活了几岁；</li>\n</ul>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ul>\n<li><p>第一个问题：筛选出生于1800-1900的人。<br>这边因为是筛选，可以用 filter 方法。<br><strong>注意</strong>：filter 不会对空数组进行检测<br><strong>注意</strong>：filter 不会改变原始数组</p>\n<pre><code>funtction born(inventor) {\n    return inventor.year &gt;= 1800 &amp;&amp; inventor.year &lt; 1900;\n}\nvar person = inventors.filter(born); // filter 参数是一个函数，做筛选用。\nconsole.log(person);\n// 简化的写法\nvar person = inventors.filter(inventor =&gt; (inventor.year &gt;= 1800 &amp;&amp; inventor.year &lt; 1900));\n</code></pre></li>\n<li><p>第二个问题：以数组形式，列出其名与姓。<br>以数组形式返回，可以对原数组进行处理，这边用 map 方法。<br><strong>注意</strong>：map 不会对空数组进行检测<br><strong>注意</strong>：map 不会改变原始数组</p>\n<pre><code> const fullnames = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);\n console.log(fullnames);\n</code></pre></li>\n<li>第三个问题：根据其出生日期，并从大到小排序。<br>按照出生日期进行排序，采用 sort 方法。<pre><code> const birthdate = inventors.sort((inventora, inventorb) =&gt; (inventorb.year - inventora.year));\n console.log(birthdate)\n</code></pre></li>\n<li>第四个问题：计算所有的发明家加起来一共活了几岁。<br>计算总过获得岁数，采用 reduce 方法<pre><code>const totalyears = inventors.reduce(\n    (total, inventor) =&gt; { return total + (inventor.passed - inventor.year); }, 0\n    );\nconsole.log(totalyears);\n</code></pre></li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>本文文章来讲述一下关于map、filter、sort 和 reduce 的用法，如果有错误的地方欢迎下伙伴来指正、</p>\n</blockquote>","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ol>\n<li>map 遍历数组返回一个新的数组，返回的是加工之后的值。</li>\n<li>filter 遍历过滤出一个新的子数组， 返回条件为true的值。</li>\n<li>sort 数组排序。</li>\n<li>reduce 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。<br> reduce() 可以作为一个高阶函数，用于函数的 compose。<br> reduce() 对于空数组是不会执行对调函数的。</li>\n</ol>\n<h1 id=\"通过一些题目来更加熟悉这些东西吧\"><a href=\"#通过一些题目来更加熟悉这些东西吧\" class=\"headerlink\" title=\"通过一些题目来更加熟悉这些东西吧~\"></a>通过一些题目来更加熟悉这些东西吧~</h1><h2 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p>这个题目是网上获取的，可以再浏览器控制台打印结果。这边给出两个数组</p>\n<ul>\n<li>第一个数组<pre><code>const inventors = [\n  { first: &#39;Albert&#39;, last: &#39;Einstein&#39;, year: 1879, passed: 1955 },\n  { first: &#39;wawa&#39;, last: &#39;fs&#39;, year: 1830, passed: 1905 },\n  { first: &#39;grvd&#39;, last: &#39;xcvxcv&#39;, year:1900, passed: 1977 },\n  { first: &#39;Hanna&#39;, last: &#39;Hammarström&#39;, year: 1829, passed: 1909 }\n];\n</code></pre></li>\n<li>第二个数组<pre><code>[&#39;Albert, Einstein&#39;, &#39;wawa, fs&#39;, &#39;grvd, xcvxcv&#39;, &#39;Hanna, Hammarström&#39;]\n</code></pre></li>\n</ul>\n<p><strong>题目如下：</strong></p>\n<ul>\n<li>筛选出生于1800-1900的发明家；</li>\n<li>以数组形式，列出其名与姓；</li>\n<li>根据其出生日期，并从大到小排序；</li>\n<li>计算所有的发明家加起来一共活了几岁；</li>\n</ul>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><ul>\n<li><p>第一个问题：筛选出生于1800-1900的人。<br>这边因为是筛选，可以用 filter 方法。<br><strong>注意</strong>：filter 不会对空数组进行检测<br><strong>注意</strong>：filter 不会改变原始数组</p>\n<pre><code>funtction born(inventor) {\n    return inventor.year &gt;= 1800 &amp;&amp; inventor.year &lt; 1900;\n}\nvar person = inventors.filter(born); // filter 参数是一个函数，做筛选用。\nconsole.log(person);\n// 简化的写法\nvar person = inventors.filter(inventor =&gt; (inventor.year &gt;= 1800 &amp;&amp; inventor.year &lt; 1900));\n</code></pre></li>\n<li><p>第二个问题：以数组形式，列出其名与姓。<br>以数组形式返回，可以对原数组进行处理，这边用 map 方法。<br><strong>注意</strong>：map 不会对空数组进行检测<br><strong>注意</strong>：map 不会改变原始数组</p>\n<pre><code> const fullnames = inventors.map(inventor =&gt; `${inventor.first} ${inventor.last}`);\n console.log(fullnames);\n</code></pre></li>\n<li>第三个问题：根据其出生日期，并从大到小排序。<br>按照出生日期进行排序，采用 sort 方法。<pre><code> const birthdate = inventors.sort((inventora, inventorb) =&gt; (inventorb.year - inventora.year));\n console.log(birthdate)\n</code></pre></li>\n<li>第四个问题：计算所有的发明家加起来一共活了几岁。<br>计算总过获得岁数，采用 reduce 方法<pre><code>const totalyears = inventors.reduce(\n    (total, inventor) =&gt; { return total + (inventor.passed - inventor.year); }, 0\n    );\nconsole.log(totalyears);\n</code></pre></li>\n</ul>"},{"title":"记一次换电脑之后hexo 怎么处理","date":"2019-05-27T07:48:41.000Z","_content":"\n> 记一次换电脑之后hexo 怎么处理\n\n<!-- more -->\n\n之前的博客都是在公司电脑上抽空写的，换了公司之后想要重新写这个blog，发现下载之后会出现一个问题，```No layout:index.html```<br>\n\n遇到这个问题我就要想要怎么处理不是.<br>\n\n我把所有npm中该下载的都下载了，发现还是不对。然后我查看内容之后还是不对，我把所有的下载啥的都尝试了之后，还是不行我咋整呀。我都想放弃了，重新搞一个拉倒<br>\n\n然后我查看了我的themes里面的主题 发现我的主题是空的，之后下载了主题之后就好了，∑(っ°Д°;)っ卧槽。<br>\n\ngit 的问题可以通过 删除.deploy_git 就好了","source":"_posts/记一次换电脑之后hexo-怎么处理.md","raw":"---\ntitle: 记一次换电脑之后hexo 怎么处理\ndate: 2019-05-27 15:48:41\ntags: hexo\ncategories: JS\n---\n\n> 记一次换电脑之后hexo 怎么处理\n\n<!-- more -->\n\n之前的博客都是在公司电脑上抽空写的，换了公司之后想要重新写这个blog，发现下载之后会出现一个问题，```No layout:index.html```<br>\n\n遇到这个问题我就要想要怎么处理不是.<br>\n\n我把所有npm中该下载的都下载了，发现还是不对。然后我查看内容之后还是不对，我把所有的下载啥的都尝试了之后，还是不行我咋整呀。我都想放弃了，重新搞一个拉倒<br>\n\n然后我查看了我的themes里面的主题 发现我的主题是空的，之后下载了主题之后就好了，∑(っ°Д°;)っ卧槽。<br>\n\ngit 的问题可以通过 删除.deploy_git 就好了","slug":"记一次换电脑之后hexo-怎么处理","published":1,"updated":"2019-09-18T09:02:06.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx87001begqnoc1a8jym","content":"<blockquote>\n<p>记一次换电脑之后hexo 怎么处理</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>之前的博客都是在公司电脑上抽空写的，换了公司之后想要重新写这个blog，发现下载之后会出现一个问题，<code>No layout:index.html</code><br></p>\n<p>遇到这个问题我就要想要怎么处理不是.<br></p>\n<p>我把所有npm中该下载的都下载了，发现还是不对。然后我查看内容之后还是不对，我把所有的下载啥的都尝试了之后，还是不行我咋整呀。我都想放弃了，重新搞一个拉倒<br></p>\n<p>然后我查看了我的themes里面的主题 发现我的主题是空的，之后下载了主题之后就好了，∑(っ°Д°;)っ卧槽。<br></p>\n<p>git 的问题可以通过 删除.deploy_git 就好了</p>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>记一次换电脑之后hexo 怎么处理</p>\n</blockquote>","more":"<p>之前的博客都是在公司电脑上抽空写的，换了公司之后想要重新写这个blog，发现下载之后会出现一个问题，<code>No layout:index.html</code><br></p>\n<p>遇到这个问题我就要想要怎么处理不是.<br></p>\n<p>我把所有npm中该下载的都下载了，发现还是不对。然后我查看内容之后还是不对，我把所有的下载啥的都尝试了之后，还是不行我咋整呀。我都想放弃了，重新搞一个拉倒<br></p>\n<p>然后我查看了我的themes里面的主题 发现我的主题是空的，之后下载了主题之后就好了，∑(っ°Д°;)っ卧槽。<br></p>\n<p>git 的问题可以通过 删除.deploy_git 就好了</p>"},{"title":"一些面试题","date":"2019-06-04T00:35:06.000Z","_content":"> 学而不思则罔，思而不学则殆。这一篇会将一些看到的面试题做一个总结。以后看到新的面试题也会持续的更新在这个里面。\n\n<!-- more -->\n\n## HTML 和 CSS 面试题\n### 盒子模型\n   CSS 中盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。 \n   W3C 盒子模型： width = content （box-sizing: content-box）\n   IE 盒子模型中： width = content + padding + border （box-sizing: border-box）\n\n### 块元素和行内元素\n   \n| 块元素 | 行内元素 |\n| ------ | ------ |\n| 块元素会独占一行，默认情况下，其宽度会自动填满父元素宽度，即使设置了宽度也会独占一行 | 行内元素不会独占一行，没有宽度和和高度属性。 |\n| 块级元素：div p form ul li h1-h6 | 行内元素：span img input a i |\n\n### 前端需要注意哪些SEO\n* 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可\n* 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页\n* 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n* 重要内容不要用js输出：爬虫不会执行js获取内容\n* 少用iframe：搜索引擎不会抓取iframe中的内容\n* 非装饰性图片必须加alt\n* 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n### 从浏览器地址栏输入url到显示页面的步骤\n* 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n* 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n* 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n* 载入解析到的资源文件，渲染页面，完成。\n\n### HTTP状态码及其含义\n* 1XX：信息状态码\n\t* 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n* 2XX：成功状态码\n\t* 200 OK 正常返回信息\n\t* 201 Created 请求成功并且服务器创建了新的资源\n\t* 202 Accepted 服务器已接受请求，但尚未处理\n* 3XX：重定向\n\t* 301 Moved Permanently 请求的网页已永久移动到新位置。\n\t* 302 Found 临时性重定向。\n\t* 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。\n\t* 304 Not Modified 自从上次请求后，请求的网页未修改过。\n* 4XX：客户端错误\n\t* 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n\t* 401 Unauthorized 请求未授权。\n\t* 403 Forbidden 禁止访问。\n\t* 404 Not Found 找不到如何与 URI 相匹配的资源。\n* 5XX: 服务器错误\n\t* 500 Internal Server Error 最常见的服务器端错误。\n\t* 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n\n### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\n* 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n* 离线的情况下，浏览器就直接使用离线存储的资源。\n\n### Canvas和SVG有什么区别？\n* svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布\n* svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿\n\n### CSS 选择器分类\n基本选择器：\n* id选择器：id = name\n* 类选择器：class = \"name\"\n* 标签选择器：body, div, ul\n* 全局选择器：* \n\n复杂选择器：\n* 组合选择器：.head .head_logo\n* 后代选择器：ul li 从父集到子集\n* 群组选择器：div span {color: red} 具有相同样式的标签分组显示\n* 继承选择器：\n* 为类选择器：链接样式 a:hover\n* 子选择器：div > p \n* css 相邻兄弟选择器： h1 + p\n\n优先级：\n* 属性后面加 !import 会覆盖页面内任何位置定义的元素样式\n* 作为 style 属性写在元素内的样式\n* id 选择器\n* 类选择器\n* 标签选择器\n* 通配符选择器（*）\n* 浏览器自定义或继承\n\n### 为什么 CSS 放在顶部而 JS 写在后面\n* 浏览器预先加载 CSS 后，可以不必等待 HTML 加载完毕就可以渲染页面了。\n* HTML 渲染并不会等到完全加载完在渲染页面，而是一边解析 DOM 一边渲染。\n* JS 写在尾部，主要是因为 JS主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面，可以节省加载时间，是页面能够更好的加载，提高用户的良好体验。\n\n### position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？\n* relative： 相对定位，相对于自己本身在正常文档流中的位置进行定位。\n* absolute：生成绝对定位，相对于最近一级定位不为 static 的父元素进行定位。\n* fixed： 生成绝对定位，相对于浏览器窗口或者 iframe 进行定位。\n* static：默认值，没有定位，元素出现在正常文档流中。\n* stricky：生成粘性定位元素，容器的位置根据正常文档流计算得出。\n\n### css sprite是什么,有什么优缺点\n* 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。\n* 优点：\n    * 减少HTTP请求数，极大地提高页面加载速度\n    * 增加图片信息重复度，提高压缩比，减少图片大小\n    * 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n* 缺点：\n    * 图片合并麻烦\n    * 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n### display:inline-block 什么时候不会显示间隙？\n* 移除空格\n* 使用margin负值\n* 使用font-size:0\n* letter-spacing\n* word-spacing\n\n### PNG,GIF,JPG的区别及如何选\n* GIF\n\t* 8位像素，256色\n\t* 无损压缩\n\t* 支持简单动画\n\t* 支持boolean透明\n\t* 适合简单动画\n* JPEG\n\t* 颜色限于256\n\t* 有损压缩\n    * 可控制压缩质量\n\t* 不支持透明\n\t* 适合照片\n* PNG\n\t* 有PNG8和truecolor PNG\n    * PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画\n\t* 适合图标、背景、按钮\n\n### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n* 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n\n### CSS不同选择器的权重\n* !important规则最重要，大于其它规则\n* 行内样式规则，加1000\n* 对于选择器中给定的各个ID属性值，加100\n* 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10\n* 对于选择其中给定的各个元素标签选择器，加1\n* 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n\n\n\n## JS 面试题\n### setTimeout和setInterval的机制\n因为js是单线程的。浏览器遇到etTimeout和setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码。\n\n### 一些检验数据类型的方法\n千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n\n* typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。\n* installOf() 用来判断A是否是B的实例，installof检查的是原型。\n* toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n* hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。\n* isProperty()方法测试一个对象是否存在另一个对象的原型链上。\n* valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。\n\n### GET 和 POST 的区别，什么时候使用 POST ？\n#### GET 和 POST 的区别如下：\n\n* GET：一般用于查询数据，使用 URL 传递参数，由于浏览器对地址栏长度有限制，所以使用 GET 方式所发送信息的数量有限制，同时浏览器记录（历史记录，缓存）会保留请求地址的信息，包括地址后面的数据。GET 只能发送普通格式（URL 编码格式）的数据。\n* POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但不会记录 POST 提交的数据。POST 可以发送纯文本、URL 编码格式、二进制格式的字符串，形式多样。\n\n#### 以下情况中，请使用 POST：\n* 以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；\n* 发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；\n* 向服务器发送大量数据（数据大小限制区别）；\n* 上传文件图片时（数据类型区别）\n\n### AJAX 的局限性\n* AJAX 不支持浏览器 back 按钮。\n* 安全问题 AJAX 暴露了与服务器交互的细节。\n* 对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；\n* 跨域请求有一定限制。解决方式：jsonp；\n\n### cookie 和 session 有什么区别和联系\n* cookie 数据存放在客户的浏览器上， session 数据存放在服务器上\n* session 比 cookie 更安全\n* 单个 cookie 保存的数据不能超多 4k ， 很多浏览器限制一个站点最多保存20个 cookie\n* 一般用 cookie 来存放 sessionId\n\n### 那些操作会造成内存泄漏？\n* 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n* setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n* 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n### 说几条写JavaScript的基本规范？\n* 不要在同一行声明多个变量\n* 请使用===/!==来比较true/false或者数值\n* 使用对象字面量替代new Array这种形式\n* 不要使用全局函数\n* Switch语句必须带有default分支\n* If语句必须使用大括号\n* for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污\n\n### null，undefined 的区别？\n* undefined 表示不存在这个值。\n* undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\n* 例如变量被声明了，但没有赋值时，就等于undefined\n* null 表示一个对象被定义了，值为“空值”\n* null : 是一个对象(空对象, 没有任何属性和方法)\n* 例如作为函数的参数，表示该函数的参数不是对象；\n* 在验证null时，一定要使用　=== ，因为 ==无法分别null 和　undefined\n\n\n\n## 框架（vue/react）\n### MVVM （Model-View-ViewModel）优点：\n* 低耦合：视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n* 可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n* 独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。\n* 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。\n\n### react 和 vue 有哪些不同？谈谈你的看法\n* 两者都采用了 virtual dom 的方式，性能都很好\n* ui 上都采用组件化的写法，开发效率很高。\n* vue 采用双向数据绑定， react 是单项数据绑定。当工程规模比较大时，双向数据绑定会很难维护\n* vue 适合不会持续的，小型的 web 应用，使用 vue.js 能带来短期内较高的开发效率， 否则采用 react。\n\n### Vue 生命周期\n生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。\n* beforeCreate()\n在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用\n注意：此时，无法获取 data中的数据、methods中的方法\n* created()\n注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据\n* beforeMounted()\n在挂载开始之前被调用\n* mounted()\n此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作\n* beforeUpdated()\n数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的\n* updated()\n组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n* beforeDestroy()\n实例销毁之前调用。在这一步，实例仍然完全可用。\n使用场景：实例销毁之前，执行清理任务，比如：清除定时器等\n* destroyed()\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","source":"_posts/一些面试题.md","raw":"---\ntitle: 一些面试题\ndate: 2019-06-04 08:35:06\ntags: js知识\ncategories: JS\n---\n> 学而不思则罔，思而不学则殆。这一篇会将一些看到的面试题做一个总结。以后看到新的面试题也会持续的更新在这个里面。\n\n<!-- more -->\n\n## HTML 和 CSS 面试题\n### 盒子模型\n   CSS 中盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。 \n   W3C 盒子模型： width = content （box-sizing: content-box）\n   IE 盒子模型中： width = content + padding + border （box-sizing: border-box）\n\n### 块元素和行内元素\n   \n| 块元素 | 行内元素 |\n| ------ | ------ |\n| 块元素会独占一行，默认情况下，其宽度会自动填满父元素宽度，即使设置了宽度也会独占一行 | 行内元素不会独占一行，没有宽度和和高度属性。 |\n| 块级元素：div p form ul li h1-h6 | 行内元素：span img input a i |\n\n### 前端需要注意哪些SEO\n* 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可\n* 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页\n* 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n* 重要内容不要用js输出：爬虫不会执行js获取内容\n* 少用iframe：搜索引擎不会抓取iframe中的内容\n* 非装饰性图片必须加alt\n* 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n### 从浏览器地址栏输入url到显示页面的步骤\n* 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n* 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n* 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n* 载入解析到的资源文件，渲染页面，完成。\n\n### HTTP状态码及其含义\n* 1XX：信息状态码\n\t* 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n* 2XX：成功状态码\n\t* 200 OK 正常返回信息\n\t* 201 Created 请求成功并且服务器创建了新的资源\n\t* 202 Accepted 服务器已接受请求，但尚未处理\n* 3XX：重定向\n\t* 301 Moved Permanently 请求的网页已永久移动到新位置。\n\t* 302 Found 临时性重定向。\n\t* 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。\n\t* 304 Not Modified 自从上次请求后，请求的网页未修改过。\n* 4XX：客户端错误\n\t* 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n\t* 401 Unauthorized 请求未授权。\n\t* 403 Forbidden 禁止访问。\n\t* 404 Not Found 找不到如何与 URI 相匹配的资源。\n* 5XX: 服务器错误\n\t* 500 Internal Server Error 最常见的服务器端错误。\n\t* 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n\n### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\n* 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n* 离线的情况下，浏览器就直接使用离线存储的资源。\n\n### Canvas和SVG有什么区别？\n* svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布\n* svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿\n\n### CSS 选择器分类\n基本选择器：\n* id选择器：id = name\n* 类选择器：class = \"name\"\n* 标签选择器：body, div, ul\n* 全局选择器：* \n\n复杂选择器：\n* 组合选择器：.head .head_logo\n* 后代选择器：ul li 从父集到子集\n* 群组选择器：div span {color: red} 具有相同样式的标签分组显示\n* 继承选择器：\n* 为类选择器：链接样式 a:hover\n* 子选择器：div > p \n* css 相邻兄弟选择器： h1 + p\n\n优先级：\n* 属性后面加 !import 会覆盖页面内任何位置定义的元素样式\n* 作为 style 属性写在元素内的样式\n* id 选择器\n* 类选择器\n* 标签选择器\n* 通配符选择器（*）\n* 浏览器自定义或继承\n\n### 为什么 CSS 放在顶部而 JS 写在后面\n* 浏览器预先加载 CSS 后，可以不必等待 HTML 加载完毕就可以渲染页面了。\n* HTML 渲染并不会等到完全加载完在渲染页面，而是一边解析 DOM 一边渲染。\n* JS 写在尾部，主要是因为 JS主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面，可以节省加载时间，是页面能够更好的加载，提高用户的良好体验。\n\n### position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？\n* relative： 相对定位，相对于自己本身在正常文档流中的位置进行定位。\n* absolute：生成绝对定位，相对于最近一级定位不为 static 的父元素进行定位。\n* fixed： 生成绝对定位，相对于浏览器窗口或者 iframe 进行定位。\n* static：默认值，没有定位，元素出现在正常文档流中。\n* stricky：生成粘性定位元素，容器的位置根据正常文档流计算得出。\n\n### css sprite是什么,有什么优缺点\n* 概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。\n* 优点：\n    * 减少HTTP请求数，极大地提高页面加载速度\n    * 增加图片信息重复度，提高压缩比，减少图片大小\n    * 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n* 缺点：\n    * 图片合并麻烦\n    * 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n### display:inline-block 什么时候不会显示间隙？\n* 移除空格\n* 使用margin负值\n* 使用font-size:0\n* letter-spacing\n* word-spacing\n\n### PNG,GIF,JPG的区别及如何选\n* GIF\n\t* 8位像素，256色\n\t* 无损压缩\n\t* 支持简单动画\n\t* 支持boolean透明\n\t* 适合简单动画\n* JPEG\n\t* 颜色限于256\n\t* 有损压缩\n    * 可控制压缩质量\n\t* 不支持透明\n\t* 适合照片\n* PNG\n\t* 有PNG8和truecolor PNG\n    * PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画\n\t* 适合图标、背景、按钮\n\n### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n* 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n\n### CSS不同选择器的权重\n* !important规则最重要，大于其它规则\n* 行内样式规则，加1000\n* 对于选择器中给定的各个ID属性值，加100\n* 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10\n* 对于选择其中给定的各个元素标签选择器，加1\n* 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n\n\n\n## JS 面试题\n### setTimeout和setInterval的机制\n因为js是单线程的。浏览器遇到etTimeout和setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码。\n\n### 一些检验数据类型的方法\n千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n\n* typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。\n* installOf() 用来判断A是否是B的实例，installof检查的是原型。\n* toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。\n* hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。\n* isProperty()方法测试一个对象是否存在另一个对象的原型链上。\n* valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。\n\n### GET 和 POST 的区别，什么时候使用 POST ？\n#### GET 和 POST 的区别如下：\n\n* GET：一般用于查询数据，使用 URL 传递参数，由于浏览器对地址栏长度有限制，所以使用 GET 方式所发送信息的数量有限制，同时浏览器记录（历史记录，缓存）会保留请求地址的信息，包括地址后面的数据。GET 只能发送普通格式（URL 编码格式）的数据。\n* POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但不会记录 POST 提交的数据。POST 可以发送纯文本、URL 编码格式、二进制格式的字符串，形式多样。\n\n#### 以下情况中，请使用 POST：\n* 以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；\n* 发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；\n* 向服务器发送大量数据（数据大小限制区别）；\n* 上传文件图片时（数据类型区别）\n\n### AJAX 的局限性\n* AJAX 不支持浏览器 back 按钮。\n* 安全问题 AJAX 暴露了与服务器交互的细节。\n* 对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；\n* 跨域请求有一定限制。解决方式：jsonp；\n\n### cookie 和 session 有什么区别和联系\n* cookie 数据存放在客户的浏览器上， session 数据存放在服务器上\n* session 比 cookie 更安全\n* 单个 cookie 保存的数据不能超多 4k ， 很多浏览器限制一个站点最多保存20个 cookie\n* 一般用 cookie 来存放 sessionId\n\n### 那些操作会造成内存泄漏？\n* 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n* setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n* 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n### 说几条写JavaScript的基本规范？\n* 不要在同一行声明多个变量\n* 请使用===/!==来比较true/false或者数值\n* 使用对象字面量替代new Array这种形式\n* 不要使用全局函数\n* Switch语句必须带有default分支\n* If语句必须使用大括号\n* for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污\n\n### null，undefined 的区别？\n* undefined 表示不存在这个值。\n* undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\n* 例如变量被声明了，但没有赋值时，就等于undefined\n* null 表示一个对象被定义了，值为“空值”\n* null : 是一个对象(空对象, 没有任何属性和方法)\n* 例如作为函数的参数，表示该函数的参数不是对象；\n* 在验证null时，一定要使用　=== ，因为 ==无法分别null 和　undefined\n\n\n\n## 框架（vue/react）\n### MVVM （Model-View-ViewModel）优点：\n* 低耦合：视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\"View\"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。\n* 可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。\n* 独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。\n* 可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。\n\n### react 和 vue 有哪些不同？谈谈你的看法\n* 两者都采用了 virtual dom 的方式，性能都很好\n* ui 上都采用组件化的写法，开发效率很高。\n* vue 采用双向数据绑定， react 是单项数据绑定。当工程规模比较大时，双向数据绑定会很难维护\n* vue 适合不会持续的，小型的 web 应用，使用 vue.js 能带来短期内较高的开发效率， 否则采用 react。\n\n### Vue 生命周期\n生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。\n* beforeCreate()\n在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用\n注意：此时，无法获取 data中的数据、methods中的方法\n* created()\n注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据\n* beforeMounted()\n在挂载开始之前被调用\n* mounted()\n此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作\n* beforeUpdated()\n数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的\n* updated()\n组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n* beforeDestroy()\n实例销毁之前调用。在这一步，实例仍然完全可用。\n使用场景：实例销毁之前，执行清理任务，比如：清除定时器等\n* destroyed()\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。","slug":"一些面试题","published":1,"updated":"2019-09-18T09:03:09.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx8a001eegqnx23iehg5","content":"<blockquote>\n<p>学而不思则罔，思而不学则殆。这一篇会将一些看到的面试题做一个总结。以后看到新的面试题也会持续的更新在这个里面。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"HTML-和-CSS-面试题\"><a href=\"#HTML-和-CSS-面试题\" class=\"headerlink\" title=\"HTML 和 CSS 面试题\"></a>HTML 和 CSS 面试题</h2><h3 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h3><p>   CSS 中盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>   W3C 盒子模型： width = content （box-sizing: content-box）<br>   IE 盒子模型中： width = content + padding + border （box-sizing: border-box）</p>\n<h3 id=\"块元素和行内元素\"><a href=\"#块元素和行内元素\" class=\"headerlink\" title=\"块元素和行内元素\"></a>块元素和行内元素</h3><table>\n<thead>\n<tr>\n<th>块元素</th>\n<th>行内元素</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>块元素会独占一行，默认情况下，其宽度会自动填满父元素宽度，即使设置了宽度也会独占一行</td>\n<td>行内元素不会独占一行，没有宽度和和高度属性。</td>\n</tr>\n<tr>\n<td>块级元素：div p form ul li h1-h6</td>\n<td>行内元素：span img input a i</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端需要注意哪些SEO\"><a href=\"#前端需要注意哪些SEO\" class=\"headerlink\" title=\"前端需要注意哪些SEO\"></a>前端需要注意哪些SEO</h3><ul>\n<li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li>\n<li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>\n<li>重要内容不要用js输出：爬虫不会执行js获取内容</li>\n<li>少用iframe：搜索引擎不会抓取iframe中的内容</li>\n<li>非装饰性图片必须加alt</li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h3 id=\"从浏览器地址栏输入url到显示页面的步骤\"><a href=\"#从浏览器地址栏输入url到显示页面的步骤\" class=\"headerlink\" title=\"从浏览器地址栏输入url到显示页面的步骤\"></a>从浏览器地址栏输入url到显示页面的步骤</h3><ul>\n<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>\n<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li>\n<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>\n<li>载入解析到的资源文件，渲染页面，完成。</li>\n</ul>\n<h3 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h3><ul>\n<li>1XX：信息状态码<ul>\n<li>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n</ul>\n</li>\n<li>2XX：成功状态码<ul>\n<li>200 OK 正常返回信息</li>\n<li>201 Created 请求成功并且服务器创建了新的资源</li>\n<li>202 Accepted 服务器已接受请求，但尚未处理</li>\n</ul>\n</li>\n<li>3XX：重定向<ul>\n<li>301 Moved Permanently 请求的网页已永久移动到新位置。</li>\n<li>302 Found 临时性重定向。</li>\n<li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li>\n</ul>\n</li>\n<li>4XX：客户端错误<ul>\n<li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 请求未授权。</li>\n<li>403 Forbidden 禁止访问。</li>\n<li>404 Not Found 找不到如何与 URI 相匹配的资源。</li>\n</ul>\n</li>\n<li>5XX: 服务器错误<ul>\n<li>500 Internal Server Error 最常见的服务器端错误。</li>\n<li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢</h3><ul>\n<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>\n<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n<h3 id=\"Canvas和SVG有什么区别？\"><a href=\"#Canvas和SVG有什么区别？\" class=\"headerlink\" title=\"Canvas和SVG有什么区别？\"></a>Canvas和SVG有什么区别？</h3><ul>\n<li>svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布</li>\n<li>svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿</li>\n</ul>\n<h3 id=\"CSS-选择器分类\"><a href=\"#CSS-选择器分类\" class=\"headerlink\" title=\"CSS 选择器分类\"></a>CSS 选择器分类</h3><p>基本选择器：</p>\n<ul>\n<li>id选择器：id = name</li>\n<li>类选择器：class = “name”</li>\n<li>标签选择器：body, div, ul</li>\n<li>全局选择器：* </li>\n</ul>\n<p>复杂选择器：</p>\n<ul>\n<li>组合选择器：.head .head_logo</li>\n<li>后代选择器：ul li 从父集到子集</li>\n<li>群组选择器：div span {color: red} 具有相同样式的标签分组显示</li>\n<li>继承选择器：</li>\n<li>为类选择器：链接样式 a:hover</li>\n<li>子选择器：div &gt; p </li>\n<li>css 相邻兄弟选择器： h1 + p</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>属性后面加 !import 会覆盖页面内任何位置定义的元素样式</li>\n<li>作为 style 属性写在元素内的样式</li>\n<li>id 选择器</li>\n<li>类选择器</li>\n<li>标签选择器</li>\n<li>通配符选择器（*）</li>\n<li>浏览器自定义或继承</li>\n</ul>\n<h3 id=\"为什么-CSS-放在顶部而-JS-写在后面\"><a href=\"#为什么-CSS-放在顶部而-JS-写在后面\" class=\"headerlink\" title=\"为什么 CSS 放在顶部而 JS 写在后面\"></a>为什么 CSS 放在顶部而 JS 写在后面</h3><ul>\n<li>浏览器预先加载 CSS 后，可以不必等待 HTML 加载完毕就可以渲染页面了。</li>\n<li>HTML 渲染并不会等到完全加载完在渲染页面，而是一边解析 DOM 一边渲染。</li>\n<li>JS 写在尾部，主要是因为 JS主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面，可以节省加载时间，是页面能够更好的加载，提高用户的良好体验。</li>\n</ul>\n<h3 id=\"position-的值有哪些，-relative-和-absolute-分别是相对于谁进行定位的？\"><a href=\"#position-的值有哪些，-relative-和-absolute-分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？\"></a>position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？</h3><ul>\n<li>relative： 相对定位，相对于自己本身在正常文档流中的位置进行定位。</li>\n<li>absolute：生成绝对定位，相对于最近一级定位不为 static 的父元素进行定位。</li>\n<li>fixed： 生成绝对定位，相对于浏览器窗口或者 iframe 进行定位。</li>\n<li>static：默认值，没有定位，元素出现在正常文档流中。</li>\n<li>stricky：生成粘性定位元素，容器的位置根据正常文档流计算得出。</li>\n</ul>\n<h3 id=\"css-sprite是什么-有什么优缺点\"><a href=\"#css-sprite是什么-有什么优缺点\" class=\"headerlink\" title=\"css sprite是什么,有什么优缺点\"></a>css sprite是什么,有什么优缺点</h3><ul>\n<li>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。</li>\n<li>优点：<ul>\n<li>减少HTTP请求数，极大地提高页面加载速度</li>\n<li>增加图片信息重复度，提高压缩比，减少图片大小</li>\n<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>图片合并麻烦</li>\n<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"display-inline-block-什么时候不会显示间隙？\"><a href=\"#display-inline-block-什么时候不会显示间隙？\" class=\"headerlink\" title=\"display:inline-block 什么时候不会显示间隙？\"></a>display:inline-block 什么时候不会显示间隙？</h3><ul>\n<li>移除空格</li>\n<li>使用margin负值</li>\n<li>使用font-size:0</li>\n<li>letter-spacing</li>\n<li>word-spacing</li>\n</ul>\n<h3 id=\"PNG-GIF-JPG的区别及如何选\"><a href=\"#PNG-GIF-JPG的区别及如何选\" class=\"headerlink\" title=\"PNG,GIF,JPG的区别及如何选\"></a>PNG,GIF,JPG的区别及如何选</h3><ul>\n<li>GIF<ul>\n<li>8位像素，256色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持boolean透明</li>\n<li>适合简单动画</li>\n</ul>\n</li>\n<li>JPEG<ul>\n<li>颜色限于256</li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n</li>\n<li>PNG<ul>\n<li>有PNG8和truecolor PNG</li>\n<li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li>\n<li>适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><ul>\n<li>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</li>\n</ul>\n<h3 id=\"CSS不同选择器的权重\"><a href=\"#CSS不同选择器的权重\" class=\"headerlink\" title=\"CSS不同选择器的权重\"></a>CSS不同选择器的权重</h3><ul>\n<li>!important规则最重要，大于其它规则</li>\n<li>行内样式规则，加1000</li>\n<li>对于选择器中给定的各个ID属性值，加100</li>\n<li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10</li>\n<li>对于选择其中给定的各个元素标签选择器，加1</li>\n<li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li>\n</ul>\n<h2 id=\"JS-面试题\"><a href=\"#JS-面试题\" class=\"headerlink\" title=\"JS 面试题\"></a>JS 面试题</h2><h3 id=\"setTimeout和setInterval的机制\"><a href=\"#setTimeout和setInterval的机制\" class=\"headerlink\" title=\"setTimeout和setInterval的机制\"></a>setTimeout和setInterval的机制</h3><p>因为js是单线程的。浏览器遇到etTimeout和setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码。</p>\n<h3 id=\"一些检验数据类型的方法\"><a href=\"#一些检验数据类型的方法\" class=\"headerlink\" title=\"一些检验数据类型的方法\"></a>一些检验数据类型的方法</h3><p>千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。</p>\n<ul>\n<li>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</li>\n<li>installOf() 用来判断A是否是B的实例，installof检查的是原型。</li>\n<li>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</li>\n<li>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</li>\n<li>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</li>\n<li>valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。</li>\n</ul>\n<h3 id=\"GET-和-POST-的区别，什么时候使用-POST-？\"><a href=\"#GET-和-POST-的区别，什么时候使用-POST-？\" class=\"headerlink\" title=\"GET 和 POST 的区别，什么时候使用 POST ？\"></a>GET 和 POST 的区别，什么时候使用 POST ？</h3><h4 id=\"GET-和-POST-的区别如下：\"><a href=\"#GET-和-POST-的区别如下：\" class=\"headerlink\" title=\"GET 和 POST 的区别如下：\"></a>GET 和 POST 的区别如下：</h4><ul>\n<li>GET：一般用于查询数据，使用 URL 传递参数，由于浏览器对地址栏长度有限制，所以使用 GET 方式所发送信息的数量有限制，同时浏览器记录（历史记录，缓存）会保留请求地址的信息，包括地址后面的数据。GET 只能发送普通格式（URL 编码格式）的数据。</li>\n<li>POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但不会记录 POST 提交的数据。POST 可以发送纯文本、URL 编码格式、二进制格式的字符串，形式多样。</li>\n</ul>\n<h4 id=\"以下情况中，请使用-POST：\"><a href=\"#以下情况中，请使用-POST：\" class=\"headerlink\" title=\"以下情况中，请使用 POST：\"></a>以下情况中，请使用 POST：</h4><ul>\n<li>以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；</li>\n<li>发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；</li>\n<li>向服务器发送大量数据（数据大小限制区别）；</li>\n<li>上传文件图片时（数据类型区别）</li>\n</ul>\n<h3 id=\"AJAX-的局限性\"><a href=\"#AJAX-的局限性\" class=\"headerlink\" title=\"AJAX 的局限性\"></a>AJAX 的局限性</h3><ul>\n<li>AJAX 不支持浏览器 back 按钮。</li>\n<li>安全问题 AJAX 暴露了与服务器交互的细节。</li>\n<li>对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；</li>\n<li>跨域请求有一定限制。解决方式：jsonp；</li>\n</ul>\n<h3 id=\"cookie-和-session-有什么区别和联系\"><a href=\"#cookie-和-session-有什么区别和联系\" class=\"headerlink\" title=\"cookie 和 session 有什么区别和联系\"></a>cookie 和 session 有什么区别和联系</h3><ul>\n<li>cookie 数据存放在客户的浏览器上， session 数据存放在服务器上</li>\n<li>session 比 cookie 更安全</li>\n<li>单个 cookie 保存的数据不能超多 4k ， 很多浏览器限制一个站点最多保存20个 cookie</li>\n<li>一般用 cookie 来存放 sessionId</li>\n</ul>\n<h3 id=\"那些操作会造成内存泄漏？\"><a href=\"#那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"那些操作会造成内存泄漏？\"></a>那些操作会造成内存泄漏？</h3><ul>\n<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ul>\n<h3 id=\"说几条写JavaScript的基本规范？\"><a href=\"#说几条写JavaScript的基本规范？\" class=\"headerlink\" title=\"说几条写JavaScript的基本规范？\"></a>说几条写JavaScript的基本规范？</h3><ul>\n<li>不要在同一行声明多个变量</li>\n<li>请使用===/!==来比较true/false或者数值</li>\n<li>使用对象字面量替代new Array这种形式</li>\n<li>不要使用全局函数</li>\n<li>Switch语句必须带有default分支</li>\n<li>If语句必须使用大括号</li>\n<li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li>\n</ul>\n<h3 id=\"null，undefined-的区别？\"><a href=\"#null，undefined-的区别？\" class=\"headerlink\" title=\"null，undefined 的区别？\"></a>null，undefined 的区别？</h3><ul>\n<li>undefined 表示不存在这个值。</li>\n<li>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</li>\n<li>例如变量被声明了，但没有赋值时，就等于undefined</li>\n<li>null 表示一个对象被定义了，值为“空值”</li>\n<li>null : 是一个对象(空对象, 没有任何属性和方法)</li>\n<li>例如作为函数的参数，表示该函数的参数不是对象；</li>\n<li>在验证null时，一定要使用　=== ，因为 ==无法分别null 和　undefined</li>\n</ul>\n<h2 id=\"框架（vue-react）\"><a href=\"#框架（vue-react）\" class=\"headerlink\" title=\"框架（vue/react）\"></a>框架（vue/react）</h2><h3 id=\"MVVM-（Model-View-ViewModel）优点：\"><a href=\"#MVVM-（Model-View-ViewModel）优点：\" class=\"headerlink\" title=\"MVVM （Model-View-ViewModel）优点：\"></a>MVVM （Model-View-ViewModel）优点：</h3><ul>\n<li>低耦合：视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>\n<li>独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</li>\n<li>可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li>\n</ul>\n<h3 id=\"react-和-vue-有哪些不同？谈谈你的看法\"><a href=\"#react-和-vue-有哪些不同？谈谈你的看法\" class=\"headerlink\" title=\"react 和 vue 有哪些不同？谈谈你的看法\"></a>react 和 vue 有哪些不同？谈谈你的看法</h3><ul>\n<li>两者都采用了 virtual dom 的方式，性能都很好</li>\n<li>ui 上都采用组件化的写法，开发效率很高。</li>\n<li>vue 采用双向数据绑定， react 是单项数据绑定。当工程规模比较大时，双向数据绑定会很难维护</li>\n<li>vue 适合不会持续的，小型的 web 应用，使用 vue.js 能带来短期内较高的开发效率， 否则采用 react。</li>\n</ul>\n<h3 id=\"Vue-生命周期\"><a href=\"#Vue-生命周期\" class=\"headerlink\" title=\"Vue 生命周期\"></a>Vue 生命周期</h3><p>生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。</p>\n<ul>\n<li>beforeCreate()<br>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</li>\n<li>created()<br>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据</li>\n<li>beforeMounted()<br>在挂载开始之前被调用</li>\n<li>mounted()<br>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</li>\n<li>beforeUpdated()<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</li>\n<li>updated()<br>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>\n<li>beforeDestroy()<br>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>\n<li>destroyed()<br>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ul>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>学而不思则罔，思而不学则殆。这一篇会将一些看到的面试题做一个总结。以后看到新的面试题也会持续的更新在这个里面。</p>\n</blockquote>","more":"<h2 id=\"HTML-和-CSS-面试题\"><a href=\"#HTML-和-CSS-面试题\" class=\"headerlink\" title=\"HTML 和 CSS 面试题\"></a>HTML 和 CSS 面试题</h2><h3 id=\"盒子模型\"><a href=\"#盒子模型\" class=\"headerlink\" title=\"盒子模型\"></a>盒子模型</h3><p>   CSS 中盒子模型包括 IE 盒子模型和标准的 W3C 盒子模型。<br>   W3C 盒子模型： width = content （box-sizing: content-box）<br>   IE 盒子模型中： width = content + padding + border （box-sizing: border-box）</p>\n<h3 id=\"块元素和行内元素\"><a href=\"#块元素和行内元素\" class=\"headerlink\" title=\"块元素和行内元素\"></a>块元素和行内元素</h3><table>\n<thead>\n<tr>\n<th>块元素</th>\n<th>行内元素</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>块元素会独占一行，默认情况下，其宽度会自动填满父元素宽度，即使设置了宽度也会独占一行</td>\n<td>行内元素不会独占一行，没有宽度和和高度属性。</td>\n</tr>\n<tr>\n<td>块级元素：div p form ul li h1-h6</td>\n<td>行内元素：span img input a i</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"前端需要注意哪些SEO\"><a href=\"#前端需要注意哪些SEO\" class=\"headerlink\" title=\"前端需要注意哪些SEO\"></a>前端需要注意哪些SEO</h3><ul>\n<li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li>\n<li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>\n<li>重要内容不要用js输出：爬虫不会执行js获取内容</li>\n<li>少用iframe：搜索引擎不会抓取iframe中的内容</li>\n<li>非装饰性图片必须加alt</li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h3 id=\"从浏览器地址栏输入url到显示页面的步骤\"><a href=\"#从浏览器地址栏输入url到显示页面的步骤\" class=\"headerlink\" title=\"从浏览器地址栏输入url到显示页面的步骤\"></a>从浏览器地址栏输入url到显示页面的步骤</h3><ul>\n<li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li>\n<li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li>\n<li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li>\n<li>载入解析到的资源文件，渲染页面，完成。</li>\n</ul>\n<h3 id=\"HTTP状态码及其含义\"><a href=\"#HTTP状态码及其含义\" class=\"headerlink\" title=\"HTTP状态码及其含义\"></a>HTTP状态码及其含义</h3><ul>\n<li>1XX：信息状态码<ul>\n<li>100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n</ul>\n</li>\n<li>2XX：成功状态码<ul>\n<li>200 OK 正常返回信息</li>\n<li>201 Created 请求成功并且服务器创建了新的资源</li>\n<li>202 Accepted 服务器已接受请求，但尚未处理</li>\n</ul>\n</li>\n<li>3XX：重定向<ul>\n<li>301 Moved Permanently 请求的网页已永久移动到新位置。</li>\n<li>302 Found 临时性重定向。</li>\n<li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。</li>\n<li>304 Not Modified 自从上次请求后，请求的网页未修改过。</li>\n</ul>\n</li>\n<li>4XX：客户端错误<ul>\n<li>400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li>401 Unauthorized 请求未授权。</li>\n<li>403 Forbidden 禁止访问。</li>\n<li>404 Not Found 找不到如何与 URI 相匹配的资源。</li>\n</ul>\n</li>\n<li>5XX: 服务器错误<ul>\n<li>500 Internal Server Error 最常见的服务器端错误。</li>\n<li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢</h3><ul>\n<li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>\n<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n<h3 id=\"Canvas和SVG有什么区别？\"><a href=\"#Canvas和SVG有什么区别？\" class=\"headerlink\" title=\"Canvas和SVG有什么区别？\"></a>Canvas和SVG有什么区别？</h3><ul>\n<li>svg绘制出来的每一个图形的元素都是独立的DOM节点，能够方便的绑定事件或用来修改。canvas输出的是一整幅画布</li>\n<li>svg输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是失真和锯齿。而canvas输出标量画布，就像一张图片一样，放大会失真或者锯齿</li>\n</ul>\n<h3 id=\"CSS-选择器分类\"><a href=\"#CSS-选择器分类\" class=\"headerlink\" title=\"CSS 选择器分类\"></a>CSS 选择器分类</h3><p>基本选择器：</p>\n<ul>\n<li>id选择器：id = name</li>\n<li>类选择器：class = “name”</li>\n<li>标签选择器：body, div, ul</li>\n<li>全局选择器：* </li>\n</ul>\n<p>复杂选择器：</p>\n<ul>\n<li>组合选择器：.head .head_logo</li>\n<li>后代选择器：ul li 从父集到子集</li>\n<li>群组选择器：div span {color: red} 具有相同样式的标签分组显示</li>\n<li>继承选择器：</li>\n<li>为类选择器：链接样式 a:hover</li>\n<li>子选择器：div &gt; p </li>\n<li>css 相邻兄弟选择器： h1 + p</li>\n</ul>\n<p>优先级：</p>\n<ul>\n<li>属性后面加 !import 会覆盖页面内任何位置定义的元素样式</li>\n<li>作为 style 属性写在元素内的样式</li>\n<li>id 选择器</li>\n<li>类选择器</li>\n<li>标签选择器</li>\n<li>通配符选择器（*）</li>\n<li>浏览器自定义或继承</li>\n</ul>\n<h3 id=\"为什么-CSS-放在顶部而-JS-写在后面\"><a href=\"#为什么-CSS-放在顶部而-JS-写在后面\" class=\"headerlink\" title=\"为什么 CSS 放在顶部而 JS 写在后面\"></a>为什么 CSS 放在顶部而 JS 写在后面</h3><ul>\n<li>浏览器预先加载 CSS 后，可以不必等待 HTML 加载完毕就可以渲染页面了。</li>\n<li>HTML 渲染并不会等到完全加载完在渲染页面，而是一边解析 DOM 一边渲染。</li>\n<li>JS 写在尾部，主要是因为 JS主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面，可以节省加载时间，是页面能够更好的加载，提高用户的良好体验。</li>\n</ul>\n<h3 id=\"position-的值有哪些，-relative-和-absolute-分别是相对于谁进行定位的？\"><a href=\"#position-的值有哪些，-relative-和-absolute-分别是相对于谁进行定位的？\" class=\"headerlink\" title=\"position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？\"></a>position 的值有哪些， relative 和 absolute 分别是相对于谁进行定位的？</h3><ul>\n<li>relative： 相对定位，相对于自己本身在正常文档流中的位置进行定位。</li>\n<li>absolute：生成绝对定位，相对于最近一级定位不为 static 的父元素进行定位。</li>\n<li>fixed： 生成绝对定位，相对于浏览器窗口或者 iframe 进行定位。</li>\n<li>static：默认值，没有定位，元素出现在正常文档流中。</li>\n<li>stricky：生成粘性定位元素，容器的位置根据正常文档流计算得出。</li>\n</ul>\n<h3 id=\"css-sprite是什么-有什么优缺点\"><a href=\"#css-sprite是什么-有什么优缺点\" class=\"headerlink\" title=\"css sprite是什么,有什么优缺点\"></a>css sprite是什么,有什么优缺点</h3><ul>\n<li>概念：将多个小图片拼接到一个图片中。通过background-position和元素尺寸调节需要显示的背景图案。</li>\n<li>优点：<ul>\n<li>减少HTTP请求数，极大地提高页面加载速度</li>\n<li>增加图片信息重复度，提高压缩比，减少图片大小</li>\n<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>图片合并麻烦</li>\n<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"display-inline-block-什么时候不会显示间隙？\"><a href=\"#display-inline-block-什么时候不会显示间隙？\" class=\"headerlink\" title=\"display:inline-block 什么时候不会显示间隙？\"></a>display:inline-block 什么时候不会显示间隙？</h3><ul>\n<li>移除空格</li>\n<li>使用margin负值</li>\n<li>使用font-size:0</li>\n<li>letter-spacing</li>\n<li>word-spacing</li>\n</ul>\n<h3 id=\"PNG-GIF-JPG的区别及如何选\"><a href=\"#PNG-GIF-JPG的区别及如何选\" class=\"headerlink\" title=\"PNG,GIF,JPG的区别及如何选\"></a>PNG,GIF,JPG的区别及如何选</h3><ul>\n<li>GIF<ul>\n<li>8位像素，256色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持boolean透明</li>\n<li>适合简单动画</li>\n</ul>\n</li>\n<li>JPEG<ul>\n<li>颜色限于256</li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n</li>\n<li>PNG<ul>\n<li>有PNG8和truecolor PNG</li>\n<li>PNG8类似GIF颜色上限为256，文件小，支持alpha透明度，无动画</li>\n<li>适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><ul>\n<li>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</li>\n</ul>\n<h3 id=\"CSS不同选择器的权重\"><a href=\"#CSS不同选择器的权重\" class=\"headerlink\" title=\"CSS不同选择器的权重\"></a>CSS不同选择器的权重</h3><ul>\n<li>!important规则最重要，大于其它规则</li>\n<li>行内样式规则，加1000</li>\n<li>对于选择器中给定的各个ID属性值，加100</li>\n<li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加10</li>\n<li>对于选择其中给定的各个元素标签选择器，加1</li>\n<li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li>\n</ul>\n<h2 id=\"JS-面试题\"><a href=\"#JS-面试题\" class=\"headerlink\" title=\"JS 面试题\"></a>JS 面试题</h2><h3 id=\"setTimeout和setInterval的机制\"><a href=\"#setTimeout和setInterval的机制\" class=\"headerlink\" title=\"setTimeout和setInterval的机制\"></a>setTimeout和setInterval的机制</h3><p>因为js是单线程的。浏览器遇到etTimeout和setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码。</p>\n<h3 id=\"一些检验数据类型的方法\"><a href=\"#一些检验数据类型的方法\" class=\"headerlink\" title=\"一些检验数据类型的方法\"></a>一些检验数据类型的方法</h3><p>千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。</p>\n<ul>\n<li>typeOf()是判断基本类型的Boolean,Number，symbol, undefined, String。 对于引用类型：除function，都返回object null返回object。</li>\n<li>installOf() 用来判断A是否是B的实例，installof检查的是原型。</li>\n<li>toString() 是Object的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</li>\n<li>hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</li>\n<li>isProperty()方法测试一个对象是否存在另一个对象的原型链上。</li>\n<li>valueof：所有对象都有valueof，如果存在任意原始值，他就默认将对象转化为表示它的原始值。如果对象是复合值，而却大部分对象无法真正表示一个原始值，因此默认的valueof()方法简单的返回对象本身，而不是返回原始值。</li>\n</ul>\n<h3 id=\"GET-和-POST-的区别，什么时候使用-POST-？\"><a href=\"#GET-和-POST-的区别，什么时候使用-POST-？\" class=\"headerlink\" title=\"GET 和 POST 的区别，什么时候使用 POST ？\"></a>GET 和 POST 的区别，什么时候使用 POST ？</h3><h4 id=\"GET-和-POST-的区别如下：\"><a href=\"#GET-和-POST-的区别如下：\" class=\"headerlink\" title=\"GET 和 POST 的区别如下：\"></a>GET 和 POST 的区别如下：</h4><ul>\n<li>GET：一般用于查询数据，使用 URL 传递参数，由于浏览器对地址栏长度有限制，所以使用 GET 方式所发送信息的数量有限制，同时浏览器记录（历史记录，缓存）会保留请求地址的信息，包括地址后面的数据。GET 只能发送普通格式（URL 编码格式）的数据。</li>\n<li>POST：一般用于向服务器发送数据，对所发送的数据的大小理论上是没有限制，浏览器会缓存记录地址，但不会记录 POST 提交的数据。POST 可以发送纯文本、URL 编码格式、二进制格式的字符串，形式多样。</li>\n</ul>\n<h4 id=\"以下情况中，请使用-POST：\"><a href=\"#以下情况中，请使用-POST：\" class=\"headerlink\" title=\"以下情况中，请使用 POST：\"></a>以下情况中，请使用 POST：</h4><ul>\n<li>以提交为目的的请求（类似语义化，get 表示请求，post 表示提交）；</li>\n<li>发送私密类数据（用户名、密码）（因为浏览器缓存记录特性）；</li>\n<li>向服务器发送大量数据（数据大小限制区别）；</li>\n<li>上传文件图片时（数据类型区别）</li>\n</ul>\n<h3 id=\"AJAX-的局限性\"><a href=\"#AJAX-的局限性\" class=\"headerlink\" title=\"AJAX 的局限性\"></a>AJAX 的局限性</h3><ul>\n<li>AJAX 不支持浏览器 back 按钮。</li>\n<li>安全问题 AJAX 暴露了与服务器交互的细节。</li>\n<li>对搜索引擎的支持比较弱。不会执行你的 JS 脚本，只会操作你的网页源代码；</li>\n<li>跨域请求有一定限制。解决方式：jsonp；</li>\n</ul>\n<h3 id=\"cookie-和-session-有什么区别和联系\"><a href=\"#cookie-和-session-有什么区别和联系\" class=\"headerlink\" title=\"cookie 和 session 有什么区别和联系\"></a>cookie 和 session 有什么区别和联系</h3><ul>\n<li>cookie 数据存放在客户的浏览器上， session 数据存放在服务器上</li>\n<li>session 比 cookie 更安全</li>\n<li>单个 cookie 保存的数据不能超多 4k ， 很多浏览器限制一个站点最多保存20个 cookie</li>\n<li>一般用 cookie 来存放 sessionId</li>\n</ul>\n<h3 id=\"那些操作会造成内存泄漏？\"><a href=\"#那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"那些操作会造成内存泄漏？\"></a>那些操作会造成内存泄漏？</h3><ul>\n<li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ul>\n<h3 id=\"说几条写JavaScript的基本规范？\"><a href=\"#说几条写JavaScript的基本规范？\" class=\"headerlink\" title=\"说几条写JavaScript的基本规范？\"></a>说几条写JavaScript的基本规范？</h3><ul>\n<li>不要在同一行声明多个变量</li>\n<li>请使用===/!==来比较true/false或者数值</li>\n<li>使用对象字面量替代new Array这种形式</li>\n<li>不要使用全局函数</li>\n<li>Switch语句必须带有default分支</li>\n<li>If语句必须使用大括号</li>\n<li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li>\n</ul>\n<h3 id=\"null，undefined-的区别？\"><a href=\"#null，undefined-的区别？\" class=\"headerlink\" title=\"null，undefined 的区别？\"></a>null，undefined 的区别？</h3><ul>\n<li>undefined 表示不存在这个值。</li>\n<li>undefined :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</li>\n<li>例如变量被声明了，但没有赋值时，就等于undefined</li>\n<li>null 表示一个对象被定义了，值为“空值”</li>\n<li>null : 是一个对象(空对象, 没有任何属性和方法)</li>\n<li>例如作为函数的参数，表示该函数的参数不是对象；</li>\n<li>在验证null时，一定要使用　=== ，因为 ==无法分别null 和　undefined</li>\n</ul>\n<h2 id=\"框架（vue-react）\"><a href=\"#框架（vue-react）\" class=\"headerlink\" title=\"框架（vue/react）\"></a>框架（vue/react）</h2><h3 id=\"MVVM-（Model-View-ViewModel）优点：\"><a href=\"#MVVM-（Model-View-ViewModel）优点：\" class=\"headerlink\" title=\"MVVM （Model-View-ViewModel）优点：\"></a>MVVM （Model-View-ViewModel）优点：</h3><ul>\n<li>低耦合：视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>\n<li>可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。</li>\n<li>独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xaml代码。</li>\n<li>可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</li>\n</ul>\n<h3 id=\"react-和-vue-有哪些不同？谈谈你的看法\"><a href=\"#react-和-vue-有哪些不同？谈谈你的看法\" class=\"headerlink\" title=\"react 和 vue 有哪些不同？谈谈你的看法\"></a>react 和 vue 有哪些不同？谈谈你的看法</h3><ul>\n<li>两者都采用了 virtual dom 的方式，性能都很好</li>\n<li>ui 上都采用组件化的写法，开发效率很高。</li>\n<li>vue 采用双向数据绑定， react 是单项数据绑定。当工程规模比较大时，双向数据绑定会很难维护</li>\n<li>vue 适合不会持续的，小型的 web 应用，使用 vue.js 能带来短期内较高的开发效率， 否则采用 react。</li>\n</ul>\n<h3 id=\"Vue-生命周期\"><a href=\"#Vue-生命周期\" class=\"headerlink\" title=\"Vue 生命周期\"></a>Vue 生命周期</h3><p>生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。</p>\n<ul>\n<li>beforeCreate()<br>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</li>\n<li>created()<br>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据</li>\n<li>beforeMounted()<br>在挂载开始之前被调用</li>\n<li>mounted()<br>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</li>\n<li>beforeUpdated()<br>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</li>\n<li>updated()<br>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</li>\n<li>beforeDestroy()<br>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</li>\n<li>destroyed()<br>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>\n</ul>"},{"title":"vue-router","date":"2019-10-09T00:40:19.000Z","_content":"\nvue-router 学习，内容来自[vue-router](https://router.vuejs.org/zh/)\n<!-- more -->\n\n# 简单的 vue-router 实例\n```\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n```\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount('#app')\n\n// 现在，应用已经启动了！\n```\n```\n// Home.vue\nexport default {\n  computed: {\n    username() {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack() {\n      window.history.length > 1 ? this.$router.go(-1) : this.$router.push('/')\n    }\n  }\n}\n```\n\n# 动态路由配置\n## 动态路径参数\n```\nconst router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n多段路由参数：\n\n| 模式 | 匹配路径 | $route.params |\n| ------ | ------ | ------- |\n| /user/:username | /user/evan | { username: 'evan' } |\n| /user/:username/post/:post_id | /user/evan/post/123 | { username: 'evan', post_id: '123' } |\n\n## 响应路由参数的变化\n提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，**原来的组件实例会被复用**。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。**不过，这也意味着组件的生命周期钩子不会再被调用**。\n复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) ```$route``` 对象：\n```\nconst User = {\n  template: '...',\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n```\n或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫：\n```\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n\n## 捕获所有路由或 404 Not found 路由\n常规参数只会匹配被 ```/``` 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (```*```)：\n```\n{\n  // 会匹配所有路径\n  path: '*'\n}\n{\n  // 会匹配以 `/user-` 开头的任意路径\n  path: '/user-*'\n}\n```\n当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 ```{ path: '*' }``` 通常用于客户端 404 错误。\n当使用一个通配符时，```$route.params``` 内会自动添加一个名为 ```pathMatch``` 参数。它包含了 URL 通过通配符被匹配的部分：\n```\n// 给出一个路由 { path: '/user-*' }\nthis.$router.push('/user-admin')\nthis.$route.params.pathMatch // 'admin'\n// 给出一个路由 { path: '*' }\nthis.$router.push('/non-existing')\nthis.$route.params.pathMatch // '/non-existing'\n```\n\n## 高级匹配模式\n[高级匹配模式](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E9%AB%98%E7%BA%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F)\n\n## 匹配优先级\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n\n# 嵌套路由\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: 'profile',\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: 'posts',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n**要注意，以 ```/``` 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。**\n\n# 编程式的导航\n除了使用 ```<router-link>``` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n## ```router.push(location, onComplete?, onAbort?)```\n**注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。**\n点击 ```<router-link :to=\"...\">``` 等同于调用 ```router.push(...)```。\n\n| 声明式 | 编程式 |\n| ------ | ------ |\n| ```<router-link :to=\"...\">``` | ```<router-link :to=\"...\">``` |\n\n```\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n**注意：如果提供了 ```path```，```params``` 会被忽略，上述例子中的 ```query``` 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 ```name``` 或手写完整的带有参数的 ```path：```**\n```\nconst userId = '123'\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n## ```router.replace(location, onComplete?, onAbort?)```\n跟 ```router.push``` 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n\n| 声明式 | 编程式 |\n| ------ | ------ |\n| ```<router-link :to=\"...\" replace>``` | ```router.replace(...)``` |\n\n## ```router.go(n)```\n这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 ```window.history.go(n)```。\n```\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n# 命名路由\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n\n# 命名视图\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 ```sidebar``` (侧导航) 和 ```main``` (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 ```router-view``` 没有设置名字，那么默认为 ```default```。\n```\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n```\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n```\n\n## 嵌套命名视图\n```\n/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings                      |                  | UserSettings                 |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------>  | | Nav | UserProfile        | |\n| |     +-------------------------+ |                  | |     +--------------------+ |\n| |     |                         | |                  | |     | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\n```\n* ```Nav``` 只是一个常规组件。\n* ```UserSettings``` 是一个视图组件。\n* ```UserEmailsSubscriptions```、```UserProfile```、```UserProfilePreview``` 是嵌套的视图组件。\n\n```\n<!-- UserSettings.vue -->\n<div>\n  <h1>User Settings</h1>\n  <NavBar/>\n  <router-view/>\n  <router-view name=\"helper\"/>\n</div>\n```\n```\n{\n  path: '/settings',\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n```\n\n# 重定向\n重定向也是通过 ```routes``` 配置来完成，下面例子是从 ```/a``` 重定向到 ```/b```：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b' }\n  ]\n})\n```\n重定向的目标也可以是一个命名的路由：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: { name: 'foo' }}\n  ]\n})\n```\n甚至是一个方法，动态返回重定向目标：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n```\n\n# 别名\n“重定向”的意思是，当用户访问 ```/a```时，URL 将会被替换成 ```/b```，然后匹配路由为 ```/b```，那么“别名”又是什么呢？\n\n**```/a``` 的别名是 ```/b```，意味着，当用户访问 ```/b``` 时，URL 会保持为 ```/b```，但是路由匹配则为 ```/a```，就像用户访问 ```/a``` 一样。**\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', component: A, alias: '/b' }\n  ]\n})\n```","source":"_posts/vue-router.md","raw":"---\ntitle: vue-router\ndate: 2019-10-09 08:40:19\ntags: vue\ncategories: JS\n---\n\nvue-router 学习，内容来自[vue-router](https://router.vuejs.org/zh/)\n<!-- more -->\n\n# 简单的 vue-router 实例\n```\n<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- 使用 router-link 组件来导航. -->\n    <!-- 通过传入 `to` 属性指定链接. -->\n    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->\n    <router-link to=\"/foo\">Go to Foo</router-link>\n    <router-link to=\"/bar\">Go to Bar</router-link>\n  </p>\n  <!-- 路由出口 -->\n  <!-- 路由匹配到的组件将渲染在这里 -->\n  <router-view></router-view>\n</div>\n```\n```\n// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: '<div>foo</div>' }\nconst Bar = { template: '<div>bar</div>' }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中\"component\" 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: '/foo', component: Foo },\n  { path: '/bar', component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount('#app')\n\n// 现在，应用已经启动了！\n```\n```\n// Home.vue\nexport default {\n  computed: {\n    username() {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack() {\n      window.history.length > 1 ? this.$router.go(-1) : this.$router.push('/')\n    }\n  }\n}\n```\n\n# 动态路由配置\n## 动态路径参数\n```\nconst router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: '/user/:id', component: User }\n  ]\n})\n```\n多段路由参数：\n\n| 模式 | 匹配路径 | $route.params |\n| ------ | ------ | ------- |\n| /user/:username | /user/evan | { username: 'evan' } |\n| /user/:username/post/:post_id | /user/evan/post/123 | { username: 'evan', post_id: '123' } |\n\n## 响应路由参数的变化\n提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，**原来的组件实例会被复用**。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。**不过，这也意味着组件的生命周期钩子不会再被调用**。\n复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) ```$route``` 对象：\n```\nconst User = {\n  template: '...',\n  watch: {\n    '$route' (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n```\n或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫：\n```\nconst User = {\n  template: '...',\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don't forget to call next()\n  }\n}\n```\n\n## 捕获所有路由或 404 Not found 路由\n常规参数只会匹配被 ```/``` 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (```*```)：\n```\n{\n  // 会匹配所有路径\n  path: '*'\n}\n{\n  // 会匹配以 `/user-` 开头的任意路径\n  path: '/user-*'\n}\n```\n当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 ```{ path: '*' }``` 通常用于客户端 404 错误。\n当使用一个通配符时，```$route.params``` 内会自动添加一个名为 ```pathMatch``` 参数。它包含了 URL 通过通配符被匹配的部分：\n```\n// 给出一个路由 { path: '/user-*' }\nthis.$router.push('/user-admin')\nthis.$route.params.pathMatch // 'admin'\n// 给出一个路由 { path: '*' }\nthis.$router.push('/non-existing')\nthis.$route.params.pathMatch // '/non-existing'\n```\n\n## 高级匹配模式\n[高级匹配模式](https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E9%AB%98%E7%BA%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F)\n\n## 匹配优先级\n有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。\n\n# 嵌套路由\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/user/:id', component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 <router-view> 中\n          path: 'profile',\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 <router-view> 中\n          path: 'posts',\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n```\n**要注意，以 ```/``` 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。**\n\n# 编程式的导航\n除了使用 ```<router-link>``` 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。\n## ```router.push(location, onComplete?, onAbort?)```\n**注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。**\n点击 ```<router-link :to=\"...\">``` 等同于调用 ```router.push(...)```。\n\n| 声明式 | 编程式 |\n| ------ | ------ |\n| ```<router-link :to=\"...\">``` | ```<router-link :to=\"...\">``` |\n\n```\n// 字符串\nrouter.push('home')\n\n// 对象\nrouter.push({ path: 'home' })\n\n// 命名的路由\nrouter.push({ name: 'user', params: { userId: '123' }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n```\n**注意：如果提供了 ```path```，```params``` 会被忽略，上述例子中的 ```query``` 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 ```name``` 或手写完整的带有参数的 ```path：```**\n```\nconst userId = '123'\nrouter.push({ name: 'user', params: { userId }}) // -> /user/123\nrouter.push({ path: `/user/${userId}` }) // -> /user/123\n// 这里的 params 不生效\nrouter.push({ path: '/user', params: { userId }}) // -> /user\n```\n\n## ```router.replace(location, onComplete?, onAbort?)```\n跟 ```router.push``` 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n\n| 声明式 | 编程式 |\n| ------ | ------ |\n| ```<router-link :to=\"...\" replace>``` | ```router.replace(...)``` |\n\n## ```router.go(n)```\n这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 ```window.history.go(n)```。\n```\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n# 命名路由\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/user/:userId',\n      name: 'user',\n      component: User\n    }\n  ]\n})\n```\n\n# 命名视图\n有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 ```sidebar``` (侧导航) 和 ```main``` (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 ```router-view``` 没有设置名字，那么默认为 ```default```。\n```\n<router-view class=\"view one\"></router-view>\n<router-view class=\"view two\" name=\"a\"></router-view>\n<router-view class=\"view three\" name=\"b\"></router-view>\n```\n一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：\n```\nconst router = new VueRouter({\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n```\n\n## 嵌套命名视图\n```\n/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings                      |                  | UserSettings                 |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------>  | | Nav | UserProfile        | |\n| |     +-------------------------+ |                  | |     +--------------------+ |\n| |     |                         | |                  | |     | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\n```\n* ```Nav``` 只是一个常规组件。\n* ```UserSettings``` 是一个视图组件。\n* ```UserEmailsSubscriptions```、```UserProfile```、```UserProfilePreview``` 是嵌套的视图组件。\n\n```\n<!-- UserSettings.vue -->\n<div>\n  <h1>User Settings</h1>\n  <NavBar/>\n  <router-view/>\n  <router-view name=\"helper\"/>\n</div>\n```\n```\n{\n  path: '/settings',\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n```\n\n# 重定向\n重定向也是通过 ```routes``` 配置来完成，下面例子是从 ```/a``` 重定向到 ```/b```：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: '/b' }\n  ]\n})\n```\n重定向的目标也可以是一个命名的路由：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: { name: 'foo' }}\n  ]\n})\n```\n甚至是一个方法，动态返回重定向目标：\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', redirect: to => {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n```\n\n# 别名\n“重定向”的意思是，当用户访问 ```/a```时，URL 将会被替换成 ```/b```，然后匹配路由为 ```/b```，那么“别名”又是什么呢？\n\n**```/a``` 的别名是 ```/b```，意味着，当用户访问 ```/b``` 时，URL 会保持为 ```/b```，但是路由匹配则为 ```/a```，就像用户访问 ```/a``` 一样。**\n```\nconst router = new VueRouter({\n  routes: [\n    { path: '/a', component: A, alias: '/b' }\n  ]\n})\n```","slug":"vue-router","published":1,"updated":"2019-10-09T02:33:25.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx8c001iegqnbdvv48yr","content":"<p>vue-router 学习，内容来自<a href=\"https://router.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">vue-router</a><br><a id=\"more\"></a></p>\n<h1 id=\"简单的-vue-router-实例\"><a href=\"#简单的-vue-router-实例\" class=\"headerlink\" title=\"简单的 vue-router 实例\"></a>简单的 vue-router 实例</h1><pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;\n\n&lt;div id=&quot;app&quot;&gt;\n  &lt;h1&gt;Hello App!&lt;/h1&gt;\n  &lt;p&gt;\n    &lt;!-- 使用 router-link 组件来导航. --&gt;\n    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;\n    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;\n    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;\n    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;\n  &lt;/p&gt;\n  &lt;!-- 路由出口 --&gt;\n  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n</code></pre><pre><code>// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }\nconst Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: &#39;/foo&#39;, component: Foo },\n  { path: &#39;/bar&#39;, component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount(&#39;#app&#39;)\n\n// 现在，应用已经启动了！\n</code></pre><pre><code>// Home.vue\nexport default {\n  computed: {\n    username() {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack() {\n      window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push(&#39;/&#39;)\n    }\n  }\n}\n</code></pre><h1 id=\"动态路由配置\"><a href=\"#动态路由配置\" class=\"headerlink\" title=\"动态路由配置\"></a>动态路由配置</h1><h2 id=\"动态路径参数\"><a href=\"#动态路径参数\" class=\"headerlink\" title=\"动态路径参数\"></a>动态路径参数</h2><pre><code>const router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: &#39;/user/:id&#39;, component: User }\n  ]\n})\n</code></pre><p>多段路由参数：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td>{ username: ‘evan’ }</td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td>{ username: ‘evan’, post_id: ‘123’ }</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应路由参数的变化\"><a href=\"#响应路由参数的变化\" class=\"headerlink\" title=\"响应路由参数的变化\"></a>响应路由参数的变化</h2><p>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。<br>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) <code>$route</code> 对象：</p>\n<pre><code>const User = {\n  template: &#39;...&#39;,\n  watch: {\n    &#39;$route&#39; (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n</code></pre><p>或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫：</p>\n<pre><code>const User = {\n  template: &#39;...&#39;,\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don&#39;t forget to call next()\n  }\n}\n</code></pre><h2 id=\"捕获所有路由或-404-Not-found-路由\"><a href=\"#捕获所有路由或-404-Not-found-路由\" class=\"headerlink\" title=\"捕获所有路由或 404 Not found 路由\"></a>捕获所有路由或 404 Not found 路由</h2><p>常规参数只会匹配被 <code>/</code> 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (<code>*</code>)：</p>\n<pre><code>{\n  // 会匹配所有路径\n  path: &#39;*&#39;\n}\n{\n  // 会匹配以 `/user-` 开头的任意路径\n  path: &#39;/user-*&#39;\n}\n</code></pre><p>当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 <code>{ path: &#39;*&#39; }</code> 通常用于客户端 404 错误。<br>当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过通配符被匹配的部分：</p>\n<pre><code>// 给出一个路由 { path: &#39;/user-*&#39; }\nthis.$router.push(&#39;/user-admin&#39;)\nthis.$route.params.pathMatch // &#39;admin&#39;\n// 给出一个路由 { path: &#39;*&#39; }\nthis.$router.push(&#39;/non-existing&#39;)\nthis.$route.params.pathMatch // &#39;/non-existing&#39;\n</code></pre><h2 id=\"高级匹配模式\"><a href=\"#高级匹配模式\" class=\"headerlink\" title=\"高级匹配模式\"></a>高级匹配模式</h2><p><a href=\"https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E9%AB%98%E7%BA%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">高级匹配模式</a></p>\n<h2 id=\"匹配优先级\"><a href=\"#匹配优先级\" class=\"headerlink\" title=\"匹配优先级\"></a>匹配优先级</h2><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h1 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h1><pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/user/:id&#39;, component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中\n          path: &#39;profile&#39;,\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中\n          path: &#39;posts&#39;,\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n</code></pre><p><strong>要注意，以 <code>/</code> 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</strong></p>\n<h1 id=\"编程式的导航\"><a href=\"#编程式的导航\" class=\"headerlink\" title=\"编程式的导航\"></a>编程式的导航</h1><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>\n<h2 id=\"router-push-location-onComplete-onAbort\"><a href=\"#router-push-location-onComplete-onAbort\" class=\"headerlink\" title=\"router.push(location, onComplete?, onAbort?)\"></a><code>router.push(location, onComplete?, onAbort?)</code></h2><p><strong>注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。</strong><br>点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code>// 字符串\nrouter.push(&#39;home&#39;)\n\n// 对象\nrouter.push({ path: &#39;home&#39; })\n\n// 命名的路由\nrouter.push({ name: &#39;user&#39;, params: { userId: &#39;123&#39; }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})\n</code></pre><p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path：</code></strong></p>\n<pre><code>const userId = &#39;123&#39;\nrouter.push({ name: &#39;user&#39;, params: { userId }}) // -&gt; /user/123\nrouter.push({ path: `/user/${userId}` }) // -&gt; /user/123\n// 这里的 params 不生效\nrouter.push({ path: &#39;/user&#39;, params: { userId }}) // -&gt; /user\n</code></pre><h2 id=\"router-replace-location-onComplete-onAbort\"><a href=\"#router-replace-location-onComplete-onAbort\" class=\"headerlink\" title=\"router.replace(location, onComplete?, onAbort?)\"></a><code>router.replace(location, onComplete?, onAbort?)</code></h2><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>\n<td><code>router.replace(...)</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"router-go-n\"><a href=\"#router-go-n\" class=\"headerlink\" title=\"router.go(n)\"></a><code>router.go(n)</code></h2><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</p>\n<pre><code>// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n</code></pre><h1 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h1><pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/user/:userId&#39;,\n      name: &#39;user&#39;,\n      component: User\n    }\n  ]\n})\n</code></pre><h1 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h1><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>\n<pre><code>&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;\n</code></pre><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/&#39;,\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n</code></pre><h2 id=\"嵌套命名视图\"><a href=\"#嵌套命名视图\" class=\"headerlink\" title=\"嵌套命名视图\"></a>嵌套命名视图</h2><pre><code>/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings                      |                  | UserSettings                 |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |\n| |     +-------------------------+ |                  | |     +--------------------+ |\n| |     |                         | |                  | |     | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\n</code></pre><ul>\n<li><code>Nav</code> 只是一个常规组件。</li>\n<li><code>UserSettings</code> 是一个视图组件。</li>\n<li><code>UserEmailsSubscriptions</code>、<code>UserProfile</code>、<code>UserProfilePreview</code> 是嵌套的视图组件。</li>\n</ul>\n<pre><code>&lt;!-- UserSettings.vue --&gt;\n&lt;div&gt;\n  &lt;h1&gt;User Settings&lt;/h1&gt;\n  &lt;NavBar/&gt;\n  &lt;router-view/&gt;\n  &lt;router-view name=&quot;helper&quot;/&gt;\n&lt;/div&gt;\n</code></pre><pre><code>{\n  path: &#39;/settings&#39;,\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: &#39;emails&#39;,\n    component: UserEmailsSubscriptions\n  }, {\n    path: &#39;profile&#39;,\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n</code></pre><h1 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h1><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: &#39;/b&#39; }\n  ]\n})\n</code></pre><p>重定向的目标也可以是一个命名的路由：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: { name: &#39;foo&#39; }}\n  ]\n})\n</code></pre><p>甚至是一个方法，动态返回重定向目标：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: to =&gt; {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n</code></pre><h1 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h1><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>\n<p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; }\n  ]\n})\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>vue-router 学习，内容来自<a href=\"https://router.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">vue-router</a><br>","more":"</p>\n<h1 id=\"简单的-vue-router-实例\"><a href=\"#简单的-vue-router-实例\" class=\"headerlink\" title=\"简单的 vue-router 实例\"></a>简单的 vue-router 实例</h1><pre><code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;&gt;&lt;/script&gt;\n\n&lt;div id=&quot;app&quot;&gt;\n  &lt;h1&gt;Hello App!&lt;/h1&gt;\n  &lt;p&gt;\n    &lt;!-- 使用 router-link 组件来导航. --&gt;\n    &lt;!-- 通过传入 `to` 属性指定链接. --&gt;\n    &lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;\n    &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;\n    &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;\n  &lt;/p&gt;\n  &lt;!-- 路由出口 --&gt;\n  &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;\n  &lt;router-view&gt;&lt;/router-view&gt;\n&lt;/div&gt;\n</code></pre><pre><code>// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)\n\n// 1. 定义 (路由) 组件。\n// 可以从其他文件 import 进来\nconst Foo = { template: &#39;&lt;div&gt;foo&lt;/div&gt;&#39; }\nconst Bar = { template: &#39;&lt;div&gt;bar&lt;/div&gt;&#39; }\n\n// 2. 定义路由\n// 每个路由应该映射一个组件。 其中&quot;component&quot; 可以是\n// 通过 Vue.extend() 创建的组件构造器，\n// 或者，只是一个组件配置对象。\n// 我们晚点再讨论嵌套路由。\nconst routes = [\n  { path: &#39;/foo&#39;, component: Foo },\n  { path: &#39;/bar&#39;, component: Bar }\n]\n\n// 3. 创建 router 实例，然后传 `routes` 配置\n// 你还可以传别的配置参数, 不过先这么简单着吧。\nconst router = new VueRouter({\n  routes // (缩写) 相当于 routes: routes\n})\n\n// 4. 创建和挂载根实例。\n// 记得要通过 router 配置参数注入路由，\n// 从而让整个应用都有路由功能\nconst app = new Vue({\n  router\n}).$mount(&#39;#app&#39;)\n\n// 现在，应用已经启动了！\n</code></pre><pre><code>// Home.vue\nexport default {\n  computed: {\n    username() {\n      // 我们很快就会看到 `params` 是什么\n      return this.$route.params.username\n    }\n  },\n  methods: {\n    goBack() {\n      window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push(&#39;/&#39;)\n    }\n  }\n}\n</code></pre><h1 id=\"动态路由配置\"><a href=\"#动态路由配置\" class=\"headerlink\" title=\"动态路由配置\"></a>动态路由配置</h1><h2 id=\"动态路径参数\"><a href=\"#动态路径参数\" class=\"headerlink\" title=\"动态路径参数\"></a>动态路径参数</h2><pre><code>const router = new VueRouter({\n  routes: [\n    // 动态路径参数 以冒号开头\n    { path: &#39;/user/:id&#39;, component: User }\n  ]\n})\n</code></pre><p>多段路由参数：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>匹配路径</th>\n<th>$route.params</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/user/:username</td>\n<td>/user/evan</td>\n<td>{ username: ‘evan’ }</td>\n</tr>\n<tr>\n<td>/user/:username/post/:post_id</td>\n<td>/user/evan/post/123</td>\n<td>{ username: ‘evan’, post_id: ‘123’ }</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"响应路由参数的变化\"><a href=\"#响应路由参数的变化\" class=\"headerlink\" title=\"响应路由参数的变化\"></a>响应路由参数的变化</h2><p>提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。<br>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) <code>$route</code> 对象：</p>\n<pre><code>const User = {\n  template: &#39;...&#39;,\n  watch: {\n    &#39;$route&#39; (to, from) {\n      // 对路由变化作出响应...\n    }\n  }\n}\n</code></pre><p>或者使用 2.2 中引入的 beforeRouteUpdate 导航守卫：</p>\n<pre><code>const User = {\n  template: &#39;...&#39;,\n  beforeRouteUpdate (to, from, next) {\n    // react to route changes...\n    // don&#39;t forget to call next()\n  }\n}\n</code></pre><h2 id=\"捕获所有路由或-404-Not-found-路由\"><a href=\"#捕获所有路由或-404-Not-found-路由\" class=\"headerlink\" title=\"捕获所有路由或 404 Not found 路由\"></a>捕获所有路由或 404 Not found 路由</h2><p>常规参数只会匹配被 <code>/</code> 分隔的 URL 片段中的字符。如果想匹配任意路径，我们可以使用通配符 (<code>*</code>)：</p>\n<pre><code>{\n  // 会匹配所有路径\n  path: &#39;*&#39;\n}\n{\n  // 会匹配以 `/user-` 开头的任意路径\n  path: &#39;/user-*&#39;\n}\n</code></pre><p>当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后。路由 <code>{ path: &#39;*&#39; }</code> 通常用于客户端 404 错误。<br>当使用一个通配符时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过通配符被匹配的部分：</p>\n<pre><code>// 给出一个路由 { path: &#39;/user-*&#39; }\nthis.$router.push(&#39;/user-admin&#39;)\nthis.$route.params.pathMatch // &#39;admin&#39;\n// 给出一个路由 { path: &#39;*&#39; }\nthis.$router.push(&#39;/non-existing&#39;)\nthis.$route.params.pathMatch // &#39;/non-existing&#39;\n</code></pre><h2 id=\"高级匹配模式\"><a href=\"#高级匹配模式\" class=\"headerlink\" title=\"高级匹配模式\"></a>高级匹配模式</h2><p><a href=\"https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E9%AB%98%E7%BA%A7%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F\" target=\"_blank\" rel=\"noopener\">高级匹配模式</a></p>\n<h2 id=\"匹配优先级\"><a href=\"#匹配优先级\" class=\"headerlink\" title=\"匹配优先级\"></a>匹配优先级</h2><p>有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序：谁先定义的，谁的优先级就最高。</p>\n<h1 id=\"嵌套路由\"><a href=\"#嵌套路由\" class=\"headerlink\" title=\"嵌套路由\"></a>嵌套路由</h1><pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/user/:id&#39;, component: User,\n      children: [\n        {\n          // 当 /user/:id/profile 匹配成功，\n          // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中\n          path: &#39;profile&#39;,\n          component: UserProfile\n        },\n        {\n          // 当 /user/:id/posts 匹配成功\n          // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中\n          path: &#39;posts&#39;,\n          component: UserPosts\n        }\n      ]\n    }\n  ]\n})\n</code></pre><p><strong>要注意，以 <code>/</code> 开头的嵌套路径会被当作根路径。 这让你充分的使用嵌套组件而无须设置嵌套的路径。</strong></p>\n<h1 id=\"编程式的导航\"><a href=\"#编程式的导航\" class=\"headerlink\" title=\"编程式的导航\"></a>编程式的导航</h1><p>除了使用 <code>&lt;router-link&gt;</code> 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。</p>\n<h2 id=\"router-push-location-onComplete-onAbort\"><a href=\"#router-push-location-onComplete-onAbort\" class=\"headerlink\" title=\"router.push(location, onComplete?, onAbort?)\"></a><code>router.push(location, onComplete?, onAbort?)</code></h2><p><strong>注意：在 Vue 实例内部，你可以通过 $router 访问路由实例。因此你可以调用 this.$router.push。</strong><br>点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code>。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>\n</tr>\n</tbody>\n</table>\n<pre><code>// 字符串\nrouter.push(&#39;home&#39;)\n\n// 对象\nrouter.push({ path: &#39;home&#39; })\n\n// 命名的路由\nrouter.push({ name: &#39;user&#39;, params: { userId: &#39;123&#39; }})\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: &#39;register&#39;, query: { plan: &#39;private&#39; }})\n</code></pre><p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path：</code></strong></p>\n<pre><code>const userId = &#39;123&#39;\nrouter.push({ name: &#39;user&#39;, params: { userId }}) // -&gt; /user/123\nrouter.push({ path: `/user/${userId}` }) // -&gt; /user/123\n// 这里的 params 不生效\nrouter.push({ path: &#39;/user&#39;, params: { userId }}) // -&gt; /user\n</code></pre><h2 id=\"router-replace-location-onComplete-onAbort\"><a href=\"#router-replace-location-onComplete-onAbort\" class=\"headerlink\" title=\"router.replace(location, onComplete?, onAbort?)\"></a><code>router.replace(location, onComplete?, onAbort?)</code></h2><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>\n<table>\n<thead>\n<tr>\n<th>声明式</th>\n<th>编程式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>\n<td><code>router.replace(...)</code></td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"router-go-n\"><a href=\"#router-go-n\" class=\"headerlink\" title=\"router.go(n)\"></a><code>router.go(n)</code></h2><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</p>\n<pre><code>// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n\n// 前进 3 步记录\nrouter.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n</code></pre><h1 id=\"命名路由\"><a href=\"#命名路由\" class=\"headerlink\" title=\"命名路由\"></a>命名路由</h1><pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/user/:userId&#39;,\n      name: &#39;user&#39;,\n      component: User\n    }\n  ]\n})\n</code></pre><h1 id=\"命名视图\"><a href=\"#命名视图\" class=\"headerlink\" title=\"命名视图\"></a>命名视图</h1><p>有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code> (侧导航) 和 <code>main</code> (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>\n<pre><code>&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;\n&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;\n</code></pre><p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置 (带上 s)：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    {\n      path: &#39;/&#39;,\n      components: {\n        default: Foo,\n        a: Bar,\n        b: Baz\n      }\n    }\n  ]\n})\n</code></pre><h2 id=\"嵌套命名视图\"><a href=\"#嵌套命名视图\" class=\"headerlink\" title=\"嵌套命名视图\"></a>嵌套命名视图</h2><pre><code>/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings                      |                  | UserSettings                 |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------&gt;  | | Nav | UserProfile        | |\n| |     +-------------------------+ |                  | |     +--------------------+ |\n| |     |                         | |                  | |     | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\n</code></pre><ul>\n<li><code>Nav</code> 只是一个常规组件。</li>\n<li><code>UserSettings</code> 是一个视图组件。</li>\n<li><code>UserEmailsSubscriptions</code>、<code>UserProfile</code>、<code>UserProfilePreview</code> 是嵌套的视图组件。</li>\n</ul>\n<pre><code>&lt;!-- UserSettings.vue --&gt;\n&lt;div&gt;\n  &lt;h1&gt;User Settings&lt;/h1&gt;\n  &lt;NavBar/&gt;\n  &lt;router-view/&gt;\n  &lt;router-view name=&quot;helper&quot;/&gt;\n&lt;/div&gt;\n</code></pre><pre><code>{\n  path: &#39;/settings&#39;,\n  // 你也可以在顶级路由就配置命名视图\n  component: UserSettings,\n  children: [{\n    path: &#39;emails&#39;,\n    component: UserEmailsSubscriptions\n  }, {\n    path: &#39;profile&#39;,\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n</code></pre><h1 id=\"重定向\"><a href=\"#重定向\" class=\"headerlink\" title=\"重定向\"></a>重定向</h1><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: &#39;/b&#39; }\n  ]\n})\n</code></pre><p>重定向的目标也可以是一个命名的路由：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: { name: &#39;foo&#39; }}\n  ]\n})\n</code></pre><p>甚至是一个方法，动态返回重定向目标：</p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, redirect: to =&gt; {\n      // 方法接收 目标路由 作为参数\n      // return 重定向的 字符串路径/路径对象\n    }}\n  ]\n})\n</code></pre><h1 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h1><p>“重定向”的意思是，当用户访问 <code>/a</code>时，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>\n<p><strong><code>/a</code> 的别名是 <code>/b</code>，意味着，当用户访问 <code>/b</code> 时，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</strong></p>\n<pre><code>const router = new VueRouter({\n  routes: [\n    { path: &#39;/a&#39;, component: A, alias: &#39;/b&#39; }\n  ]\n})\n</code></pre>"},{"title":"vue学习","date":"2019-05-29T01:20:46.000Z","_content":"\n> 记录 Vue 的学习, Vue -渐进式JavaScript框架\n\n<!-- more -->\n\n## MVC 与 MVVM 的区别\nMVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。\nMVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。\n在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。\nMVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。\n\n## Vue 实例\n<b>注意点：</b>\n1. 需要先在data中声明数据，再使用数据\n2. 可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg\n\n## 双向数据绑定\n将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定\n\n## 动态添加数据的注意点\n只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式\n可以通过以下方式实现动态添加数据的响应式\n1. Vue.set(object, key, value) - 适用于添加单个属性\n2. Object.assign() - 适用于添加多个属性\n\n## 异步 DOM 更新\n* 说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM\n* 优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要\n* 如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})\n\n## Vue 指令\nVue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM\n* v-text: 更新 DOM 对象的 textContent\n* v-html: 更新 DOM 对象的 innerHTML\n* v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM\n* v-on: 绑定事件， 绑定的事件定义在 methods 中\n* 事件修饰符\n    * .stop 阻止冒泡，调用 event.stopPropagation()\n    * .prevent 阻止默认行为，调用 event.preventDefault()\n    * .capture 添加事件侦听器时使用事件捕获模式\n    * .self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件\n    * .once 事件只触发一次\n* v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据\n* v-for: 基于源数据多次渲染元素或模板块\n* key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n## 样式处理 -class 和 style\n使用方式：v-bind:class=\"expression\" or :class=\"expression\"， 表达式的类型：字符串、数组、对象（重点）\n\n* v-if 和 v-show\n    * v-if: 根据表达式的值的真假条件，销毁或重建元素\n    * v-show: 根据表达式之真假值，切换元素的 display CSS 属性\n\n* 提升性能: v-pre\nvue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译\n\n* 提升性能：v-once\nvue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n## 过滤器 filter\n文本数据格式化\n* 全局过滤器\n通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定\n* 局部过滤器\n局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用\n\n## 按键值修饰符\n在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=\"submit\"\n\n## 监视数据变化 - watch\nwatch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作\n\n## 实例生命周期\n所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。\n实例生命周期也叫做：组件生命周期\n\n### 生命周期介绍\n一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期\n生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！\n注意：\n* Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可\n* 钩子函数的名称都是Vue中规定好的！\n\n### 钩子函数 - beforeCreate()\n在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用\n注意：此时，无法获取 data中的数据、methods中的方法\n\n### 钩子函数 - created()\n注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 [参考资料1](https://segmentfault.com/a/1190000008879966) [参考资料2](https://segmentfault.com/a/1190000008010666)\n\n### 钩子函数 - beforeMounted()\n在挂载开始之前被调用\n\n### 钩子函数 - mounted()\n此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作\n\n### 钩子函数 - beforeUpdated()\n数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的\n\n### 钩子函数 - updated()\n组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n\n### 钩子函数 - beforeDestroy()\n实例销毁之前调用。在这一步，实例仍然完全可用。\n使用场景：实例销毁之前，执行清理任务，比如：清除定时器等\n\n### 钩子函数 - destroyed()\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n## axios\n* Promise based HTTP client for the browser and node.js\n    * 以Promise为基础的HTTP客户端，适用于：浏览器和node.js\n    * 封装ajax，用来发送请求，异步获取数据\n* 安装：npm i -S axios\n* 拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数\n\n## 自定义组件\n* 作用：进行DOM操作\n* 使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点\n* 两种指令：1 全局指令 2 局部指令\n\n## 组件\n> 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树\n\n创建组件的两种方式：1 全局组件 2 局部组件\n\n### 全局组件\n* 说明：全局组件在所有的vue实例中都可以使用\n* 注意：先注册组件，再初始化根实例\n* extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n### 局部组件\n局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用\n\n### is特性\n> 在某些特定的标签中只能存在指定表恰 如ul > li 如果要浏览器正常解析则需要使用is\n\n## 组件通讯\n### 父组件到子组件\n通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同\n注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效\n\n### 子组件到父组件\n父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=\"fn\"）\n步骤：\n1. 在父组件中定义方法 parentFn\n2. 在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=\"父组件中的方法\" ==> @pfn=\"parentFn\"\n3. 子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)\n\n### 非父子组件通讯\n> 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线\n$on()：绑定自定义事件\n\n### 内容分发\n通过<slot></slot> 标签指定内容展示区域\n\n### 获取组件（或元素） - refs\nvm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取\n注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods\n\n## SPA -单页应用程序\n### SPA： Single Page Application\n> 单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。\n\n* 单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中\n* 传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面\n优势:\n* 减少了请求体积，加快页面响应速度，降低了对服务器的压力\n* 更好的用户体验，让用户在web app感受native app的流畅\n实现思路和技术点\n1. ajax\n2. 锚点的使用（window.location.hash #）\n3. hashchange 事件 window.addEventListener(\"hashchange\",function () {})\n4. 监听锚点值变化的事件，根据不同的锚点值，请求相应的数据\n5. 原本用作页面内部进行跳转，定位并展示相应的内容\n\n### 路由\n路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则\nvue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容\n基本使用 安装：npm i -S vue-router\n重定向 { path: '/', redirect: '/home' }\n路由其他配置 \n* 路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类\n* 匹配路由模式 配置：mode\n路由参数\n* 说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理\n* 语法：/user/:id\n* 使用：当匹配到一个路由时，参数值会被设置到 this.$route.params\n* 其他：可以通过 $route.query 获取到 URL 中的查询参数 等\n嵌套路由 - 子路由\n* 路由是可以嵌套的，即：路由中又包含子路由\n* 规则：父组件中包含 router-view，在路由规则中使用 children 配置\n\n## 前端模块化\n为什么需要模块化?\n1. 最开始的js就是为了实现客户端验证以及一些简单的效果\n2. 后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高\n3. 旧版本的js中没有提供与模块（module）相关的内容\n### 模块的概念\n* 在js中，一个模块就是实现特定功能的文件（js文件）\n* 遵循模块的机制，想要什么功能就加载什么模块\n* 模块化开发需要遵循规范\n\n### 模块化解决的问题\n1. 命名冲突\n2. 文件依赖（加载文件）\n3. 模块的复用\n4. 统一规范和开发方式\n\n### JS实现模块化的规范\nAMD 的使用\n> Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行\n\n1. 定义模块\n```\n    // 语法:define(name, dependencies?, factory);\n    // name表示：当前模块的名称，是一个字符串 可有可无\n    // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写\n    // factory表示：当前模块要完成的一些功能，是一个函数\n    \n    // 定义对象模块\n    define({})\n    // 定义方法模块\n    define(function() {\n      return {}\n    })\n    // 定义带有依赖项的模块\n    define(['js/a'], function() {})\n```\n\n2. 加载模块\n```\n    // - 注意：require的第一个参数必须是数组\n\n    // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应\n    require(['a', 'js/b'], function(a, b) {\n      // 使用模块a 和 模块b 中的代码\n    })\n```\n\n3. 路径查找配置\n    * requirejs 默认使用 baseUrl+paths 的路径解析方式\n    * 可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://\n```\n    // 配置示例\n    // 注意配置应当在使用之前\n    require.config({\n      baseUrl: './js' // 配置基础路径为：当前目录下的js目录\n    })\n    require(['a'])    // 查找 基础路径下的 ./js/a.js\n\n    // 简化加载模块路径\n    require.config({\n      baseUrl: './js',\n      // 配置一次即可，直接通过路径名称（template || jquery）加载模块\n      paths: {\n        template: 'assets/artTemplate/template-native',\n        jquery: 'assets/jquery/jquery.min'\n      }\n    })\n    // 加载jquery template模块\n    require(['jquery', 'template'])\n```\n\n4. 非模块化和依赖项支持\n    * 添加模块的依赖模块，保证加载顺序（deps）\n    * 将非模块化模块，转化为模块化（exports）\n```\n    // 示例\n    require.config({\n      baseUrl: './js',\n      paths: {\n        // 配置路径\n        noModule: 'assets/demo/noModule'\n      },\n      // 配置不符合规范的模块项\n      shim: {\n        // 模块名称\n        noModule: {\n          deps: [],         // 依赖项\n          exports: 'sayHi'  // 导出模块中存在的函数或变量\n        }\n      }\n    });\n\n    // 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块\n    // 定义 这个模块名称与paths中的名称相同\n    define('moduleA', function() {})\n    // 导入\n    require.config({\n      paths: {\n        // 此处的模块名：moduleA\n        moduleA: 'assets/demo/moduleA'\n      }\n    })\n```\n\n5. 路径加载规则\n路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找\n```\n    <!-- \n      设置data-main属性\n      1 data-main属性指定的文件也会同时被加载\n      2 用于指定查找其他模块的基础路径\n    -->\n    <script src=\"js/require.js\" data-main=\"js/main\"></script>\n```","source":"_posts/vue学习.md","raw":"---\ntitle: vue学习\ndate: 2019-05-29 09:20:46\ntags: vue\ncategories: JS\n---\n\n> 记录 Vue 的学习, Vue -渐进式JavaScript框架\n\n<!-- more -->\n\n## MVC 与 MVVM 的区别\nMVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。\nMVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。\n在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。\nMVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。\n\n## Vue 实例\n<b>注意点：</b>\n1. 需要先在data中声明数据，再使用数据\n2. 可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg\n\n## 双向数据绑定\n将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定\n\n## 动态添加数据的注意点\n只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式\n可以通过以下方式实现动态添加数据的响应式\n1. Vue.set(object, key, value) - 适用于添加单个属性\n2. Object.assign() - 适用于添加多个属性\n\n## 异步 DOM 更新\n* 说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM\n* 优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要\n* 如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})\n\n## Vue 指令\nVue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM\n* v-text: 更新 DOM 对象的 textContent\n* v-html: 更新 DOM 对象的 innerHTML\n* v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM\n* v-on: 绑定事件， 绑定的事件定义在 methods 中\n* 事件修饰符\n    * .stop 阻止冒泡，调用 event.stopPropagation()\n    * .prevent 阻止默认行为，调用 event.preventDefault()\n    * .capture 添加事件侦听器时使用事件捕获模式\n    * .self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件\n    * .once 事件只触发一次\n* v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据\n* v-for: 基于源数据多次渲染元素或模板块\n* key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。\n\n## 样式处理 -class 和 style\n使用方式：v-bind:class=\"expression\" or :class=\"expression\"， 表达式的类型：字符串、数组、对象（重点）\n\n* v-if 和 v-show\n    * v-if: 根据表达式的值的真假条件，销毁或重建元素\n    * v-show: 根据表达式之真假值，切换元素的 display CSS 属性\n\n* 提升性能: v-pre\nvue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译\n\n* 提升性能：v-once\nvue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。\n\n## 过滤器 filter\n文本数据格式化\n* 全局过滤器\n通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定\n* 局部过滤器\n局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用\n\n## 按键值修饰符\n在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=\"submit\"\n\n## 监视数据变化 - watch\nwatch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作\n\n## 实例生命周期\n所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。\n实例生命周期也叫做：组件生命周期\n\n### 生命周期介绍\n一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期\n生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！\n注意：\n* Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可\n* 钩子函数的名称都是Vue中规定好的！\n\n### 钩子函数 - beforeCreate()\n在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用\n注意：此时，无法获取 data中的数据、methods中的方法\n\n### 钩子函数 - created()\n注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 [参考资料1](https://segmentfault.com/a/1190000008879966) [参考资料2](https://segmentfault.com/a/1190000008010666)\n\n### 钩子函数 - beforeMounted()\n在挂载开始之前被调用\n\n### 钩子函数 - mounted()\n此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作\n\n### 钩子函数 - beforeUpdated()\n数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\n注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的\n\n### 钩子函数 - updated()\n组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。\n\n### 钩子函数 - beforeDestroy()\n实例销毁之前调用。在这一步，实例仍然完全可用。\n使用场景：实例销毁之前，执行清理任务，比如：清除定时器等\n\n### 钩子函数 - destroyed()\nVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\n\n## axios\n* Promise based HTTP client for the browser and node.js\n    * 以Promise为基础的HTTP客户端，适用于：浏览器和node.js\n    * 封装ajax，用来发送请求，异步获取数据\n* 安装：npm i -S axios\n* 拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数\n\n## 自定义组件\n* 作用：进行DOM操作\n* 使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点\n* 两种指令：1 全局指令 2 局部指令\n\n## 组件\n> 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树\n\n创建组件的两种方式：1 全局组件 2 局部组件\n\n### 全局组件\n* 说明：全局组件在所有的vue实例中都可以使用\n* 注意：先注册组件，再初始化根实例\n* extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n\n### 局部组件\n局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用\n\n### is特性\n> 在某些特定的标签中只能存在指定表恰 如ul > li 如果要浏览器正常解析则需要使用is\n\n## 组件通讯\n### 父组件到子组件\n通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同\n注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效\n\n### 子组件到父组件\n父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=\"fn\"）\n步骤：\n1. 在父组件中定义方法 parentFn\n2. 在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=\"父组件中的方法\" ==> @pfn=\"parentFn\"\n3. 子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)\n\n### 非父子组件通讯\n> 在简单的场景下，可以使用一个空的 Vue 实例作为事件总线\n$on()：绑定自定义事件\n\n### 内容分发\n通过<slot></slot> 标签指定内容展示区域\n\n### 获取组件（或元素） - refs\nvm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取\n注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods\n\n## SPA -单页应用程序\n### SPA： Single Page Application\n> 单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。\n\n* 单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中\n* 传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面\n优势:\n* 减少了请求体积，加快页面响应速度，降低了对服务器的压力\n* 更好的用户体验，让用户在web app感受native app的流畅\n实现思路和技术点\n1. ajax\n2. 锚点的使用（window.location.hash #）\n3. hashchange 事件 window.addEventListener(\"hashchange\",function () {})\n4. 监听锚点值变化的事件，根据不同的锚点值，请求相应的数据\n5. 原本用作页面内部进行跳转，定位并展示相应的内容\n\n### 路由\n路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则\nvue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容\n基本使用 安装：npm i -S vue-router\n重定向 { path: '/', redirect: '/home' }\n路由其他配置 \n* 路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类\n* 匹配路由模式 配置：mode\n路由参数\n* 说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理\n* 语法：/user/:id\n* 使用：当匹配到一个路由时，参数值会被设置到 this.$route.params\n* 其他：可以通过 $route.query 获取到 URL 中的查询参数 等\n嵌套路由 - 子路由\n* 路由是可以嵌套的，即：路由中又包含子路由\n* 规则：父组件中包含 router-view，在路由规则中使用 children 配置\n\n## 前端模块化\n为什么需要模块化?\n1. 最开始的js就是为了实现客户端验证以及一些简单的效果\n2. 后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高\n3. 旧版本的js中没有提供与模块（module）相关的内容\n### 模块的概念\n* 在js中，一个模块就是实现特定功能的文件（js文件）\n* 遵循模块的机制，想要什么功能就加载什么模块\n* 模块化开发需要遵循规范\n\n### 模块化解决的问题\n1. 命名冲突\n2. 文件依赖（加载文件）\n3. 模块的复用\n4. 统一规范和开发方式\n\n### JS实现模块化的规范\nAMD 的使用\n> Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行\n\n1. 定义模块\n```\n    // 语法:define(name, dependencies?, factory);\n    // name表示：当前模块的名称，是一个字符串 可有可无\n    // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写\n    // factory表示：当前模块要完成的一些功能，是一个函数\n    \n    // 定义对象模块\n    define({})\n    // 定义方法模块\n    define(function() {\n      return {}\n    })\n    // 定义带有依赖项的模块\n    define(['js/a'], function() {})\n```\n\n2. 加载模块\n```\n    // - 注意：require的第一个参数必须是数组\n\n    // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应\n    require(['a', 'js/b'], function(a, b) {\n      // 使用模块a 和 模块b 中的代码\n    })\n```\n\n3. 路径查找配置\n    * requirejs 默认使用 baseUrl+paths 的路径解析方式\n    * 可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://\n```\n    // 配置示例\n    // 注意配置应当在使用之前\n    require.config({\n      baseUrl: './js' // 配置基础路径为：当前目录下的js目录\n    })\n    require(['a'])    // 查找 基础路径下的 ./js/a.js\n\n    // 简化加载模块路径\n    require.config({\n      baseUrl: './js',\n      // 配置一次即可，直接通过路径名称（template || jquery）加载模块\n      paths: {\n        template: 'assets/artTemplate/template-native',\n        jquery: 'assets/jquery/jquery.min'\n      }\n    })\n    // 加载jquery template模块\n    require(['jquery', 'template'])\n```\n\n4. 非模块化和依赖项支持\n    * 添加模块的依赖模块，保证加载顺序（deps）\n    * 将非模块化模块，转化为模块化（exports）\n```\n    // 示例\n    require.config({\n      baseUrl: './js',\n      paths: {\n        // 配置路径\n        noModule: 'assets/demo/noModule'\n      },\n      // 配置不符合规范的模块项\n      shim: {\n        // 模块名称\n        noModule: {\n          deps: [],         // 依赖项\n          exports: 'sayHi'  // 导出模块中存在的函数或变量\n        }\n      }\n    });\n\n    // 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块\n    // 定义 这个模块名称与paths中的名称相同\n    define('moduleA', function() {})\n    // 导入\n    require.config({\n      paths: {\n        // 此处的模块名：moduleA\n        moduleA: 'assets/demo/moduleA'\n      }\n    })\n```\n\n5. 路径加载规则\n路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找\n```\n    <!-- \n      设置data-main属性\n      1 data-main属性指定的文件也会同时被加载\n      2 用于指定查找其他模块的基础路径\n    -->\n    <script src=\"js/require.js\" data-main=\"js/main\"></script>\n```","slug":"vue学习","published":1,"updated":"2019-09-18T09:03:19.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx8o001vegqnpb5g9dzh","content":"<blockquote>\n<p>记录 Vue 的学习, Vue -渐进式JavaScript框架</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"MVC-与-MVVM-的区别\"><a href=\"#MVC-与-MVVM-的区别\" class=\"headerlink\" title=\"MVC 与 MVVM 的区别\"></a>MVC 与 MVVM 的区别</h2><p>MVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。<br>MVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p>\n<h2 id=\"Vue-实例\"><a href=\"#Vue-实例\" class=\"headerlink\" title=\"Vue 实例\"></a>Vue 实例</h2><p><b>注意点：</b></p>\n<ol>\n<li>需要先在data中声明数据，再使用数据</li>\n<li>可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg</li>\n</ol>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><p>将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定</p>\n<h2 id=\"动态添加数据的注意点\"><a href=\"#动态添加数据的注意点\" class=\"headerlink\" title=\"动态添加数据的注意点\"></a>动态添加数据的注意点</h2><p>只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式<br>可以通过以下方式实现动态添加数据的响应式</p>\n<ol>\n<li>Vue.set(object, key, value) - 适用于添加单个属性</li>\n<li>Object.assign() - 适用于添加多个属性</li>\n</ol>\n<h2 id=\"异步-DOM-更新\"><a href=\"#异步-DOM-更新\" class=\"headerlink\" title=\"异步 DOM 更新\"></a>异步 DOM 更新</h2><ul>\n<li>说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</li>\n<li>优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要</li>\n<li>如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})</li>\n</ul>\n<h2 id=\"Vue-指令\"><a href=\"#Vue-指令\" class=\"headerlink\" title=\"Vue 指令\"></a>Vue 指令</h2><p>Vue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM</p>\n<ul>\n<li>v-text: 更新 DOM 对象的 textContent</li>\n<li>v-html: 更新 DOM 对象的 innerHTML</li>\n<li>v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>\n<li>v-on: 绑定事件， 绑定的事件定义在 methods 中</li>\n<li>事件修饰符<ul>\n<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>\n<li>.prevent 阻止默认行为，调用 event.preventDefault()</li>\n<li>.capture 添加事件侦听器时使用事件捕获模式</li>\n<li>.self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li>\n<li>.once 事件只触发一次</li>\n</ul>\n</li>\n<li>v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据</li>\n<li>v-for: 基于源数据多次渲染元素或模板块</li>\n<li>key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>\n</ul>\n<h2 id=\"样式处理-class-和-style\"><a href=\"#样式处理-class-和-style\" class=\"headerlink\" title=\"样式处理 -class 和 style\"></a>样式处理 -class 和 style</h2><p>使用方式：v-bind:class=”expression” or :class=”expression”， 表达式的类型：字符串、数组、对象（重点）</p>\n<ul>\n<li><p>v-if 和 v-show</p>\n<ul>\n<li>v-if: 根据表达式的值的真假条件，销毁或重建元素</li>\n<li>v-show: 根据表达式之真假值，切换元素的 display CSS 属性</li>\n</ul>\n</li>\n<li><p>提升性能: v-pre<br>vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译</p>\n</li>\n<li><p>提升性能：v-once<br>vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n</li>\n</ul>\n<h2 id=\"过滤器-filter\"><a href=\"#过滤器-filter\" class=\"headerlink\" title=\"过滤器 filter\"></a>过滤器 filter</h2><p>文本数据格式化</p>\n<ul>\n<li>全局过滤器<br>通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定</li>\n<li>局部过滤器<br>局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>\n</ul>\n<h2 id=\"按键值修饰符\"><a href=\"#按键值修饰符\" class=\"headerlink\" title=\"按键值修饰符\"></a>按键值修饰符</h2><p>在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=”submit”</p>\n<h2 id=\"监视数据变化-watch\"><a href=\"#监视数据变化-watch\" class=\"headerlink\" title=\"监视数据变化 - watch\"></a>监视数据变化 - watch</h2><p>watch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</p>\n<h2 id=\"实例生命周期\"><a href=\"#实例生命周期\" class=\"headerlink\" title=\"实例生命周期\"></a>实例生命周期</h2><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。<br>实例生命周期也叫做：组件生命周期</p>\n<h3 id=\"生命周期介绍\"><a href=\"#生命周期介绍\" class=\"headerlink\" title=\"生命周期介绍\"></a>生命周期介绍</h3><p>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期<br>生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！<br>注意：</p>\n<ul>\n<li>Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可</li>\n<li>钩子函数的名称都是Vue中规定好的！</li>\n</ul>\n<h3 id=\"钩子函数-beforeCreate\"><a href=\"#钩子函数-beforeCreate\" class=\"headerlink\" title=\"钩子函数 - beforeCreate()\"></a>钩子函数 - beforeCreate()</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</p>\n<h3 id=\"钩子函数-created\"><a href=\"#钩子函数-created\" class=\"headerlink\" title=\"钩子函数 - created()\"></a>钩子函数 - created()</h3><p>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 <a href=\"https://segmentfault.com/a/1190000008879966\" target=\"_blank\" rel=\"noopener\">参考资料1</a> <a href=\"https://segmentfault.com/a/1190000008010666\" target=\"_blank\" rel=\"noopener\">参考资料2</a></p>\n<h3 id=\"钩子函数-beforeMounted\"><a href=\"#钩子函数-beforeMounted\" class=\"headerlink\" title=\"钩子函数 - beforeMounted()\"></a>钩子函数 - beforeMounted()</h3><p>在挂载开始之前被调用</p>\n<h3 id=\"钩子函数-mounted\"><a href=\"#钩子函数-mounted\" class=\"headerlink\" title=\"钩子函数 - mounted()\"></a>钩子函数 - mounted()</h3><p>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</p>\n<h3 id=\"钩子函数-beforeUpdated\"><a href=\"#钩子函数-beforeUpdated\" class=\"headerlink\" title=\"钩子函数 - beforeUpdated()\"></a>钩子函数 - beforeUpdated()</h3><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</p>\n<h3 id=\"钩子函数-updated\"><a href=\"#钩子函数-updated\" class=\"headerlink\" title=\"钩子函数 - updated()\"></a>钩子函数 - updated()</h3><p>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</p>\n<h3 id=\"钩子函数-beforeDestroy\"><a href=\"#钩子函数-beforeDestroy\" class=\"headerlink\" title=\"钩子函数 - beforeDestroy()\"></a>钩子函数 - beforeDestroy()</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</p>\n<h3 id=\"钩子函数-destroyed\"><a href=\"#钩子函数-destroyed\" class=\"headerlink\" title=\"钩子函数 - destroyed()\"></a>钩子函数 - destroyed()</h3><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<h2 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h2><ul>\n<li>Promise based HTTP client for the browser and node.js<ul>\n<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>\n<li>封装ajax，用来发送请求，异步获取数据</li>\n</ul>\n</li>\n<li>安装：npm i -S axios</li>\n<li>拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数</li>\n</ul>\n<h2 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h2><ul>\n<li>作用：进行DOM操作</li>\n<li>使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点</li>\n<li>两种指令：1 全局指令 2 局部指令</li>\n</ul>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><blockquote>\n<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>\n</blockquote>\n<p>创建组件的两种方式：1 全局组件 2 局部组件</p>\n<h3 id=\"全局组件\"><a href=\"#全局组件\" class=\"headerlink\" title=\"全局组件\"></a>全局组件</h3><ul>\n<li>说明：全局组件在所有的vue实例中都可以使用</li>\n<li>注意：先注册组件，再初始化根实例</li>\n<li>extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>\n</ul>\n<h3 id=\"局部组件\"><a href=\"#局部组件\" class=\"headerlink\" title=\"局部组件\"></a>局部组件</h3><p>局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</p>\n<h3 id=\"is特性\"><a href=\"#is特性\" class=\"headerlink\" title=\"is特性\"></a>is特性</h3><blockquote>\n<p>在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is</p>\n</blockquote>\n<h2 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h2><h3 id=\"父组件到子组件\"><a href=\"#父组件到子组件\" class=\"headerlink\" title=\"父组件到子组件\"></a>父组件到子组件</h3><p>通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同<br>注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效</p>\n<h3 id=\"子组件到父组件\"><a href=\"#子组件到父组件\" class=\"headerlink\" title=\"子组件到父组件\"></a>子组件到父组件</h3><p>父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=”fn”）<br>步骤：</p>\n<ol>\n<li>在父组件中定义方法 parentFn</li>\n<li>在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=”父组件中的方法” ==&gt; @pfn=”parentFn”</li>\n<li>子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)</li>\n</ol>\n<h3 id=\"非父子组件通讯\"><a href=\"#非父子组件通讯\" class=\"headerlink\" title=\"非父子组件通讯\"></a>非父子组件通讯</h3><blockquote>\n<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线<br>$on()：绑定自定义事件</p>\n</blockquote>\n<h3 id=\"内容分发\"><a href=\"#内容分发\" class=\"headerlink\" title=\"内容分发\"></a>内容分发</h3><p>通过<slot></slot> 标签指定内容展示区域</p>\n<h3 id=\"获取组件（或元素）-refs\"><a href=\"#获取组件（或元素）-refs\" class=\"headerlink\" title=\"获取组件（或元素） - refs\"></a>获取组件（或元素） - refs</h3><p>vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取<br>注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods</p>\n<h2 id=\"SPA-单页应用程序\"><a href=\"#SPA-单页应用程序\" class=\"headerlink\" title=\"SPA -单页应用程序\"></a>SPA -单页应用程序</h2><h3 id=\"SPA：-Single-Page-Application\"><a href=\"#SPA：-Single-Page-Application\" class=\"headerlink\" title=\"SPA： Single Page Application\"></a>SPA： Single Page Application</h3><blockquote>\n<p>单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>\n</blockquote>\n<ul>\n<li>单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中</li>\n<li>传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面<br>优势:</li>\n<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>\n<li>更好的用户体验，让用户在web app感受native app的流畅<br>实现思路和技术点</li>\n</ul>\n<ol>\n<li>ajax</li>\n<li>锚点的使用（window.location.hash #）</li>\n<li>hashchange 事件 window.addEventListener(“hashchange”,function () {})</li>\n<li>监听锚点值变化的事件，根据不同的锚点值，请求相应的数据</li>\n<li>原本用作页面内部进行跳转，定位并展示相应的内容</li>\n</ol>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则<br>vue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容<br>基本使用 安装：npm i -S vue-router<br>重定向 { path: ‘/‘, redirect: ‘/home’ }<br>路由其他配置 </p>\n<ul>\n<li>路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类</li>\n<li>匹配路由模式 配置：mode<br>路由参数</li>\n<li>说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理</li>\n<li>语法：/user/:id</li>\n<li>使用：当匹配到一个路由时，参数值会被设置到 this.$route.params</li>\n<li>其他：可以通过 $route.query 获取到 URL 中的查询参数 等<br>嵌套路由 - 子路由</li>\n<li>路由是可以嵌套的，即：路由中又包含子路由</li>\n<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>\n</ul>\n<h2 id=\"前端模块化\"><a href=\"#前端模块化\" class=\"headerlink\" title=\"前端模块化\"></a>前端模块化</h2><p>为什么需要模块化?</p>\n<ol>\n<li>最开始的js就是为了实现客户端验证以及一些简单的效果</li>\n<li>后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高</li>\n<li>旧版本的js中没有提供与模块（module）相关的内容<h3 id=\"模块的概念\"><a href=\"#模块的概念\" class=\"headerlink\" title=\"模块的概念\"></a>模块的概念</h3></li>\n</ol>\n<ul>\n<li>在js中，一个模块就是实现特定功能的文件（js文件）</li>\n<li>遵循模块的机制，想要什么功能就加载什么模块</li>\n<li>模块化开发需要遵循规范</li>\n</ul>\n<h3 id=\"模块化解决的问题\"><a href=\"#模块化解决的问题\" class=\"headerlink\" title=\"模块化解决的问题\"></a>模块化解决的问题</h3><ol>\n<li>命名冲突</li>\n<li>文件依赖（加载文件）</li>\n<li>模块的复用</li>\n<li>统一规范和开发方式</li>\n</ol>\n<h3 id=\"JS实现模块化的规范\"><a href=\"#JS实现模块化的规范\" class=\"headerlink\" title=\"JS实现模块化的规范\"></a>JS实现模块化的规范</h3><p>AMD 的使用</p>\n<blockquote>\n<p>Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行</p>\n</blockquote>\n<ol>\n<li><p>定义模块</p>\n<pre><code> // 语法:define(name, dependencies?, factory);\n // name表示：当前模块的名称，是一个字符串 可有可无\n // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写\n // factory表示：当前模块要完成的一些功能，是一个函数\n\n // 定义对象模块\n define({})\n // 定义方法模块\n define(function() {\n   return {}\n })\n // 定义带有依赖项的模块\n define([&#39;js/a&#39;], function() {})\n</code></pre></li>\n<li><p>加载模块</p>\n<pre><code> // - 注意：require的第一个参数必须是数组\n\n // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应\n require([&#39;a&#39;, &#39;js/b&#39;], function(a, b) {\n   // 使用模块a 和 模块b 中的代码\n })\n</code></pre></li>\n<li><p>路径查找配置</p>\n<ul>\n<li>requirejs 默认使用 baseUrl+paths 的路径解析方式</li>\n<li><p>可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://</p>\n<pre><code>// 配置示例\n// 注意配置应当在使用之前\nrequire.config({\nbaseUrl: &#39;./js&#39; // 配置基础路径为：当前目录下的js目录\n})\nrequire([&#39;a&#39;])    // 查找 基础路径下的 ./js/a.js\n\n// 简化加载模块路径\nrequire.config({\nbaseUrl: &#39;./js&#39;,\n// 配置一次即可，直接通过路径名称（template || jquery）加载模块\npaths: {\n  template: &#39;assets/artTemplate/template-native&#39;,\n  jquery: &#39;assets/jquery/jquery.min&#39;\n}\n})\n// 加载jquery template模块\nrequire([&#39;jquery&#39;, &#39;template&#39;])\n</code></pre></li>\n</ul>\n</li>\n<li><p>非模块化和依赖项支持</p>\n<ul>\n<li>添加模块的依赖模块，保证加载顺序（deps）</li>\n<li><p>将非模块化模块，转化为模块化（exports）</p>\n<pre><code>// 示例\nrequire.config({\nbaseUrl: &#39;./js&#39;,\npaths: {\n  // 配置路径\n  noModule: &#39;assets/demo/noModule&#39;\n},\n// 配置不符合规范的模块项\nshim: {\n  // 模块名称\n  noModule: {\n    deps: [],         // 依赖项\n    exports: &#39;sayHi&#39;  // 导出模块中存在的函数或变量\n  }\n}\n});\n\n// 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块\n// 定义 这个模块名称与paths中的名称相同\ndefine(&#39;moduleA&#39;, function() {})\n// 导入\nrequire.config({\npaths: {\n  // 此处的模块名：moduleA\n  moduleA: &#39;assets/demo/moduleA&#39;\n}\n})\n</code></pre></li>\n</ul>\n</li>\n<li><p>路径加载规则<br>路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找</p>\n<pre><code> &lt;!-- \n   设置data-main属性\n   1 data-main属性指定的文件也会同时被加载\n   2 用于指定查找其他模块的基础路径\n --&gt;\n &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ol>\n","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>记录 Vue 的学习, Vue -渐进式JavaScript框架</p>\n</blockquote>","more":"<h2 id=\"MVC-与-MVVM-的区别\"><a href=\"#MVC-与-MVVM-的区别\" class=\"headerlink\" title=\"MVC 与 MVVM 的区别\"></a>MVC 与 MVVM 的区别</h2><p>MVC 是指 Model View Controller（模型-视图-控制器），是一种 Web 架构的模式。<br>MVVM 是指 Model-View-ViewModel，是一种基于前端开发的架构模式。<br>在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。<br>MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。</p>\n<h2 id=\"Vue-实例\"><a href=\"#Vue-实例\" class=\"headerlink\" title=\"Vue 实例\"></a>Vue 实例</h2><p><b>注意点：</b></p>\n<ol>\n<li>需要先在data中声明数据，再使用数据</li>\n<li>可以通过 vm.$data 访问到data中的所有属性，或者 vm.msg</li>\n</ol>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><p>将DOM与Vue实例的data数据绑定到一起，彼此之间相互影响。通过 getter 和 setter 来实现双向绑定</p>\n<h2 id=\"动态添加数据的注意点\"><a href=\"#动态添加数据的注意点\" class=\"headerlink\" title=\"动态添加数据的注意点\"></a>动态添加数据的注意点</h2><p>只有 data 中的数据才是响应式的，动态添加进来的数据默认为非响应式<br>可以通过以下方式实现动态添加数据的响应式</p>\n<ol>\n<li>Vue.set(object, key, value) - 适用于添加单个属性</li>\n<li>Object.assign() - 适用于添加多个属性</li>\n</ol>\n<h2 id=\"异步-DOM-更新\"><a href=\"#异步-DOM-更新\" class=\"headerlink\" title=\"异步 DOM 更新\"></a>异步 DOM 更新</h2><ul>\n<li>说明：Vue 异步执行 DOM 更新，监视所有数据改变，一次性更新DOM</li>\n<li>优势：可以去除重复数据，对于避免不必要的计算和避免重复 DOM 操作上，非常重要</li>\n<li>如果需要那到更新后 DOM 中的数据，则需要通过 Vue.nextTick(callback)：在DOM更新后，执行某个操作（属于DOM操作） 实例调用 vm.$nextTick(function () {})</li>\n</ul>\n<h2 id=\"Vue-指令\"><a href=\"#Vue-指令\" class=\"headerlink\" title=\"Vue 指令\"></a>Vue 指令</h2><p>Vue 指令一般是带有 v- 前缀的特殊属性，当表达式的值改变是，将其产生的连带影响，响应式地作用于 DOM</p>\n<ul>\n<li>v-text: 更新 DOM 对象的 textContent</li>\n<li>v-html: 更新 DOM 对象的 innerHTML</li>\n<li>v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li>\n<li>v-on: 绑定事件， 绑定的事件定义在 methods 中</li>\n<li>事件修饰符<ul>\n<li>.stop 阻止冒泡，调用 event.stopPropagation()</li>\n<li>.prevent 阻止默认行为，调用 event.preventDefault()</li>\n<li>.capture 添加事件侦听器时使用事件捕获模式</li>\n<li>.self 只当事件在该元素本身（比如不是子元素）触发时，才会触发事件</li>\n<li>.once 事件只触发一次</li>\n</ul>\n</li>\n<li>v-model: 在表单元素上创建双向数据绑定，监听用户的输入事件以更新数据</li>\n<li>v-for: 基于源数据多次渲染元素或模板块</li>\n<li>key属性: 使用 v-for 的时候提供 key 属性，以获得性能提升。使用 key，Vue 会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li>\n</ul>\n<h2 id=\"样式处理-class-和-style\"><a href=\"#样式处理-class-和-style\" class=\"headerlink\" title=\"样式处理 -class 和 style\"></a>样式处理 -class 和 style</h2><p>使用方式：v-bind:class=”expression” or :class=”expression”， 表达式的类型：字符串、数组、对象（重点）</p>\n<ul>\n<li><p>v-if 和 v-show</p>\n<ul>\n<li>v-if: 根据表达式的值的真假条件，销毁或重建元素</li>\n<li>v-show: 根据表达式之真假值，切换元素的 display CSS 属性</li>\n</ul>\n</li>\n<li><p>提升性能: v-pre<br>vue会跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译</p>\n</li>\n<li><p>提升性能：v-once<br>vue只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>\n</li>\n</ul>\n<h2 id=\"过滤器-filter\"><a href=\"#过滤器-filter\" class=\"headerlink\" title=\"过滤器 filter\"></a>过滤器 filter</h2><p>文本数据格式化</p>\n<ul>\n<li>全局过滤器<br>通过全局方式创建的过滤器，在任何一个vue实例中都可以使用。使用全局过滤器的时候，需要先创建全局过滤器，再创建Vue实例。显示的内容由过滤器的返回值决定</li>\n<li>局部过滤器<br>局部过滤器是在某一个vue实例的内容创建的，只在当前实例中起作用</li>\n</ul>\n<h2 id=\"按键值修饰符\"><a href=\"#按键值修饰符\" class=\"headerlink\" title=\"按键值修饰符\"></a>按键值修饰符</h2><p>在监听键盘事件时，Vue 允许为 v-on 在监听键盘事件时添加关键修饰符。例如@keyup.13=”submit”</p>\n<h2 id=\"监视数据变化-watch\"><a href=\"#监视数据变化-watch\" class=\"headerlink\" title=\"监视数据变化 - watch\"></a>监视数据变化 - watch</h2><p>watch是一个对象，键是需要观察的表达式，值是对应回调函数，当表达式的值发生变化后，会调用对应的回调函数完成响应的监视操作</p>\n<h2 id=\"实例生命周期\"><a href=\"#实例生命周期\" class=\"headerlink\" title=\"实例生命周期\"></a>实例生命周期</h2><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象即可 (一些根实例特有的选项除外)。<br>实例生命周期也叫做：组件生命周期</p>\n<h3 id=\"生命周期介绍\"><a href=\"#生命周期介绍\" class=\"headerlink\" title=\"生命周期介绍\"></a>生命周期介绍</h3><p>一个组件从开始到最后消亡所经历的各种状态，就是一个组件的生命周期<br>生命周期钩子函数的定义：从组件被创建，到组件挂载到页面上运行，再到页面关闭组件被卸载，这三个阶段总是伴随着组件各种各样的事件，这些事件，统称为组件的生命周期函数！<br>注意：</p>\n<ul>\n<li>Vue在执行过程中会自动调用生命周期钩子函数，我们只需要提供这些钩子函数即可</li>\n<li>钩子函数的名称都是Vue中规定好的！</li>\n</ul>\n<h3 id=\"钩子函数-beforeCreate\"><a href=\"#钩子函数-beforeCreate\" class=\"headerlink\" title=\"钩子函数 - beforeCreate()\"></a>钩子函数 - beforeCreate()</h3><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用<br>注意：此时，无法获取 data中的数据、methods中的方法</p>\n<h3 id=\"钩子函数-created\"><a href=\"#钩子函数-created\" class=\"headerlink\" title=\"钩子函数 - created()\"></a>钩子函数 - created()</h3><p>注意：这是一个常用的生命周期，可以调用methods中的方法、改变data中的数据 <a href=\"https://segmentfault.com/a/1190000008879966\" target=\"_blank\" rel=\"noopener\">参考资料1</a> <a href=\"https://segmentfault.com/a/1190000008010666\" target=\"_blank\" rel=\"noopener\">参考资料2</a></p>\n<h3 id=\"钩子函数-beforeMounted\"><a href=\"#钩子函数-beforeMounted\" class=\"headerlink\" title=\"钩子函数 - beforeMounted()\"></a>钩子函数 - beforeMounted()</h3><p>在挂载开始之前被调用</p>\n<h3 id=\"钩子函数-mounted\"><a href=\"#钩子函数-mounted\" class=\"headerlink\" title=\"钩子函数 - mounted()\"></a>钩子函数 - mounted()</h3><p>此时，vue实例已经挂载到页面中，可以获取到el中的DOM元素，进行DOM操作</p>\n<h3 id=\"钩子函数-beforeUpdated\"><a href=\"#钩子函数-beforeUpdated\" class=\"headerlink\" title=\"钩子函数 - beforeUpdated()\"></a>钩子函数 - beforeUpdated()</h3><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。<br>注意：此处获取的数据是更新后的数据，但是获取页面中的DOM元素是更新之前的</p>\n<h3 id=\"钩子函数-updated\"><a href=\"#钩子函数-updated\" class=\"headerlink\" title=\"钩子函数 - updated()\"></a>钩子函数 - updated()</h3><p>组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。</p>\n<h3 id=\"钩子函数-beforeDestroy\"><a href=\"#钩子函数-beforeDestroy\" class=\"headerlink\" title=\"钩子函数 - beforeDestroy()\"></a>钩子函数 - beforeDestroy()</h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>使用场景：实例销毁之前，执行清理任务，比如：清除定时器等</p>\n<h3 id=\"钩子函数-destroyed\"><a href=\"#钩子函数-destroyed\" class=\"headerlink\" title=\"钩子函数 - destroyed()\"></a>钩子函数 - destroyed()</h3><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>\n<h2 id=\"axios\"><a href=\"#axios\" class=\"headerlink\" title=\"axios\"></a>axios</h2><ul>\n<li>Promise based HTTP client for the browser and node.js<ul>\n<li>以Promise为基础的HTTP客户端，适用于：浏览器和node.js</li>\n<li>封装ajax，用来发送请求，异步获取数据</li>\n</ul>\n</li>\n<li>安装：npm i -S axios</li>\n<li>拦截器：拦截器会拦截发送的每一个请求，请求发送之前执行request中的函数，请求发送完成之后执行response中的函数</li>\n</ul>\n<h2 id=\"自定义组件\"><a href=\"#自定义组件\" class=\"headerlink\" title=\"自定义组件\"></a>自定义组件</h2><ul>\n<li>作用：进行DOM操作</li>\n<li>使用场景：对纯 DOM 元素进行底层操作，比如：文本框获得焦点</li>\n<li>两种指令：1 全局指令 2 局部指令</li>\n</ul>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><blockquote>\n<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树</p>\n</blockquote>\n<p>创建组件的两种方式：1 全局组件 2 局部组件</p>\n<h3 id=\"全局组件\"><a href=\"#全局组件\" class=\"headerlink\" title=\"全局组件\"></a>全局组件</h3><ul>\n<li>说明：全局组件在所有的vue实例中都可以使用</li>\n<li>注意：先注册组件，再初始化根实例</li>\n<li>extend：使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</li>\n</ul>\n<h3 id=\"局部组件\"><a href=\"#局部组件\" class=\"headerlink\" title=\"局部组件\"></a>局部组件</h3><p>局部组件，是在某一个具体的vue实例中定义的，只能在这个vue实例中使用</p>\n<h3 id=\"is特性\"><a href=\"#is特性\" class=\"headerlink\" title=\"is特性\"></a>is特性</h3><blockquote>\n<p>在某些特定的标签中只能存在指定表恰 如ul &gt; li 如果要浏览器正常解析则需要使用is</p>\n</blockquote>\n<h2 id=\"组件通讯\"><a href=\"#组件通讯\" class=\"headerlink\" title=\"组件通讯\"></a>组件通讯</h2><h3 id=\"父组件到子组件\"><a href=\"#父组件到子组件\" class=\"headerlink\" title=\"父组件到子组件\"></a>父组件到子组件</h3><p>通过子组件props属性来传递数据 props是一个数组, 传递过来的props属性的用法与data属性的用法相同<br>注意：属性的值必须在组件中通过props属性显示指定，否则，不会生效</p>\n<h3 id=\"子组件到父组件\"><a href=\"#子组件到父组件\" class=\"headerlink\" title=\"子组件到父组件\"></a>子组件到父组件</h3><p>父组件给子组件传递一个函数，由子组件调用这个函数。借助vue中的自定义事件（v-on:cunstomFn=”fn”）<br>步骤：</p>\n<ol>\n<li>在父组件中定义方法 parentFn</li>\n<li>在子组件 组件引入标签 中绑定自定义事件 v-on:自定义事件名=”父组件中的方法” ==&gt; @pfn=”parentFn”</li>\n<li>子组件中通过$emit()触发自定义事件事件 this.$emit(pfn,参数列表。。。)</li>\n</ol>\n<h3 id=\"非父子组件通讯\"><a href=\"#非父子组件通讯\" class=\"headerlink\" title=\"非父子组件通讯\"></a>非父子组件通讯</h3><blockquote>\n<p>在简单的场景下，可以使用一个空的 Vue 实例作为事件总线<br>$on()：绑定自定义事件</p>\n</blockquote>\n<h3 id=\"内容分发\"><a href=\"#内容分发\" class=\"headerlink\" title=\"内容分发\"></a>内容分发</h3><p>通过<slot></slot> 标签指定内容展示区域</p>\n<h3 id=\"获取组件（或元素）-refs\"><a href=\"#获取组件（或元素）-refs\" class=\"headerlink\" title=\"获取组件（或元素） - refs\"></a>获取组件（或元素） - refs</h3><p>vm.$refs 一个对象，持有已注册过 ref 的所有子组件（或HTML元素）.在 HTML元素 中，添加ref属性，然后在JS中通过vm.$refs.属性来获取<br>注意：如果获取的是一个子组件，那么通过ref就能获取到子组件中的data和methods</p>\n<h2 id=\"SPA-单页应用程序\"><a href=\"#SPA-单页应用程序\" class=\"headerlink\" title=\"SPA -单页应用程序\"></a>SPA -单页应用程序</h2><h3 id=\"SPA：-Single-Page-Application\"><a href=\"#SPA：-Single-Page-Application\" class=\"headerlink\" title=\"SPA： Single Page Application\"></a>SPA： Single Page Application</h3><blockquote>\n<p>单页Web应用（single page application，SPA），就是只有一个Web页面的应用，是加载单个HTML页面，并在用户与应用程序交互时动态更新该页面的Web应用程序。</p>\n</blockquote>\n<ul>\n<li>单页面应用程序：只有第一次会加载页面, 以后的每次请求, 仅仅是获取必要的数据.然后, 由页面中js解析获取的数据, 展示在页面中</li>\n<li>传统多页面应用程序：对于传统的多页面应用程序来说, 每次请求服务器返回的都是一个完整的页面<br>优势:</li>\n<li>减少了请求体积，加快页面响应速度，降低了对服务器的压力</li>\n<li>更好的用户体验，让用户在web app感受native app的流畅<br>实现思路和技术点</li>\n</ul>\n<ol>\n<li>ajax</li>\n<li>锚点的使用（window.location.hash #）</li>\n<li>hashchange 事件 window.addEventListener(“hashchange”,function () {})</li>\n<li>监听锚点值变化的事件，根据不同的锚点值，请求相应的数据</li>\n<li>原本用作页面内部进行跳转，定位并展示相应的内容</li>\n</ol>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>路由即：浏览器中的哈希值（# hash）与展示视图内容（template）之间的对应规则<br>vue中的路由是：hash 和 component的对应关系,在 Web app 中，通过一个页面来展示和管理整个应用的功能。SPA往往是功能复杂的应用，为了有效管理所有视图内容，前端路由 应运而生！简单来说，路由就是一套映射规则（一对一的对应规则），由开发人员制定规则。当URL中的哈希值（# hash）发生改变后，路由会根据制定好的规则，展示对应的视图内容<br>基本使用 安装：npm i -S vue-router<br>重定向 { path: ‘/‘, redirect: ‘/home’ }<br>路由其他配置 </p>\n<ul>\n<li>路由导航高亮 当前匹配的导航链接，会自动添加router-link-exact-active router-link-active类</li>\n<li>匹配路由模式 配置：mode<br>路由参数</li>\n<li>说明：我们经常需要把某种模式匹配到的所有路由，全都映射到同一个组件，此时，可以通过路由参数来处理</li>\n<li>语法：/user/:id</li>\n<li>使用：当匹配到一个路由时，参数值会被设置到 this.$route.params</li>\n<li>其他：可以通过 $route.query 获取到 URL 中的查询参数 等<br>嵌套路由 - 子路由</li>\n<li>路由是可以嵌套的，即：路由中又包含子路由</li>\n<li>规则：父组件中包含 router-view，在路由规则中使用 children 配置</li>\n</ul>\n<h2 id=\"前端模块化\"><a href=\"#前端模块化\" class=\"headerlink\" title=\"前端模块化\"></a>前端模块化</h2><p>为什么需要模块化?</p>\n<ol>\n<li>最开始的js就是为了实现客户端验证以及一些简单的效果</li>\n<li>后来，js得到重视，应用越来越广泛，前端开发的复杂度越来越高</li>\n<li>旧版本的js中没有提供与模块（module）相关的内容<h3 id=\"模块的概念\"><a href=\"#模块的概念\" class=\"headerlink\" title=\"模块的概念\"></a>模块的概念</h3></li>\n</ol>\n<ul>\n<li>在js中，一个模块就是实现特定功能的文件（js文件）</li>\n<li>遵循模块的机制，想要什么功能就加载什么模块</li>\n<li>模块化开发需要遵循规范</li>\n</ul>\n<h3 id=\"模块化解决的问题\"><a href=\"#模块化解决的问题\" class=\"headerlink\" title=\"模块化解决的问题\"></a>模块化解决的问题</h3><ol>\n<li>命名冲突</li>\n<li>文件依赖（加载文件）</li>\n<li>模块的复用</li>\n<li>统一规范和开发方式</li>\n</ol>\n<h3 id=\"JS实现模块化的规范\"><a href=\"#JS实现模块化的规范\" class=\"headerlink\" title=\"JS实现模块化的规范\"></a>JS实现模块化的规范</h3><p>AMD 的使用</p>\n<blockquote>\n<p>Asynchronous Module Definition：异步模块定义，浏览器端模块开发的规范 代表：require.js 特点：模块被异步加载，模块加载不影响后面语句的运行</p>\n</blockquote>\n<ol>\n<li><p>定义模块</p>\n<pre><code> // 语法:define(name, dependencies?, factory);\n // name表示：当前模块的名称，是一个字符串 可有可无\n // dependencies表示：当前模块的依赖项，是一个数组无论依赖一项还是多项 无则不写\n // factory表示：当前模块要完成的一些功能，是一个函数\n\n // 定义对象模块\n define({})\n // 定义方法模块\n define(function() {\n   return {}\n })\n // 定义带有依赖项的模块\n define([&#39;js/a&#39;], function() {})\n</code></pre></li>\n<li><p>加载模块</p>\n<pre><code> // - 注意：require的第一个参数必须是数组\n\n // 参数必须是数组 表示模块路径 以当前文件为基准,通过回调函数中的参数获取加载模块中的变量 参数与模块按照顺序一一对应\n require([&#39;a&#39;, &#39;js/b&#39;], function(a, b) {\n   // 使用模块a 和 模块b 中的代码\n })\n</code></pre></li>\n<li><p>路径查找配置</p>\n<ul>\n<li>requirejs 默认使用 baseUrl+paths 的路径解析方式</li>\n<li><p>可以使用以下方式避开此设置：1 以.js结尾 2 以 / 开始 3 包含协议：https:// 或 http://</p>\n<pre><code>// 配置示例\n// 注意配置应当在使用之前\nrequire.config({\nbaseUrl: &#39;./js&#39; // 配置基础路径为：当前目录下的js目录\n})\nrequire([&#39;a&#39;])    // 查找 基础路径下的 ./js/a.js\n\n// 简化加载模块路径\nrequire.config({\nbaseUrl: &#39;./js&#39;,\n// 配置一次即可，直接通过路径名称（template || jquery）加载模块\npaths: {\n  template: &#39;assets/artTemplate/template-native&#39;,\n  jquery: &#39;assets/jquery/jquery.min&#39;\n}\n})\n// 加载jquery template模块\nrequire([&#39;jquery&#39;, &#39;template&#39;])\n</code></pre></li>\n</ul>\n</li>\n<li><p>非模块化和依赖项支持</p>\n<ul>\n<li>添加模块的依赖模块，保证加载顺序（deps）</li>\n<li><p>将非模块化模块，转化为模块化（exports）</p>\n<pre><code>// 示例\nrequire.config({\nbaseUrl: &#39;./js&#39;,\npaths: {\n  // 配置路径\n  noModule: &#39;assets/demo/noModule&#39;\n},\n// 配置不符合规范的模块项\nshim: {\n  // 模块名称\n  noModule: {\n    deps: [],         // 依赖项\n    exports: &#39;sayHi&#39;  // 导出模块中存在的函数或变量\n  }\n}\n});\n\n// 注意点  如果定义模块的时候，指定了模块名称，需要使用该名称来引用模块\n// 定义 这个模块名称与paths中的名称相同\ndefine(&#39;moduleA&#39;, function() {})\n// 导入\nrequire.config({\npaths: {\n  // 此处的模块名：moduleA\n  moduleA: &#39;assets/demo/moduleA&#39;\n}\n})\n</code></pre></li>\n</ul>\n</li>\n<li><p>路径加载规则<br>路径配置的优先级：1 通过 config 配置规则查找 2 通过 data-main 指定的路径查找 3 以引入 requirejs 的页面所在路径为准查找</p>\n<pre><code> &lt;!-- \n   设置data-main属性\n   1 data-main属性指定的文件也会同时被加载\n   2 用于指定查找其他模块的基础路径\n --&gt;\n &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;\n</code></pre></li>\n</ol>"},{"title":"前端知识谱","date":"2019-06-20T08:23:01.000Z","_content":"\n> 前端知识谱，从基础入手，往深层学习。一点点扎实自己，从基础沉淀。(持续更新)\n\n<!-- more -->\n\n# 前端总谱\n## HTML\n### BOM\n1. 什么是BOM？\nBOM（Browser Object Model），是**浏览器对象模型**。浏览器页面初始化时，会在内存创建一个全局对象，用来描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型。\n不同于 DOM 的标准化组织是 W3C，JavaScript 的语法标准化组织是 ECMA，BOM 没有官方标准，它最初是 Netscape 浏览器标准的一部分，也就是说，对于现代浏览器，每个浏览器都有自己的 BOM 实现方法，所以直接使用 BOM 会有**兼容性问题**。\n2. BOM 包含哪些内容？\nBOM 包含一个对象 **window**，**window** 中又包含 6 大模块，分别为：\n1). **document** 对象：文档对象\n2). **frames**：HTML自框架\n3). **history**：页面的历史记录\n4). **location**：当前页面的地址\n5). **navigator**：浏览器相关信息\n6). **screen**：用户显示屏幕相关参数\n3. 各模块介绍\n1). **window** 对象\nBOM 的核心对象就是 window 对象，所有浏览器都支持 window 对象，它代表浏览器的窗口。\nJavaScript 的所有全局对象、全局方法和全局变量全都自动被归为 window 对象的方法和属性，在调用这些方法和属性的时候可以省略 window。DOM 也是 window 对象的属性。\n**window 对象的 size**\nwindow 对象有两个用来定义浏览器窗口大小的属性（两个属性均返回以 px 像素为单位的数值）：window.innerHeight（返回浏览器窗口的高度） 和 window.innerWidth（返回浏览器窗口的宽度）\n注意：浏览器窗口的视窗不包括工具栏和滚动条。\n兼容问题：对于IE 5-8，innerWidth和innerHeight并不兼容，需要使用 document.documentElement.clientHeight / document.documentElement.clientWidth 或者 document.body.clientHeight / document.body.clientWidth。\n**window 的方法**\nwindow.open(url, target, specs, replace)：打开一个新窗口。四个参数（均为可选）。\nwindow.close()：关闭当前窗口。\nwindow.moveTo()：移动窗口到特定位置。\nwindow.resizeTo()：修改窗口大小。\n2). **document** 对象\ndocument 对象是 HTML 文档的根节点。每一个元素都会生成对应的 DOM对象，由于元素之间存在层级关系，整个 HTML 代码解析结束后，会生成一个由不同节点组成的树形结构，成为 DOM 树。document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。\n3). **frames**\nframe 指 HTML 子框架，即在浏览器里嵌入另一个窗口。父框架和子框架拥有独立的作用域和上下文。\nwindow.frames 返回的是一个类数组的对象，对象的内容是当前页面中的 <iframe\\> 元素。这些 <iframe\\> 元素可以通过索引号来获得。\n4). **history**\nwindow.history 对象包含浏览器的历史记录，window 可以省略。这些历史记录以**栈（FIFO）**的形式保存。页面前进则入栈，页面返回则出栈。\n**history 的方法**\nhistory.back()：跳转到历史记录中的前一个链接\nhistory.forward()：跳转到历史记录中的后一个链接\n5). **location**\nwindow.location 可以用户获取当前页面地址以及重定向到一个新的页面。\n**location 的属性**\nwindow.location.href： 返回当前页面的地址\nwindow.location.hostname： 返回当前页面的域名\nwindow.location.pathname： 返回当前页面的路径和文件名\nwindow.location.protocol： 返回网页使用的协议（http: 还是 https:）\nwindow.location.port： 返回当前页面的端口，如果页面使用的是默认端口（http:80,https:443），则大多数浏览器会显示为0或者不显示\nwindow.location.assgin: 加载一个新的文档\n6). **navigator**\nnavigator 对象是一个只读对象，它用来描述浏览器本身的信息，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。\n7). **screen**\nscreen 提供了用户显示屏幕的相关属性，比如显示屏幕的宽度、高度，可用宽度、高度。\n**screen 的属性**\nscreen.width：显示屏的宽度\nscreen.height：显示屏的高度\nscreen.availWidth： 屏幕的可用宽度\nscreen.availHeight： 屏幕的可用高度\n### DOM\nHTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。\n每个节点都拥有包含着关于节点某些信息的属性。这些属性是：\nnodeName（节点名称）nodeValue（节点值）nodeType（节点类型）\n根据W3C的 HTML DOM 标准，HTML 文档中的所有内容都是节点：\n1). 整个文档是一个文档节点\n2). 每个 HTML 元素是元素节点\n4). HTML 元素内的文本是文本节点\n5). 每个 HTML 属性是属性节点\n6). 注释是注释节点\n### 语义化\n定义：首先是关于语义（Semantics）和默认样式的区别，默认样式是浏览器设定的一些常用tag的表现形式，语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。<strong\\>,<em\\>用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。\n优点：语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。\n### 事件\nHTML 4 增加了使事件在浏览器中触发动作的能力，比如当用户点击元素时启动 JavaScript。\n**Window 事件属性**\n针对 window 对象触发的事件（应用到 <body\\> 标签）：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onafterprint | 文档打印之后运行的脚本。 | 是 |\n| onbeforeprint | 文档打印之前运行的脚本。 | 是 |\n| onbeforeunload | 文档卸载之前运行的脚本。 | 是 |\n| onerror | 在错误发生时运行的脚本。 | 是 |\n| onhaschange | 当文档已改变时运行的脚本。 | 是 |\n| onload | 页面结束加载之后触发。 | 否 |\n| onmessage | 在消息被触发时运行的脚本。 | 是 |\n| onoffline | 当文档离线时运行的脚本。 | 是 |\n| ononline | 当文档上线时运行的脚本。 | 是 |\n| onpagehide | 当窗口隐藏时运行的脚本。 | 是 |\n| onpageshow | 当窗口成为可见时运行的脚本。 | 是 |\n| onpopstate | 当窗口历史记录改变时运行的脚本。 | 是 |\n| onredo | 当文档执行撤销（redo）时运行的脚本。 | 是 |\n| onresize | 当浏览器窗口被调整大小时触发。 | 是 |\n| onstorage | 在 Web Storage 区域更新后运行的脚本。 | 是 |\n| onundo | 在文档执行 undo 时运行的脚本。 | 是 |\n| onunload | 一旦页面已下载时触发（或者浏览器窗口已被关闭）。 | 否 |\n**Form 事件**\n由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onblur | 元素失去焦点时运行的脚本。 | 否 |\n| onchange | 在元素值被改变时运行的脚本。 | 否 |\n| oncontextmenu | 当上下文菜单被触发时运行的脚本。 | 是 |\n| onfocus | 当元素获得焦点时运行的脚本。 | 否 |\n| onformchange | 在表单改变时运行的脚本。 | 是 |\n| onforminput | 当表单获得用户输入时运行的脚本。 | 是 |\n| oninput | 当元素获得用户输入时运行的脚本。 | 是 |\n| oninvalid | 当元素无效时运行的脚本。 | 是 |\n| onreset | 当表单中的重置按钮被点击时触发。HTML5 中不支持。 | 否 |\n| onselect | 在元素中文本被选中后触发。 | 否 |\n| onsubmit | 在提交表单时触发。 | 否 |\n**Keyboard 事件**\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onkeydown | 在用户按下按键时触发。 | 否 |\n| onkeypress | 在用户敲击按钮时触发。 | 否 |\n| onkeyup | 当用户释放按键时触发。 | 否 |\n**Mouse 事件**\n由鼠标或类似用户动作触发的事件：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onclick | 元素上发生鼠标点击时触发。 | 否 |\n| ondblclick | 元素上发生鼠标双击时触发。 | 否 |\n| ondrag | 元素被拖动时运行的脚本。 | 是 |\n| ondragend | 在拖动操作末端运行的脚本。 | 是 |\n| ondragenter | 当元素元素已被拖动到有效拖放区域时运行的脚本。 | 是 |\n| ondragleave | 当元素离开有效拖放目标时运行的脚本。 | 是 |\n| ondragover | 当元素在有效拖放目标上正在被拖动时运行的脚本。 | 是 |\n| ondragstart | 在拖动操作开端运行的脚本。 | 是 |\n| ondrop | 当被拖元素正在被拖放时运行的脚本。 | 是 |\n| onmousedown | 当元素上按下鼠标按钮时触发。 | 否 |\n| onmousemove | 当鼠标指针移动到元素上时触发。 | 否 |\n| onmouseout | 当鼠标指针移出元素时触发。 | 否 |\n| onmouseover | 当鼠标指针移动到元素上时触发。 | 否 |\n| onmouseup | 当在元素上释放鼠标按钮时触发。 | 否 |\n| onmousewheel | 当鼠标滚轮正在被滚动时运行的脚本。 | 是 |\n| onscroll | 当元素滚动条被滚动时运行的脚本。 | 是 |\n**Media 事件**\n由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 <audio\\>、<embed\\>、<img\\>、<object\\> 以及 <video\\>）:\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onabort | 在退出时运行的脚本。 | 否 |\n| oncanplay | 当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。 | 是 |\n| oncanplaythrough | 当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。 | 是 |\n| ondurationchange | 当媒介长度改变时运行的脚本。 | 是 |\n| onemptied | 当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。 | 是 |\n| onended | 当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。 | 是 |\n| onerror | 当在文件加载期间发生错误时运行的脚本。 | 是 |\n| onloadeddata | 当媒介数据已加载时运行的脚本。 | 是 |\n| onloadedmetadata | 当元数据（比如分辨率和时长）被加载时运行的脚本。 | 是 |\n| onloadstart | 在文件开始加载且未实际加载任何数据前运行的脚本。 | 是 |\n| onpause | 当媒介被用户或程序暂停时运行的脚本。 | 是 |\n| onplay | 当媒介已就绪可以开始播放时运行的脚本。 | 是 |\n| onplaying | 当媒介已开始播放时运行的脚本。 | 是 |\n| onprogress | 当浏览器正在获取媒介数据时运行的脚本。 | 是 |\n| onratechange | 每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。 | 是 |\n| onreadystatechange | 每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。 | 是 |\n| onseeked | 当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。 | 是 |\n| onseeking | 当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。 | 是 |\n| onstalled | 在浏览器不论何种原因未能取回媒介数据时运行的脚本。 | 是 |\n| onsuspend | 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。 | 是 |\n| ontimeupdate | 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。 | 是 |\n| onvolumechange | 每当音量改变时（包括将音量设置为静音）时运行的脚本。 | 是 |\n| onwaiting | 当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本 | 否 |\n### 渲染机制\n浏览器的渲染过程主要包括以下几步:\n1). 解析HTML生成DOM树。\n2). 解析CSS生成CSSOM规则树。\n3). 将DOM树与CSSOM规则树合并在一起生成渲染树。\n4). 遍历渲染树开始布局，计算每个节点的位置大小信息。\n5). 将渲染树每个节点绘制到屏幕。\n## CSS\n### 选择器\n在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。\n\n| 选择器 | 例子 | 例子描述 | CSS |\n| ------ | ------ | ------- | ------- |\n| .class | intro | 选择 class=\"intro\" 的所有元素。 | 1 |\n| #id | #firstname | 选择 id=\"firstname\" 的所有元素。 | 1 |\n| * | * | 选择所有元素。 | 2 |\n| element | p | 选择所有 <p\\> 元素。 | 1 |\n| element,element | div,p | 选择所有 <div\\> 元素和所有 <p\\> 元素。 | 1 |\n| element element | div p | 选择 <div\\> 元素内部的所有 <p\\> 元素。 | 1 |\n| element>element | div>p | 选择父元素为 <div\\> 元素的所有 <p\\> 元素。 | 2 |\n| element+element | div+p | 选择紧接在 <div\\> 元素之后的所有 <p\\> 元素。 | 2 |\n| [attribute] | [target] | 选择带有 target 属性所有元素。 | 2 |\n| [attribute=value] | [target=\\_blank] | 选择 target=\"\\_blank\" 的所有元素。 | 2 |\n| [attribute~=value] | [title~=flower] | 选择 title 属性包含单词 \"flower\" 的所有元素。 | 2 |\n| :link | a:link | 选择所有未被访问的链接。 | 1 |\n| :visited | a:visited | 选择所有已被访问的链接。 | 1 |\n| :active | a:active | 选择活动链接。 | 1 |\n| :hover | a:hover | 选择鼠标指针位于其上的链接。 | 1 |\n| :focus | input:focus | 选择获得焦点的 input 元素。 | 2 |\n| :first-letter | p:first-letter | 选择每个 <p\\> 元素的首字母。 | 1 |\n| :first-line | p:first-line | 选择每个 <p\\> 元素的首行。 | 1 |\n| :first-child | p:first-child | 选择属于父元素的第一个子元素的每个 <p\\> 元素。 | 2 |\n| :before | p:before | 在每个 <p\\> 元素的内容之前插入内容。 | 2 |\n| :after | p:after | 在每个 <p\\> 元素的内容之后插入内容。 | 2 |\n| :lang(language) | p:lang(it) | 选择带有以 \"it\" 开头的 lang 属性值的每个 <p\\> 元素。 | 2 |\n| element1~element2 | p~ul | 选择前面有 <p\\> 元素的每个 <ul\\> 元素。 | 3 |\n| [attribute^=value] | a[src^=\"https\"] | 选择其 src 属性值以 \"https\" 开头的每个 <a\\> 元素。 | 3 |\n| [attribute$=value] | a[src$=\".pdf\"] | 选择其 src 属性以 \".pdf\" 结尾的所有 <a\\> 元素。 | 3 |\n| [attribute*=value] | a[src*=\"abc\"] | 选择其 src 属性中包含 \"abc\" 子串的每个 <a\\> 元素。 | 3 |\n| :first-of-type | p:first-of-type | 选择属于其父元素的首个 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :last-of-type | p:last-of-type | 选择属于其父元素的最后 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :only-of-type | p:only-of-type | 选择属于其父元素唯一的 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :only-child | p:only-child | 选择属于其父元素的唯一子元素的每个 <p\\> 元素。 | 3 |\n| :nth-child(n) | p:nth-child(2) | 选择属于其父元素的第二个子元素的每个 <p\\> 元素。 | 3 |\n| :nth-last-child(n) | p:nth-last-child(2) | 同上，从最后一个子元素开始计数。 | 3 |\n| :nth-of-type(n) | p:nth-of-type(2) | 选择属于其父元素第二个 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。 | 3 |\n| :last-child | p:last-child | 选择属于其父元素最后一个子元素每个 <p\\> 元素。 | 3 |\n| :root | :root | 选择文档的根元素。 | 3 |\n| :empty | p:empty | 选择没有子元素的每个 <p\\> 元素（包括文本节点）。 | 3 |\n| :target | #news:target | 选择当前活动的 #news 元素。 | 3 |\n| :enabled | input:enabled | 选择每个启用的 <input\\> 元素。 | 3 |\n| :disabled | input:disabled | 选择每个禁用的 <input\\> 元素 | 3 |\n| :checked | input:checked | 选择每个被选中的 <input\\> 元素。 | 3 |\n| :not(selector) | :not(p) | 选择非 <p\\> 元素的每个元素。 | 3 |\n| ::selection | ::selection | 选择被用户选取的元素部分。| 3 |\n### 盒子布局\n所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。\n盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。\n**Margin(外边距)** - 清除边框外的区域，外边距是透明的。\n**Border(边框)** - 围绕在内边距和内容外的边框。\n**Padding(内边距)** - 清除内容周围的区域，内边距是透明的。\n**Content(内容)** - 盒子的内容，显示文本和图像。\n### 弹性布局（Flex）\n弹性盒子是 CSS3 的一种新的布局模式。\nCSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。\n引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。\n### Hack\n简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack 为不同版本的浏览器定制编写不同的 CSS 效果。\n常用的CSS Hack 方式：\n1）、条件注释法：\n* <!--[if IE]> 只在 IE 下生效\n* <![endif]--> 这段文字只在IE浏览器显示\n* <!--[if IE 6]> 只在IE6下生效\n* <![endif]--> 这段文字只在IE6浏览器显示\n* <!--[if gte IE 6]> 只在IE6以上版本生效\n* <![endif]--> 这段文字只在IE6以上(包括)版本IE浏览器显示\n* <!--[if ! IE 8]> 只在IE8上不生效\n* <![endif]--> 这段文字在非IE8浏览器显示\n* <!--[if !IE]> 非IE浏览器生效\n* <![endif]--> 这段文字只在非IE浏览器显示\n\n2）、类内属性前缀法\nIE浏览器各版本 CSS hack 对照表： \n\n| hack | 写法  | IE6(S) | IE6(Q) | IE7(S) | IE7(Q) | IE8(S) | IE8(Q) | IE9(S) | IE9(Q) | IE10(S) | IE10(Q) |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| * | \\*color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| + | +color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| - | -color | Y | Y | N | N | N | N | N | N | N | N |\n| _ | \\_color | Y | Y | N | Y | N | Y | N | Y | N | N |\n| # | #color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| \\0 | color:red\\0 | N | N | N | N | Y | N | Y | N | Y | N |\n| \\9\\0 | color:red\\9\\0 | N | N | N | N | N | N | Y | N | Y | N |\n| !important | color:blue !important;color:green; | N | N | Y | N | Y | N | Y | N | Y | Y |\n说明：在标准模式中:\n* “-″减号是IE6专有的hack\n* “\\9″ IE6/IE7/IE8/IE9/IE10都生效\n* “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack\n* “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack\n\n3）、选择器前缀法\n选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。\n* \\*html \\*前缀只对IE6生效\n* \\*+html \\*+前缀只对IE7生效\n* @media screen\\9{...}只对IE6/7生效\n* @media \\0screen {body { background: red; }}只对IE8有效\n* @media \\0screen\\,screen\\9{body { background: blue; }}只对IE6/7/8有效\n* @media screen\\0 {body { background: green; }} 只对IE8/9/10有效\n* @media screen and (min-width:0\\0) {body { background: gray; }} 只对IE9/10有效\n* @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等\n\n### LESS\nLess （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。\n\n### SASS\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。\n\n### 媒体查询\n使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n**媒体类型：**\n\n| 值 | 描述 |\n| --- | --- |\n| all | 用于所有设备 |\n| aural | 已废弃。用于语音和声音合成器 |\n| braille | 已废弃。 应用于盲文触摸式反馈设备 |\n| embossed | 已废弃。 用于打印的盲人印刷设备 |\n| handheld | 已废弃。 用于掌上设备或更小的装置，如PDA和小型电话 |\n| print | 用于打印机和打印预览 |\n| projection | 已废弃。 用于投影设备 |\n| screen | 用于电脑屏幕，平板电脑，智能手机等。 |\n| speech | 应用于屏幕阅读器等发声设备 |\n| tty | 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 |\n| tv | 已废弃。 用于电视和网络电视 |\n\n**媒体功能**\n\n| 值 | 描述 |\n| --- | --- |\n| aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的比率 |\n| color | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 |\n| color-index | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 |\n| device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的比率。 |\n| device-height | 定义输出设备的屏幕可见高度。 |\n| device-width | 定义输出设备的屏幕可见宽度。 |\n| grid | 用来查询输出设备是否使用栅格或点阵。 |\n| height | 定义输出设备中的页面可见区域高度。 |\n| max-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。 |\n| max-color | 定义输出设备每一组彩色原件的最大个数。 |\n| max-color-index | 定义在输出设备的彩色查询表中的最大条目数。 |\n| max-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。 |\n| max-device-height | 定义输出设备的屏幕可见的最大高度。 |\n| max-device-width | 定义输出设备的屏幕最大可见宽度。 |\n| max-height | 定义输出设备中的页面最大可见区域高度。 |\n| max-monochrome | 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。 |\n| max-resolution | 定义设备的最大分辨率。 |\n| max-width | 定义输出设备中的页面最大可见区域宽度。 |\n| min-aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的最小比率。 |\n| min-color | 定义输出设备每一组彩色原件的最小个数。 |\n| min-color-index | 定义在输出设备的彩色查询表中的最小条目数。 |\n| min-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最小比率。 |\n| min-device-width | 定义输出设备的屏幕最小可见宽度。 |\n| min-device-height | 定义输出设备的屏幕的最小可见高度。 |\n| min-height | 定义输出设备中的页面最小可见区域高度。 |\n| min-monochrome | 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数 |\n| min-resolution | 定义设备的最小分辨率。 |\n| min-width | 定义输出设备中的页面最小可见区域宽度。 |\n| monochrome | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 |\n| orientation | 定义输出设备中的页面可见区域高度是否大于或等于宽度。 |\n| resolution | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcmscan定义电视类设备的扫描工序。 |\n| width | 定义输出设备中的页面可见区域宽度。 |\n\n\n\n\n### 动画\n通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。\n**CSS3 @keyframes 规则**\n如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。\n\n## ECMAScript(Javascript)\nECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。\n**ECMAScript 历史**\n>1998年6月，ECMAScript 2.0版发布。\n>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。\n>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。\n>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。\n>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。\n>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。\n>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。\n>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。\n>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。\n>ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。TC39的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。\n>截止发布日期，JavaScript的官方名称是ECMAScript 2015，Ecma国际意在更频繁地发布包含小规模增量更新的新版本，下一版本将于2016年发布，命名为ECMAScript 2016。新版本将按照ECMAScript+年份的形式发布。\n>ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。\n>截止发布日期，没有一款完全支持ES6的JavaScript代理（无论是浏览器环境还是服务器环境），所以热衷于使用语言最新特性的开发者需要将ES6代码转译为ES5代码。等到主流浏览器完全实现ES6特性大概需要一年左右的时间，若想一睹各代理对于ES6特性的支持情况，我们推荐大家参考由 kangax 维护的 ECMAScript Compatibility Table 。\n>ECMAScript 2016的制定工作已经启动，许多 草案 已被提交到委员会，包括以下这些：异步方法、定型对象、并行JavaScript、类修饰符以及observables。虽然委员会正在积极评估这些特性，但我们无法预知它们的未来，其中一些会加入到下一版规范，另一些会加入未来的其它规范，剩下的将最终被遗弃。 TC39进程 解释了新特性从开始到最终被语言采用所经历的各种阶段。\n\n### 基础\n#### 内置类型\nJS中有七种内置类型，七种内置类型分为两大类：基本类型和对象（Object）。\n基本类型有六种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`。\n其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。`NaN` 也属于 `number` 类型，并且 `NaN` 不等于自身。\n对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型\n\n\n### 进阶\n### ES6\n### 正则表达式\n\n## 前端框架\n### jQuery\n### Anjular\n### React\n### Vue\n### bootstrap\n### antd\n### elementui\n\n## 小程序\n### 工具\n### 服务器\n### api\n### 组件\n### 云开发\n### 实战\n## 微信公众号\n\n### 对接微信服务器\n### 客服机器人\n### jssdk\n### 实战\n## Typescript\n\n## Node.js\n\n## 面试之道\n### 基础知识\n### 职业生涯\n### 一面/二面/三面\n### 开源看法、如何开源\n### 熟悉一门后端\n### 遇到问题如何解决\n\n## 浏览器\n### 事件机制\n### 时间循环机制\n### 渲染机制\n### 跨域\n### 存储\n### 性能\n\n## HTTP指南\n\n## 设计模式\n### 工厂模式\n### 抽象工厂模式\n### 建造者模式\n### 单例模式\n### 原型模式\n### 适配器模式\n### 装饰器模式\n### 代理模式\n### 外观模式\n### 桥接模式\n### 组合模式\n### 享元模式\n### 策略模式\n### 模板方法模式\n### 观察者模式\n### 迭代器模式\n### 职责链模式\n### 命令模式\n### 备忘录模式\n### 状态模式\n### 访问者模式\n### 中介者模式\n### 解释器模式\n\n## 工程化\n### 版本控制\n### mock\n### webpack\n### gulp\n### npm scripts\n### xxx-cli\n\n## 性能优化\n\n## 前端安全\n### 漏洞\n### XSS\n### CSRF\n### 持久化攻击\n### SQL注入\n### 爬虫对抗\n\n## 自动化测试\n### puppeteer\n### cypress\n\n## 工具调试\n### 编辑器IDE\n### chrome\n\n## 算法与数据结构\n### 基础知识\n### 复杂度\n### 数据结构\n### 搜索\n### 排序","source":"_posts/前端知识总谱.md","raw":"---\ntitle: 前端知识谱\ndate: 2019-06-20 16:23:01\ntags: js知识\ncategories: JS\n---\n\n> 前端知识谱，从基础入手，往深层学习。一点点扎实自己，从基础沉淀。(持续更新)\n\n<!-- more -->\n\n# 前端总谱\n## HTML\n### BOM\n1. 什么是BOM？\nBOM（Browser Object Model），是**浏览器对象模型**。浏览器页面初始化时，会在内存创建一个全局对象，用来描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型。\n不同于 DOM 的标准化组织是 W3C，JavaScript 的语法标准化组织是 ECMA，BOM 没有官方标准，它最初是 Netscape 浏览器标准的一部分，也就是说，对于现代浏览器，每个浏览器都有自己的 BOM 实现方法，所以直接使用 BOM 会有**兼容性问题**。\n2. BOM 包含哪些内容？\nBOM 包含一个对象 **window**，**window** 中又包含 6 大模块，分别为：\n1). **document** 对象：文档对象\n2). **frames**：HTML自框架\n3). **history**：页面的历史记录\n4). **location**：当前页面的地址\n5). **navigator**：浏览器相关信息\n6). **screen**：用户显示屏幕相关参数\n3. 各模块介绍\n1). **window** 对象\nBOM 的核心对象就是 window 对象，所有浏览器都支持 window 对象，它代表浏览器的窗口。\nJavaScript 的所有全局对象、全局方法和全局变量全都自动被归为 window 对象的方法和属性，在调用这些方法和属性的时候可以省略 window。DOM 也是 window 对象的属性。\n**window 对象的 size**\nwindow 对象有两个用来定义浏览器窗口大小的属性（两个属性均返回以 px 像素为单位的数值）：window.innerHeight（返回浏览器窗口的高度） 和 window.innerWidth（返回浏览器窗口的宽度）\n注意：浏览器窗口的视窗不包括工具栏和滚动条。\n兼容问题：对于IE 5-8，innerWidth和innerHeight并不兼容，需要使用 document.documentElement.clientHeight / document.documentElement.clientWidth 或者 document.body.clientHeight / document.body.clientWidth。\n**window 的方法**\nwindow.open(url, target, specs, replace)：打开一个新窗口。四个参数（均为可选）。\nwindow.close()：关闭当前窗口。\nwindow.moveTo()：移动窗口到特定位置。\nwindow.resizeTo()：修改窗口大小。\n2). **document** 对象\ndocument 对象是 HTML 文档的根节点。每一个元素都会生成对应的 DOM对象，由于元素之间存在层级关系，整个 HTML 代码解析结束后，会生成一个由不同节点组成的树形结构，成为 DOM 树。document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。\n3). **frames**\nframe 指 HTML 子框架，即在浏览器里嵌入另一个窗口。父框架和子框架拥有独立的作用域和上下文。\nwindow.frames 返回的是一个类数组的对象，对象的内容是当前页面中的 <iframe\\> 元素。这些 <iframe\\> 元素可以通过索引号来获得。\n4). **history**\nwindow.history 对象包含浏览器的历史记录，window 可以省略。这些历史记录以**栈（FIFO）**的形式保存。页面前进则入栈，页面返回则出栈。\n**history 的方法**\nhistory.back()：跳转到历史记录中的前一个链接\nhistory.forward()：跳转到历史记录中的后一个链接\n5). **location**\nwindow.location 可以用户获取当前页面地址以及重定向到一个新的页面。\n**location 的属性**\nwindow.location.href： 返回当前页面的地址\nwindow.location.hostname： 返回当前页面的域名\nwindow.location.pathname： 返回当前页面的路径和文件名\nwindow.location.protocol： 返回网页使用的协议（http: 还是 https:）\nwindow.location.port： 返回当前页面的端口，如果页面使用的是默认端口（http:80,https:443），则大多数浏览器会显示为0或者不显示\nwindow.location.assgin: 加载一个新的文档\n6). **navigator**\nnavigator 对象是一个只读对象，它用来描述浏览器本身的信息，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。\n7). **screen**\nscreen 提供了用户显示屏幕的相关属性，比如显示屏幕的宽度、高度，可用宽度、高度。\n**screen 的属性**\nscreen.width：显示屏的宽度\nscreen.height：显示屏的高度\nscreen.availWidth： 屏幕的可用宽度\nscreen.availHeight： 屏幕的可用高度\n### DOM\nHTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。\n每个节点都拥有包含着关于节点某些信息的属性。这些属性是：\nnodeName（节点名称）nodeValue（节点值）nodeType（节点类型）\n根据W3C的 HTML DOM 标准，HTML 文档中的所有内容都是节点：\n1). 整个文档是一个文档节点\n2). 每个 HTML 元素是元素节点\n4). HTML 元素内的文本是文本节点\n5). 每个 HTML 属性是属性节点\n6). 注释是注释节点\n### 语义化\n定义：首先是关于语义（Semantics）和默认样式的区别，默认样式是浏览器设定的一些常用tag的表现形式，语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。<strong\\>,<em\\>用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。\n优点：语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。\n### 事件\nHTML 4 增加了使事件在浏览器中触发动作的能力，比如当用户点击元素时启动 JavaScript。\n**Window 事件属性**\n针对 window 对象触发的事件（应用到 <body\\> 标签）：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onafterprint | 文档打印之后运行的脚本。 | 是 |\n| onbeforeprint | 文档打印之前运行的脚本。 | 是 |\n| onbeforeunload | 文档卸载之前运行的脚本。 | 是 |\n| onerror | 在错误发生时运行的脚本。 | 是 |\n| onhaschange | 当文档已改变时运行的脚本。 | 是 |\n| onload | 页面结束加载之后触发。 | 否 |\n| onmessage | 在消息被触发时运行的脚本。 | 是 |\n| onoffline | 当文档离线时运行的脚本。 | 是 |\n| ononline | 当文档上线时运行的脚本。 | 是 |\n| onpagehide | 当窗口隐藏时运行的脚本。 | 是 |\n| onpageshow | 当窗口成为可见时运行的脚本。 | 是 |\n| onpopstate | 当窗口历史记录改变时运行的脚本。 | 是 |\n| onredo | 当文档执行撤销（redo）时运行的脚本。 | 是 |\n| onresize | 当浏览器窗口被调整大小时触发。 | 是 |\n| onstorage | 在 Web Storage 区域更新后运行的脚本。 | 是 |\n| onundo | 在文档执行 undo 时运行的脚本。 | 是 |\n| onunload | 一旦页面已下载时触发（或者浏览器窗口已被关闭）。 | 否 |\n**Form 事件**\n由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onblur | 元素失去焦点时运行的脚本。 | 否 |\n| onchange | 在元素值被改变时运行的脚本。 | 否 |\n| oncontextmenu | 当上下文菜单被触发时运行的脚本。 | 是 |\n| onfocus | 当元素获得焦点时运行的脚本。 | 否 |\n| onformchange | 在表单改变时运行的脚本。 | 是 |\n| onforminput | 当表单获得用户输入时运行的脚本。 | 是 |\n| oninput | 当元素获得用户输入时运行的脚本。 | 是 |\n| oninvalid | 当元素无效时运行的脚本。 | 是 |\n| onreset | 当表单中的重置按钮被点击时触发。HTML5 中不支持。 | 否 |\n| onselect | 在元素中文本被选中后触发。 | 否 |\n| onsubmit | 在提交表单时触发。 | 否 |\n**Keyboard 事件**\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onkeydown | 在用户按下按键时触发。 | 否 |\n| onkeypress | 在用户敲击按钮时触发。 | 否 |\n| onkeyup | 当用户释放按键时触发。 | 否 |\n**Mouse 事件**\n由鼠标或类似用户动作触发的事件：\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onclick | 元素上发生鼠标点击时触发。 | 否 |\n| ondblclick | 元素上发生鼠标双击时触发。 | 否 |\n| ondrag | 元素被拖动时运行的脚本。 | 是 |\n| ondragend | 在拖动操作末端运行的脚本。 | 是 |\n| ondragenter | 当元素元素已被拖动到有效拖放区域时运行的脚本。 | 是 |\n| ondragleave | 当元素离开有效拖放目标时运行的脚本。 | 是 |\n| ondragover | 当元素在有效拖放目标上正在被拖动时运行的脚本。 | 是 |\n| ondragstart | 在拖动操作开端运行的脚本。 | 是 |\n| ondrop | 当被拖元素正在被拖放时运行的脚本。 | 是 |\n| onmousedown | 当元素上按下鼠标按钮时触发。 | 否 |\n| onmousemove | 当鼠标指针移动到元素上时触发。 | 否 |\n| onmouseout | 当鼠标指针移出元素时触发。 | 否 |\n| onmouseover | 当鼠标指针移动到元素上时触发。 | 否 |\n| onmouseup | 当在元素上释放鼠标按钮时触发。 | 否 |\n| onmousewheel | 当鼠标滚轮正在被滚动时运行的脚本。 | 是 |\n| onscroll | 当元素滚动条被滚动时运行的脚本。 | 是 |\n**Media 事件**\n由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 <audio\\>、<embed\\>、<img\\>、<object\\> 以及 <video\\>）:\n\n| 属性 | 描述 | H5新增 |\n| ------ | ------ | ------- |\n| onabort | 在退出时运行的脚本。 | 否 |\n| oncanplay | 当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。 | 是 |\n| oncanplaythrough | 当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。 | 是 |\n| ondurationchange | 当媒介长度改变时运行的脚本。 | 是 |\n| onemptied | 当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。 | 是 |\n| onended | 当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。 | 是 |\n| onerror | 当在文件加载期间发生错误时运行的脚本。 | 是 |\n| onloadeddata | 当媒介数据已加载时运行的脚本。 | 是 |\n| onloadedmetadata | 当元数据（比如分辨率和时长）被加载时运行的脚本。 | 是 |\n| onloadstart | 在文件开始加载且未实际加载任何数据前运行的脚本。 | 是 |\n| onpause | 当媒介被用户或程序暂停时运行的脚本。 | 是 |\n| onplay | 当媒介已就绪可以开始播放时运行的脚本。 | 是 |\n| onplaying | 当媒介已开始播放时运行的脚本。 | 是 |\n| onprogress | 当浏览器正在获取媒介数据时运行的脚本。 | 是 |\n| onratechange | 每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。 | 是 |\n| onreadystatechange | 每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。 | 是 |\n| onseeked | 当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。 | 是 |\n| onseeking | 当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。 | 是 |\n| onstalled | 在浏览器不论何种原因未能取回媒介数据时运行的脚本。 | 是 |\n| onsuspend | 在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。 | 是 |\n| ontimeupdate | 当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。 | 是 |\n| onvolumechange | 每当音量改变时（包括将音量设置为静音）时运行的脚本。 | 是 |\n| onwaiting | 当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本 | 否 |\n### 渲染机制\n浏览器的渲染过程主要包括以下几步:\n1). 解析HTML生成DOM树。\n2). 解析CSS生成CSSOM规则树。\n3). 将DOM树与CSSOM规则树合并在一起生成渲染树。\n4). 遍历渲染树开始布局，计算每个节点的位置大小信息。\n5). 将渲染树每个节点绘制到屏幕。\n## CSS\n### 选择器\n在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。\n\n| 选择器 | 例子 | 例子描述 | CSS |\n| ------ | ------ | ------- | ------- |\n| .class | intro | 选择 class=\"intro\" 的所有元素。 | 1 |\n| #id | #firstname | 选择 id=\"firstname\" 的所有元素。 | 1 |\n| * | * | 选择所有元素。 | 2 |\n| element | p | 选择所有 <p\\> 元素。 | 1 |\n| element,element | div,p | 选择所有 <div\\> 元素和所有 <p\\> 元素。 | 1 |\n| element element | div p | 选择 <div\\> 元素内部的所有 <p\\> 元素。 | 1 |\n| element>element | div>p | 选择父元素为 <div\\> 元素的所有 <p\\> 元素。 | 2 |\n| element+element | div+p | 选择紧接在 <div\\> 元素之后的所有 <p\\> 元素。 | 2 |\n| [attribute] | [target] | 选择带有 target 属性所有元素。 | 2 |\n| [attribute=value] | [target=\\_blank] | 选择 target=\"\\_blank\" 的所有元素。 | 2 |\n| [attribute~=value] | [title~=flower] | 选择 title 属性包含单词 \"flower\" 的所有元素。 | 2 |\n| :link | a:link | 选择所有未被访问的链接。 | 1 |\n| :visited | a:visited | 选择所有已被访问的链接。 | 1 |\n| :active | a:active | 选择活动链接。 | 1 |\n| :hover | a:hover | 选择鼠标指针位于其上的链接。 | 1 |\n| :focus | input:focus | 选择获得焦点的 input 元素。 | 2 |\n| :first-letter | p:first-letter | 选择每个 <p\\> 元素的首字母。 | 1 |\n| :first-line | p:first-line | 选择每个 <p\\> 元素的首行。 | 1 |\n| :first-child | p:first-child | 选择属于父元素的第一个子元素的每个 <p\\> 元素。 | 2 |\n| :before | p:before | 在每个 <p\\> 元素的内容之前插入内容。 | 2 |\n| :after | p:after | 在每个 <p\\> 元素的内容之后插入内容。 | 2 |\n| :lang(language) | p:lang(it) | 选择带有以 \"it\" 开头的 lang 属性值的每个 <p\\> 元素。 | 2 |\n| element1~element2 | p~ul | 选择前面有 <p\\> 元素的每个 <ul\\> 元素。 | 3 |\n| [attribute^=value] | a[src^=\"https\"] | 选择其 src 属性值以 \"https\" 开头的每个 <a\\> 元素。 | 3 |\n| [attribute$=value] | a[src$=\".pdf\"] | 选择其 src 属性以 \".pdf\" 结尾的所有 <a\\> 元素。 | 3 |\n| [attribute*=value] | a[src*=\"abc\"] | 选择其 src 属性中包含 \"abc\" 子串的每个 <a\\> 元素。 | 3 |\n| :first-of-type | p:first-of-type | 选择属于其父元素的首个 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :last-of-type | p:last-of-type | 选择属于其父元素的最后 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :only-of-type | p:only-of-type | 选择属于其父元素唯一的 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :only-child | p:only-child | 选择属于其父元素的唯一子元素的每个 <p\\> 元素。 | 3 |\n| :nth-child(n) | p:nth-child(2) | 选择属于其父元素的第二个子元素的每个 <p\\> 元素。 | 3 |\n| :nth-last-child(n) | p:nth-last-child(2) | 同上，从最后一个子元素开始计数。 | 3 |\n| :nth-of-type(n) | p:nth-of-type(2) | 选择属于其父元素第二个 <p\\> 元素的每个 <p\\> 元素。 | 3 |\n| :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数。 | 3 |\n| :last-child | p:last-child | 选择属于其父元素最后一个子元素每个 <p\\> 元素。 | 3 |\n| :root | :root | 选择文档的根元素。 | 3 |\n| :empty | p:empty | 选择没有子元素的每个 <p\\> 元素（包括文本节点）。 | 3 |\n| :target | #news:target | 选择当前活动的 #news 元素。 | 3 |\n| :enabled | input:enabled | 选择每个启用的 <input\\> 元素。 | 3 |\n| :disabled | input:disabled | 选择每个禁用的 <input\\> 元素 | 3 |\n| :checked | input:checked | 选择每个被选中的 <input\\> 元素。 | 3 |\n| :not(selector) | :not(p) | 选择非 <p\\> 元素的每个元素。 | 3 |\n| ::selection | ::selection | 选择被用户选取的元素部分。| 3 |\n### 盒子布局\n所有HTML元素可以看作盒子，在CSS中，\"box model\"这一术语是用来设计和布局时使用。\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。\n盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。\n**Margin(外边距)** - 清除边框外的区域，外边距是透明的。\n**Border(边框)** - 围绕在内边距和内容外的边框。\n**Padding(内边距)** - 清除内容周围的区域，内边距是透明的。\n**Content(内容)** - 盒子的内容，显示文本和图像。\n### 弹性布局（Flex）\n弹性盒子是 CSS3 的一种新的布局模式。\nCSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。\n引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。\n### Hack\n简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack 为不同版本的浏览器定制编写不同的 CSS 效果。\n常用的CSS Hack 方式：\n1）、条件注释法：\n* <!--[if IE]> 只在 IE 下生效\n* <![endif]--> 这段文字只在IE浏览器显示\n* <!--[if IE 6]> 只在IE6下生效\n* <![endif]--> 这段文字只在IE6浏览器显示\n* <!--[if gte IE 6]> 只在IE6以上版本生效\n* <![endif]--> 这段文字只在IE6以上(包括)版本IE浏览器显示\n* <!--[if ! IE 8]> 只在IE8上不生效\n* <![endif]--> 这段文字在非IE8浏览器显示\n* <!--[if !IE]> 非IE浏览器生效\n* <![endif]--> 这段文字只在非IE浏览器显示\n\n2）、类内属性前缀法\nIE浏览器各版本 CSS hack 对照表： \n\n| hack | 写法  | IE6(S) | IE6(Q) | IE7(S) | IE7(Q) | IE8(S) | IE8(Q) | IE9(S) | IE9(Q) | IE10(S) | IE10(Q) |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| * | \\*color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| + | +color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| - | -color | Y | Y | N | N | N | N | N | N | N | N |\n| _ | \\_color | Y | Y | N | Y | N | Y | N | Y | N | N |\n| # | #color | Y | Y | Y | Y | N | Y | N | Y | N | Y |\n| \\0 | color:red\\0 | N | N | N | N | Y | N | Y | N | Y | N |\n| \\9\\0 | color:red\\9\\0 | N | N | N | N | N | N | Y | N | Y | N |\n| !important | color:blue !important;color:green; | N | N | Y | N | Y | N | Y | N | Y | Y |\n说明：在标准模式中:\n* “-″减号是IE6专有的hack\n* “\\9″ IE6/IE7/IE8/IE9/IE10都生效\n* “\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack\n* “\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack\n\n3）、选择器前缀法\n选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。\n* \\*html \\*前缀只对IE6生效\n* \\*+html \\*+前缀只对IE7生效\n* @media screen\\9{...}只对IE6/7生效\n* @media \\0screen {body { background: red; }}只对IE8有效\n* @media \\0screen\\,screen\\9{body { background: blue; }}只对IE6/7/8有效\n* @media screen\\0 {body { background: green; }} 只对IE8/9/10有效\n* @media screen and (min-width:0\\0) {body { background: gray; }} 只对IE9/10有效\n* @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等\n\n### LESS\nLess （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。\n\n### SASS\nSass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。\n\n### 媒体查询\n使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。\n**媒体类型：**\n\n| 值 | 描述 |\n| --- | --- |\n| all | 用于所有设备 |\n| aural | 已废弃。用于语音和声音合成器 |\n| braille | 已废弃。 应用于盲文触摸式反馈设备 |\n| embossed | 已废弃。 用于打印的盲人印刷设备 |\n| handheld | 已废弃。 用于掌上设备或更小的装置，如PDA和小型电话 |\n| print | 用于打印机和打印预览 |\n| projection | 已废弃。 用于投影设备 |\n| screen | 用于电脑屏幕，平板电脑，智能手机等。 |\n| speech | 应用于屏幕阅读器等发声设备 |\n| tty | 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 |\n| tv | 已废弃。 用于电视和网络电视 |\n\n**媒体功能**\n\n| 值 | 描述 |\n| --- | --- |\n| aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的比率 |\n| color | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0 |\n| color-index | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0 |\n| device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的比率。 |\n| device-height | 定义输出设备的屏幕可见高度。 |\n| device-width | 定义输出设备的屏幕可见宽度。 |\n| grid | 用来查询输出设备是否使用栅格或点阵。 |\n| height | 定义输出设备中的页面可见区域高度。 |\n| max-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。 |\n| max-color | 定义输出设备每一组彩色原件的最大个数。 |\n| max-color-index | 定义在输出设备的彩色查询表中的最大条目数。 |\n| max-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最大比率。 |\n| max-device-height | 定义输出设备的屏幕可见的最大高度。 |\n| max-device-width | 定义输出设备的屏幕最大可见宽度。 |\n| max-height | 定义输出设备中的页面最大可见区域高度。 |\n| max-monochrome | 定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。 |\n| max-resolution | 定义设备的最大分辨率。 |\n| max-width | 定义输出设备中的页面最大可见区域宽度。 |\n| min-aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的最小比率。 |\n| min-color | 定义输出设备每一组彩色原件的最小个数。 |\n| min-color-index | 定义在输出设备的彩色查询表中的最小条目数。 |\n| min-device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的最小比率。 |\n| min-device-width | 定义输出设备的屏幕最小可见宽度。 |\n| min-device-height | 定义输出设备的屏幕的最小可见高度。 |\n| min-height | 定义输出设备中的页面最小可见区域高度。 |\n| min-monochrome | 定义在一个单色框架缓冲区中每像素包含的最小单色原件个数 |\n| min-resolution | 定义设备的最小分辨率。 |\n| min-width | 定义输出设备中的页面最小可见区域宽度。 |\n| monochrome | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0 |\n| orientation | 定义输出设备中的页面可见区域高度是否大于或等于宽度。 |\n| resolution | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcmscan定义电视类设备的扫描工序。 |\n| width | 定义输出设备中的页面可见区域宽度。 |\n\n\n\n\n### 动画\n通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。\n**CSS3 @keyframes 规则**\n如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。\n\n## ECMAScript(Javascript)\nECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。\n**ECMAScript 历史**\n>1998年6月，ECMAScript 2.0版发布。\n>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。\n>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。\n>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。\n>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。\n>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。\n>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。\n>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。\n>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。\n>ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。TC39的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。\n>截止发布日期，JavaScript的官方名称是ECMAScript 2015，Ecma国际意在更频繁地发布包含小规模增量更新的新版本，下一版本将于2016年发布，命名为ECMAScript 2016。新版本将按照ECMAScript+年份的形式发布。\n>ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。\n>截止发布日期，没有一款完全支持ES6的JavaScript代理（无论是浏览器环境还是服务器环境），所以热衷于使用语言最新特性的开发者需要将ES6代码转译为ES5代码。等到主流浏览器完全实现ES6特性大概需要一年左右的时间，若想一睹各代理对于ES6特性的支持情况，我们推荐大家参考由 kangax 维护的 ECMAScript Compatibility Table 。\n>ECMAScript 2016的制定工作已经启动，许多 草案 已被提交到委员会，包括以下这些：异步方法、定型对象、并行JavaScript、类修饰符以及observables。虽然委员会正在积极评估这些特性，但我们无法预知它们的未来，其中一些会加入到下一版规范，另一些会加入未来的其它规范，剩下的将最终被遗弃。 TC39进程 解释了新特性从开始到最终被语言采用所经历的各种阶段。\n\n### 基础\n#### 内置类型\nJS中有七种内置类型，七种内置类型分为两大类：基本类型和对象（Object）。\n基本类型有六种： `null`，`undefined`，`boolean`，`number`，`string`，`symbol`。\n其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。`NaN` 也属于 `number` 类型，并且 `NaN` 不等于自身。\n对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型\n\n\n### 进阶\n### ES6\n### 正则表达式\n\n## 前端框架\n### jQuery\n### Anjular\n### React\n### Vue\n### bootstrap\n### antd\n### elementui\n\n## 小程序\n### 工具\n### 服务器\n### api\n### 组件\n### 云开发\n### 实战\n## 微信公众号\n\n### 对接微信服务器\n### 客服机器人\n### jssdk\n### 实战\n## Typescript\n\n## Node.js\n\n## 面试之道\n### 基础知识\n### 职业生涯\n### 一面/二面/三面\n### 开源看法、如何开源\n### 熟悉一门后端\n### 遇到问题如何解决\n\n## 浏览器\n### 事件机制\n### 时间循环机制\n### 渲染机制\n### 跨域\n### 存储\n### 性能\n\n## HTTP指南\n\n## 设计模式\n### 工厂模式\n### 抽象工厂模式\n### 建造者模式\n### 单例模式\n### 原型模式\n### 适配器模式\n### 装饰器模式\n### 代理模式\n### 外观模式\n### 桥接模式\n### 组合模式\n### 享元模式\n### 策略模式\n### 模板方法模式\n### 观察者模式\n### 迭代器模式\n### 职责链模式\n### 命令模式\n### 备忘录模式\n### 状态模式\n### 访问者模式\n### 中介者模式\n### 解释器模式\n\n## 工程化\n### 版本控制\n### mock\n### webpack\n### gulp\n### npm scripts\n### xxx-cli\n\n## 性能优化\n\n## 前端安全\n### 漏洞\n### XSS\n### CSRF\n### 持久化攻击\n### SQL注入\n### 爬虫对抗\n\n## 自动化测试\n### puppeteer\n### cypress\n\n## 工具调试\n### 编辑器IDE\n### chrome\n\n## 算法与数据结构\n### 基础知识\n### 复杂度\n### 数据结构\n### 搜索\n### 排序","slug":"前端知识总谱","published":1,"updated":"2019-09-18T09:02:36.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx94001yegqn89jngwcr","content":"<blockquote>\n<p>前端知识谱，从基础入手，往深层学习。一点点扎实自己，从基础沉淀。(持续更新)</p>\n</blockquote>\n<a id=\"more\"></a>\n<h1 id=\"前端总谱\"><a href=\"#前端总谱\" class=\"headerlink\" title=\"前端总谱\"></a>前端总谱</h1><h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h3 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h3><ol>\n<li>什么是BOM？<br>BOM（Browser Object Model），是<strong>浏览器对象模型</strong>。浏览器页面初始化时，会在内存创建一个全局对象，用来描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型。<br>不同于 DOM 的标准化组织是 W3C，JavaScript 的语法标准化组织是 ECMA，BOM 没有官方标准，它最初是 Netscape 浏览器标准的一部分，也就是说，对于现代浏览器，每个浏览器都有自己的 BOM 实现方法，所以直接使用 BOM 会有<strong>兼容性问题</strong>。</li>\n<li>BOM 包含哪些内容？<br>BOM 包含一个对象 <strong>window</strong>，<strong>window</strong> 中又包含 6 大模块，分别为：<br>1). <strong>document</strong> 对象：文档对象<br>2). <strong>frames</strong>：HTML自框架<br>3). <strong>history</strong>：页面的历史记录<br>4). <strong>location</strong>：当前页面的地址<br>5). <strong>navigator</strong>：浏览器相关信息<br>6). <strong>screen</strong>：用户显示屏幕相关参数</li>\n<li>各模块介绍<br>1). <strong>window</strong> 对象<br>BOM 的核心对象就是 window 对象，所有浏览器都支持 window 对象，它代表浏览器的窗口。<br>JavaScript 的所有全局对象、全局方法和全局变量全都自动被归为 window 对象的方法和属性，在调用这些方法和属性的时候可以省略 window。DOM 也是 window 对象的属性。<br><strong>window 对象的 size</strong><br>window 对象有两个用来定义浏览器窗口大小的属性（两个属性均返回以 px 像素为单位的数值）：window.innerHeight（返回浏览器窗口的高度） 和 window.innerWidth（返回浏览器窗口的宽度）<br>注意：浏览器窗口的视窗不包括工具栏和滚动条。<br>兼容问题：对于IE 5-8，innerWidth和innerHeight并不兼容，需要使用 document.documentElement.clientHeight / document.documentElement.clientWidth 或者 document.body.clientHeight / document.body.clientWidth。<br><strong>window 的方法</strong><br>window.open(url, target, specs, replace)：打开一个新窗口。四个参数（均为可选）。<br>window.close()：关闭当前窗口。<br>window.moveTo()：移动窗口到特定位置。<br>window.resizeTo()：修改窗口大小。<br>2). <strong>document</strong> 对象<br>document 对象是 HTML 文档的根节点。每一个元素都会生成对应的 DOM对象，由于元素之间存在层级关系，整个 HTML 代码解析结束后，会生成一个由不同节点组成的树形结构，成为 DOM 树。document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。<br>3). <strong>frames</strong><br>frame 指 HTML 子框架，即在浏览器里嵌入另一个窗口。父框架和子框架拥有独立的作用域和上下文。<br>window.frames 返回的是一个类数组的对象，对象的内容是当前页面中的 &lt;iframe> 元素。这些 &lt;iframe> 元素可以通过索引号来获得。<br>4). <strong>history</strong><br>window.history 对象包含浏览器的历史记录，window 可以省略。这些历史记录以<strong>栈（FIFO）</strong>的形式保存。页面前进则入栈，页面返回则出栈。<br><strong>history 的方法</strong><br>history.back()：跳转到历史记录中的前一个链接<br>history.forward()：跳转到历史记录中的后一个链接<br>5). <strong>location</strong><br>window.location 可以用户获取当前页面地址以及重定向到一个新的页面。<br><strong>location 的属性</strong><br>window.location.href： 返回当前页面的地址<br>window.location.hostname： 返回当前页面的域名<br>window.location.pathname： 返回当前页面的路径和文件名<br>window.location.protocol： 返回网页使用的协议（http: 还是 https:）<br>window.location.port： 返回当前页面的端口，如果页面使用的是默认端口（http:80,https:443），则大多数浏览器会显示为0或者不显示<br>window.location.assgin: 加载一个新的文档<br>6). <strong>navigator</strong><br>navigator 对象是一个只读对象，它用来描述浏览器本身的信息，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。<br>7). <strong>screen</strong><br>screen 提供了用户显示屏幕的相关属性，比如显示屏幕的宽度、高度，可用宽度、高度。<br><strong>screen 的属性</strong><br>screen.width：显示屏的宽度<br>screen.height：显示屏的高度<br>screen.availWidth： 屏幕的可用宽度<br>screen.availHeight： 屏幕的可用高度<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3>HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。<br>每个节点都拥有包含着关于节点某些信息的属性。这些属性是：<br>nodeName（节点名称）nodeValue（节点值）nodeType（节点类型）<br>根据W3C的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<br>1). 整个文档是一个文档节点<br>2). 每个 HTML 元素是元素节点<br>4). HTML 元素内的文本是文本节点<br>5). 每个 HTML 属性是属性节点<br>6). 注释是注释节点<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3>定义：首先是关于语义（Semantics）和默认样式的区别，默认样式是浏览器设定的一些常用tag的表现形式，语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。&lt;strong>,&lt;em>用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。<br>优点：语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3>HTML 4 增加了使事件在浏览器中触发动作的能力，比如当用户点击元素时启动 JavaScript。<br><strong>Window 事件属性</strong><br>针对 window 对象触发的事件（应用到 &lt;body> 标签）：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onafterprint</td>\n<td>文档打印之后运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onbeforeprint</td>\n<td>文档打印之前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td>文档卸载之前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>在错误发生时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onhaschange</td>\n<td>当文档已改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>页面结束加载之后触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmessage</td>\n<td>在消息被触发时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onoffline</td>\n<td>当文档离线时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ononline</td>\n<td>当文档上线时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpagehide</td>\n<td>当窗口隐藏时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpageshow</td>\n<td>当窗口成为可见时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpopstate</td>\n<td>当窗口历史记录改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onredo</td>\n<td>当文档执行撤销（redo）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onresize</td>\n<td>当浏览器窗口被调整大小时触发。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onstorage</td>\n<td>在 Web Storage 区域更新后运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onundo</td>\n<td>在文档执行 undo 时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onunload</td>\n<td>一旦页面已下载时触发（或者浏览器窗口已被关闭）。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Form 事件</strong><br>由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onblur</td>\n<td>元素失去焦点时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onchange</td>\n<td>在元素值被改变时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>oncontextmenu</td>\n<td>当上下文菜单被触发时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>当元素获得焦点时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onformchange</td>\n<td>在表单改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onforminput</td>\n<td>当表单获得用户输入时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oninput</td>\n<td>当元素获得用户输入时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oninvalid</td>\n<td>当元素无效时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onreset</td>\n<td>当表单中的重置按钮被点击时触发。HTML5 中不支持。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onselect</td>\n<td>在元素中文本被选中后触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onsubmit</td>\n<td>在提交表单时触发。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Keyboard 事件</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onkeydown</td>\n<td>在用户按下按键时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onkeypress</td>\n<td>在用户敲击按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onkeyup</td>\n<td>当用户释放按键时触发。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mouse 事件</strong><br>由鼠标或类似用户动作触发的事件：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onclick</td>\n<td>元素上发生鼠标点击时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>ondblclick</td>\n<td>元素上发生鼠标双击时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>ondrag</td>\n<td>元素被拖动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragend</td>\n<td>在拖动操作末端运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragenter</td>\n<td>当元素元素已被拖动到有效拖放区域时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragleave</td>\n<td>当元素离开有效拖放目标时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragover</td>\n<td>当元素在有效拖放目标上正在被拖动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragstart</td>\n<td>在拖动操作开端运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondrop</td>\n<td>当被拖元素正在被拖放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>当元素上按下鼠标按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>当鼠标指针移动到元素上时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>当鼠标指针移出元素时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>当鼠标指针移动到元素上时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>当在元素上释放鼠标按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmousewheel</td>\n<td>当鼠标滚轮正在被滚动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onscroll</td>\n<td>当元素滚动条被滚动时运行的脚本。</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Media 事件</strong><br>由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 &lt;audio>、&lt;embed>、&lt;img>、&lt;object> 以及 &lt;video>）:</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onabort</td>\n<td>在退出时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>oncanplay</td>\n<td>当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oncanplaythrough</td>\n<td>当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondurationchange</td>\n<td>当媒介长度改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onemptied</td>\n<td>当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onended</td>\n<td>当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>当在文件加载期间发生错误时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadeddata</td>\n<td>当媒介数据已加载时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadedmetadata</td>\n<td>当元数据（比如分辨率和时长）被加载时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td>在文件开始加载且未实际加载任何数据前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpause</td>\n<td>当媒介被用户或程序暂停时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onplay</td>\n<td>当媒介已就绪可以开始播放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onplaying</td>\n<td>当媒介已开始播放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td>当浏览器正在获取媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onratechange</td>\n<td>每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onreadystatechange</td>\n<td>每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onseeked</td>\n<td>当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onseeking</td>\n<td>当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onstalled</td>\n<td>在浏览器不论何种原因未能取回媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onsuspend</td>\n<td>在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ontimeupdate</td>\n<td>当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onvolumechange</td>\n<td>每当音量改变时（包括将音量设置为静音）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onwaiting</td>\n<td>当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><p>浏览器的渲染过程主要包括以下几步:<br>1). 解析HTML生成DOM树。<br>2). 解析CSS生成CSSOM规则树。<br>3). 将DOM树与CSSOM规则树合并在一起生成渲染树。<br>4). 遍历渲染树开始布局，计算每个节点的位置大小信息。<br>5). 将渲染树每个节点绘制到屏幕。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>例子</th>\n<th>例子描述</th>\n<th>CSS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>intro</td>\n<td>选择 class=”intro” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#firstname</td>\n<td>选择 id=”firstname” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element</td>\n<td>p</td>\n<td>选择所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element,element</td>\n<td>div,p</td>\n<td>选择所有 &lt;div> 元素和所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element element</td>\n<td>div p</td>\n<td>选择 &lt;div> 元素内部的所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择父元素为 &lt;div> 元素的所有 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接在 &lt;div> 元素之后的所有 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>[target]</td>\n<td>选择带有 target 属性所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>[target=_blank]</td>\n<td>选择 target=”_blank” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute~=value]</td>\n<td>[title~=flower]</td>\n<td>选择 title 属性包含单词 “flower” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:visited</td>\n<td>a:visited</td>\n<td>选择所有已被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:active</td>\n<td>a:active</td>\n<td>选择活动链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:hover</td>\n<td>a:hover</td>\n<td>选择鼠标指针位于其上的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>input:focus</td>\n<td>选择获得焦点的 input 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:first-letter</td>\n<td>p:first-letter</td>\n<td>选择每个 &lt;p> 元素的首字母。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-line</td>\n<td>p:first-line</td>\n<td>选择每个 &lt;p> 元素的首行。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>p:first-child</td>\n<td>选择属于父元素的第一个子元素的每个 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:before</td>\n<td>p:before</td>\n<td>在每个 &lt;p> 元素的内容之前插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:after</td>\n<td>p:after</td>\n<td>在每个 &lt;p> 元素的内容之后插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:lang(language)</td>\n<td>p:lang(it)</td>\n<td>选择带有以 “it” 开头的 lang 属性值的每个 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element1~element2</td>\n<td>p~ul</td>\n<td>选择前面有 &lt;p> 元素的每个 &lt;ul> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute^=value]</td>\n<td>a[src^=”https”]</td>\n<td>选择其 src 属性值以 “https” 开头的每个 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute$=value]</td>\n<td>a[src$=”.pdf”]</td>\n<td>选择其 src 属性以 “.pdf” 结尾的所有 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute*=value]</td>\n<td>a[src*=”abc”]</td>\n<td>选择其 src 属性中包含 “abc” 子串的每个 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:last-of-type</td>\n<td>p:last-of-type</td>\n<td>选择属于其父元素的最后 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:only-of-type</td>\n<td>p:only-of-type</td>\n<td>选择属于其父元素唯一的 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>p:only-child</td>\n<td>选择属于其父元素的唯一子元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-child(n)</td>\n<td>p:nth-child(2)</td>\n<td>选择属于其父元素的第二个子元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-last-child(n)</td>\n<td>p:nth-last-child(2)</td>\n<td>同上，从最后一个子元素开始计数。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-of-type(n)</td>\n<td>p:nth-of-type(2)</td>\n<td>选择属于其父元素第二个 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-last-of-type(n)</td>\n<td>p:nth-last-of-type(2)</td>\n<td>同上，但是从最后一个子元素开始计数。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>p:last-child</td>\n<td>选择属于其父元素最后一个子元素每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>:root</td>\n<td>选择文档的根元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>p:empty</td>\n<td>选择没有子元素的每个 &lt;p> 元素（包括文本节点）。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:target</td>\n<td>#news:target</td>\n<td>选择当前活动的 #news 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:enabled</td>\n<td>input:enabled</td>\n<td>选择每个启用的 &lt;input> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:disabled</td>\n<td>input:disabled</td>\n<td>选择每个禁用的 &lt;input> 元素</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>input:checked</td>\n<td>选择每个被选中的 &lt;input> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非 &lt;p> 元素的每个元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>::selection</td>\n<td>::selection</td>\n<td>选择被用户选取的元素部分。</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"盒子布局\"><a href=\"#盒子布局\" class=\"headerlink\" title=\"盒子布局\"></a>盒子布局</h3><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。<br><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。<br><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。<br><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</p>\n<h3 id=\"弹性布局（Flex）\"><a href=\"#弹性布局（Flex）\" class=\"headerlink\" title=\"弹性布局（Flex）\"></a>弹性布局（Flex）</h3><p>弹性盒子是 CSS3 的一种新的布局模式。<br>CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。<br>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>\n<h3 id=\"Hack\"><a href=\"#Hack\" class=\"headerlink\" title=\"Hack\"></a>Hack</h3><p>简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack 为不同版本的浏览器定制编写不同的 CSS 效果。<br>常用的CSS Hack 方式：<br>1）、条件注释法：</p>\n<ul>\n<li>&lt;!–[if IE]&gt; 只在 IE 下生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE浏览器显示</li>\n<li>&lt;!–[if IE 6]&gt; 只在IE6下生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE6浏览器显示</li>\n<li>&lt;!–[if gte IE 6]&gt; 只在IE6以上版本生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示</li>\n<li>&lt;!–[if ! IE 8]&gt; 只在IE8上不生效</li>\n<li>&lt;![endif]–&gt; 这段文字在非IE8浏览器显示</li>\n<li>&lt;!–[if !IE]&gt; 非IE浏览器生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在非IE浏览器显示</li>\n</ul>\n<p>2）、类内属性前缀法<br>IE浏览器各版本 CSS hack 对照表： </p>\n<table>\n<thead>\n<tr>\n<th>hack</th>\n<th>写法</th>\n<th>IE6(S)</th>\n<th>IE6(Q)</th>\n<th>IE7(S)</th>\n<th>IE7(Q)</th>\n<th>IE8(S)</th>\n<th>IE8(Q)</th>\n<th>IE9(S)</th>\n<th>IE9(Q)</th>\n<th>IE10(S)</th>\n<th>IE10(Q)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>*color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>+</td>\n<td>+color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>-</td>\n<td>-color</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>_</td>\n<td>_color</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>#</td>\n<td>#color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>color:red\\0</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>\\9\\0</td>\n<td>color:red\\9\\0</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>!important</td>\n<td>color:blue !important;color:green;</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p>说明：在标准模式中:</p>\n<ul>\n<li>“-″减号是IE6专有的hack</li>\n<li>“\\9″ IE6/IE7/IE8/IE9/IE10都生效</li>\n<li>“\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>\n<li>“\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack</li>\n</ul>\n<p>3）、选择器前缀法<br>选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。</p>\n<ul>\n<li>*html *前缀只对IE6生效</li>\n<li>*+html *+前缀只对IE7生效</li>\n<li>@media screen\\9{…}只对IE6/7生效</li>\n<li>@media \\0screen {body { background: red; }}只对IE8有效</li>\n<li>@media \\0screen\\,screen\\9{body { background: blue; }}只对IE6/7/8有效</li>\n<li>@media screen\\0 {body { background: green; }} 只对IE8/9/10有效</li>\n<li>@media screen and (min-width:0\\0) {body { background: gray; }} 只对IE9/10有效</li>\n<li>@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等</li>\n</ul>\n<h3 id=\"LESS\"><a href=\"#LESS\" class=\"headerlink\" title=\"LESS\"></a>LESS</h3><p>Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。</p>\n<h3 id=\"SASS\"><a href=\"#SASS\" class=\"headerlink\" title=\"SASS\"></a>SASS</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p>\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><p>使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br><strong>媒体类型：</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>all</td>\n<td>用于所有设备</td>\n</tr>\n<tr>\n<td>aural</td>\n<td>已废弃。用于语音和声音合成器</td>\n</tr>\n<tr>\n<td>braille</td>\n<td>已废弃。 应用于盲文触摸式反馈设备</td>\n</tr>\n<tr>\n<td>embossed</td>\n<td>已废弃。 用于打印的盲人印刷设备</td>\n</tr>\n<tr>\n<td>handheld</td>\n<td>已废弃。 用于掌上设备或更小的装置，如PDA和小型电话</td>\n</tr>\n<tr>\n<td>print</td>\n<td>用于打印机和打印预览</td>\n</tr>\n<tr>\n<td>projection</td>\n<td>已废弃。 用于投影设备</td>\n</tr>\n<tr>\n<td>screen</td>\n<td>用于电脑屏幕，平板电脑，智能手机等。</td>\n</tr>\n<tr>\n<td>speech</td>\n<td>应用于屏幕阅读器等发声设备</td>\n</tr>\n<tr>\n<td>tty</td>\n<td>已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备</td>\n</tr>\n<tr>\n<td>tv</td>\n<td>已废弃。 用于电视和网络电视</td>\n</tr>\n</tbody>\n</table>\n<p><strong>媒体功能</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>aspect-ratio</td>\n<td>定义输出设备中的页面可见区域宽度与高度的比率</td>\n</tr>\n<tr>\n<td>color</td>\n<td>定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0</td>\n</tr>\n<tr>\n<td>color-index</td>\n<td>定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td>\n</tr>\n<tr>\n<td>device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的比率。</td>\n</tr>\n<tr>\n<td>device-height</td>\n<td>定义输出设备的屏幕可见高度。</td>\n</tr>\n<tr>\n<td>device-width</td>\n<td>定义输出设备的屏幕可见宽度。</td>\n</tr>\n<tr>\n<td>grid</td>\n<td>用来查询输出设备是否使用栅格或点阵。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>定义输出设备中的页面可见区域高度。</td>\n</tr>\n<tr>\n<td>max-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>\n</tr>\n<tr>\n<td>max-color</td>\n<td>定义输出设备每一组彩色原件的最大个数。</td>\n</tr>\n<tr>\n<td>max-color-index</td>\n<td>定义在输出设备的彩色查询表中的最大条目数。</td>\n</tr>\n<tr>\n<td>max-device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>\n</tr>\n<tr>\n<td>max-device-height</td>\n<td>定义输出设备的屏幕可见的最大高度。</td>\n</tr>\n<tr>\n<td>max-device-width</td>\n<td>定义输出设备的屏幕最大可见宽度。</td>\n</tr>\n<tr>\n<td>max-height</td>\n<td>定义输出设备中的页面最大可见区域高度。</td>\n</tr>\n<tr>\n<td>max-monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。</td>\n</tr>\n<tr>\n<td>max-resolution</td>\n<td>定义设备的最大分辨率。</td>\n</tr>\n<tr>\n<td>max-width</td>\n<td>定义输出设备中的页面最大可见区域宽度。</td>\n</tr>\n<tr>\n<td>min-aspect-ratio</td>\n<td>定义输出设备中的页面可见区域宽度与高度的最小比率。</td>\n</tr>\n<tr>\n<td>min-color</td>\n<td>定义输出设备每一组彩色原件的最小个数。</td>\n</tr>\n<tr>\n<td>min-color-index</td>\n<td>定义在输出设备的彩色查询表中的最小条目数。</td>\n</tr>\n<tr>\n<td>min-device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最小比率。</td>\n</tr>\n<tr>\n<td>min-device-width</td>\n<td>定义输出设备的屏幕最小可见宽度。</td>\n</tr>\n<tr>\n<td>min-device-height</td>\n<td>定义输出设备的屏幕的最小可见高度。</td>\n</tr>\n<tr>\n<td>min-height</td>\n<td>定义输出设备中的页面最小可见区域高度。</td>\n</tr>\n<tr>\n<td>min-monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的最小单色原件个数</td>\n</tr>\n<tr>\n<td>min-resolution</td>\n<td>定义设备的最小分辨率。</td>\n</tr>\n<tr>\n<td>min-width</td>\n<td>定义输出设备中的页面最小可见区域宽度。</td>\n</tr>\n<tr>\n<td>monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td>\n</tr>\n<tr>\n<td>orientation</td>\n<td>定义输出设备中的页面可见区域高度是否大于或等于宽度。</td>\n</tr>\n<tr>\n<td>resolution</td>\n<td>定义设备的分辨率。如：96dpi, 300dpi, 118dpcmscan定义电视类设备的扫描工序。</td>\n</tr>\n<tr>\n<td>width</td>\n<td>定义输出设备中的页面可见区域宽度。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。<br><strong>CSS3 @keyframes 规则</strong><br>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p>\n<h2 id=\"ECMAScript-Javascript\"><a href=\"#ECMAScript-Javascript\" class=\"headerlink\" title=\"ECMAScript(Javascript)\"></a>ECMAScript(Javascript)</h2><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。<br><strong>ECMAScript 历史</strong></p>\n<blockquote>\n<p>1998年6月，ECMAScript 2.0版发布。<br>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。<br>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。<br>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。<br>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。<br>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。<br>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。<br>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。<br>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。<br>ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。TC39的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。<br>截止发布日期，JavaScript的官方名称是ECMAScript 2015，Ecma国际意在更频繁地发布包含小规模增量更新的新版本，下一版本将于2016年发布，命名为ECMAScript 2016。新版本将按照ECMAScript+年份的形式发布。<br>ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。<br>截止发布日期，没有一款完全支持ES6的JavaScript代理（无论是浏览器环境还是服务器环境），所以热衷于使用语言最新特性的开发者需要将ES6代码转译为ES5代码。等到主流浏览器完全实现ES6特性大概需要一年左右的时间，若想一睹各代理对于ES6特性的支持情况，我们推荐大家参考由 kangax 维护的 ECMAScript Compatibility Table 。<br>ECMAScript 2016的制定工作已经启动，许多 草案 已被提交到委员会，包括以下这些：异步方法、定型对象、并行JavaScript、类修饰符以及observables。虽然委员会正在积极评估这些特性，但我们无法预知它们的未来，其中一些会加入到下一版规范，另一些会加入未来的其它规范，剩下的将最终被遗弃。 TC39进程 解释了新特性从开始到最终被语言采用所经历的各种阶段。</p>\n</blockquote>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><p>JS中有七种内置类型，七种内置类型分为两大类：基本类型和对象（Object）。<br>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。<br>其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。<br>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型</p>\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><h2 id=\"前端框架\"><a href=\"#前端框架\" class=\"headerlink\" title=\"前端框架\"></a>前端框架</h2><h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><h3 id=\"Anjular\"><a href=\"#Anjular\" class=\"headerlink\" title=\"Anjular\"></a>Anjular</h3><h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><h3 id=\"bootstrap\"><a href=\"#bootstrap\" class=\"headerlink\" title=\"bootstrap\"></a>bootstrap</h3><h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><h3 id=\"elementui\"><a href=\"#elementui\" class=\"headerlink\" title=\"elementui\"></a>elementui</h3><h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h3><h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><h3 id=\"云开发\"><a href=\"#云开发\" class=\"headerlink\" title=\"云开发\"></a>云开发</h3><h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h2 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h2><h3 id=\"对接微信服务器\"><a href=\"#对接微信服务器\" class=\"headerlink\" title=\"对接微信服务器\"></a>对接微信服务器</h3><h3 id=\"客服机器人\"><a href=\"#客服机器人\" class=\"headerlink\" title=\"客服机器人\"></a>客服机器人</h3><h3 id=\"jssdk\"><a href=\"#jssdk\" class=\"headerlink\" title=\"jssdk\"></a>jssdk</h3><h3 id=\"实战-1\"><a href=\"#实战-1\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h2 id=\"Typescript\"><a href=\"#Typescript\" class=\"headerlink\" title=\"Typescript\"></a>Typescript</h2><h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><h2 id=\"面试之道\"><a href=\"#面试之道\" class=\"headerlink\" title=\"面试之道\"></a>面试之道</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h3 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h3><h3 id=\"一面-二面-三面\"><a href=\"#一面-二面-三面\" class=\"headerlink\" title=\"一面/二面/三面\"></a>一面/二面/三面</h3><h3 id=\"开源看法、如何开源\"><a href=\"#开源看法、如何开源\" class=\"headerlink\" title=\"开源看法、如何开源\"></a>开源看法、如何开源</h3><h3 id=\"熟悉一门后端\"><a href=\"#熟悉一门后端\" class=\"headerlink\" title=\"熟悉一门后端\"></a>熟悉一门后端</h3><h3 id=\"遇到问题如何解决\"><a href=\"#遇到问题如何解决\" class=\"headerlink\" title=\"遇到问题如何解决\"></a>遇到问题如何解决</h3><h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h3 id=\"事件机制\"><a href=\"#事件机制\" class=\"headerlink\" title=\"事件机制\"></a>事件机制</h3><h3 id=\"时间循环机制\"><a href=\"#时间循环机制\" class=\"headerlink\" title=\"时间循环机制\"></a>时间循环机制</h3><h3 id=\"渲染机制-1\"><a href=\"#渲染机制-1\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><h2 id=\"HTTP指南\"><a href=\"#HTTP指南\" class=\"headerlink\" title=\"HTTP指南\"></a>HTTP指南</h2><h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><h3 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h3><h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><h3 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h3><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><h3 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h3><h3 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h3><h3 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h3><h3 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h3><h3 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h3><h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><h3 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h3><h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h3><h3 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h3><h3 id=\"npm-scripts\"><a href=\"#npm-scripts\" class=\"headerlink\" title=\"npm scripts\"></a>npm scripts</h3><h3 id=\"xxx-cli\"><a href=\"#xxx-cli\" class=\"headerlink\" title=\"xxx-cli\"></a>xxx-cli</h3><h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h2 id=\"前端安全\"><a href=\"#前端安全\" class=\"headerlink\" title=\"前端安全\"></a>前端安全</h2><h3 id=\"漏洞\"><a href=\"#漏洞\" class=\"headerlink\" title=\"漏洞\"></a>漏洞</h3><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3><h3 id=\"持久化攻击\"><a href=\"#持久化攻击\" class=\"headerlink\" title=\"持久化攻击\"></a>持久化攻击</h3><h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><h3 id=\"爬虫对抗\"><a href=\"#爬虫对抗\" class=\"headerlink\" title=\"爬虫对抗\"></a>爬虫对抗</h3><h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><h3 id=\"puppeteer\"><a href=\"#puppeteer\" class=\"headerlink\" title=\"puppeteer\"></a>puppeteer</h3><h3 id=\"cypress\"><a href=\"#cypress\" class=\"headerlink\" title=\"cypress\"></a>cypress</h3><h2 id=\"工具调试\"><a href=\"#工具调试\" class=\"headerlink\" title=\"工具调试\"></a>工具调试</h2><h3 id=\"编辑器IDE\"><a href=\"#编辑器IDE\" class=\"headerlink\" title=\"编辑器IDE\"></a>编辑器IDE</h3><h3 id=\"chrome\"><a href=\"#chrome\" class=\"headerlink\" title=\"chrome\"></a>chrome</h3><h2 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h2><h3 id=\"基础知识-1\"><a href=\"#基础知识-1\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h3 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<blockquote>\n<p>前端知识谱，从基础入手，往深层学习。一点点扎实自己，从基础沉淀。(持续更新)</p>\n</blockquote>","more":"<h1 id=\"前端总谱\"><a href=\"#前端总谱\" class=\"headerlink\" title=\"前端总谱\"></a>前端总谱</h1><h2 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h2><h3 id=\"BOM\"><a href=\"#BOM\" class=\"headerlink\" title=\"BOM\"></a>BOM</h3><ol>\n<li>什么是BOM？<br>BOM（Browser Object Model），是<strong>浏览器对象模型</strong>。浏览器页面初始化时，会在内存创建一个全局对象，用来描述当前窗口的属性和状态，这个全局对象被称为浏览器对象模型。<br>不同于 DOM 的标准化组织是 W3C，JavaScript 的语法标准化组织是 ECMA，BOM 没有官方标准，它最初是 Netscape 浏览器标准的一部分，也就是说，对于现代浏览器，每个浏览器都有自己的 BOM 实现方法，所以直接使用 BOM 会有<strong>兼容性问题</strong>。</li>\n<li>BOM 包含哪些内容？<br>BOM 包含一个对象 <strong>window</strong>，<strong>window</strong> 中又包含 6 大模块，分别为：<br>1). <strong>document</strong> 对象：文档对象<br>2). <strong>frames</strong>：HTML自框架<br>3). <strong>history</strong>：页面的历史记录<br>4). <strong>location</strong>：当前页面的地址<br>5). <strong>navigator</strong>：浏览器相关信息<br>6). <strong>screen</strong>：用户显示屏幕相关参数</li>\n<li>各模块介绍<br>1). <strong>window</strong> 对象<br>BOM 的核心对象就是 window 对象，所有浏览器都支持 window 对象，它代表浏览器的窗口。<br>JavaScript 的所有全局对象、全局方法和全局变量全都自动被归为 window 对象的方法和属性，在调用这些方法和属性的时候可以省略 window。DOM 也是 window 对象的属性。<br><strong>window 对象的 size</strong><br>window 对象有两个用来定义浏览器窗口大小的属性（两个属性均返回以 px 像素为单位的数值）：window.innerHeight（返回浏览器窗口的高度） 和 window.innerWidth（返回浏览器窗口的宽度）<br>注意：浏览器窗口的视窗不包括工具栏和滚动条。<br>兼容问题：对于IE 5-8，innerWidth和innerHeight并不兼容，需要使用 document.documentElement.clientHeight / document.documentElement.clientWidth 或者 document.body.clientHeight / document.body.clientWidth。<br><strong>window 的方法</strong><br>window.open(url, target, specs, replace)：打开一个新窗口。四个参数（均为可选）。<br>window.close()：关闭当前窗口。<br>window.moveTo()：移动窗口到特定位置。<br>window.resizeTo()：修改窗口大小。<br>2). <strong>document</strong> 对象<br>document 对象是 HTML 文档的根节点。每一个元素都会生成对应的 DOM对象，由于元素之间存在层级关系，整个 HTML 代码解析结束后，会生成一个由不同节点组成的树形结构，成为 DOM 树。document 用于描述 DOM 树的状态和属性，并提供了很多操作 DOM 的 API。<br>3). <strong>frames</strong><br>frame 指 HTML 子框架，即在浏览器里嵌入另一个窗口。父框架和子框架拥有独立的作用域和上下文。<br>window.frames 返回的是一个类数组的对象，对象的内容是当前页面中的 &lt;iframe> 元素。这些 &lt;iframe> 元素可以通过索引号来获得。<br>4). <strong>history</strong><br>window.history 对象包含浏览器的历史记录，window 可以省略。这些历史记录以<strong>栈（FIFO）</strong>的形式保存。页面前进则入栈，页面返回则出栈。<br><strong>history 的方法</strong><br>history.back()：跳转到历史记录中的前一个链接<br>history.forward()：跳转到历史记录中的后一个链接<br>5). <strong>location</strong><br>window.location 可以用户获取当前页面地址以及重定向到一个新的页面。<br><strong>location 的属性</strong><br>window.location.href： 返回当前页面的地址<br>window.location.hostname： 返回当前页面的域名<br>window.location.pathname： 返回当前页面的路径和文件名<br>window.location.protocol： 返回网页使用的协议（http: 还是 https:）<br>window.location.port： 返回当前页面的端口，如果页面使用的是默认端口（http:80,https:443），则大多数浏览器会显示为0或者不显示<br>window.location.assgin: 加载一个新的文档<br>6). <strong>navigator</strong><br>navigator 对象是一个只读对象，它用来描述浏览器本身的信息，包括浏览器的名称、版本、语言、系统平台、用户特性字符串等信息。<br>7). <strong>screen</strong><br>screen 提供了用户显示屏幕的相关属性，比如显示屏幕的宽度、高度，可用宽度、高度。<br><strong>screen 的属性</strong><br>screen.width：显示屏的宽度<br>screen.height：显示屏的高度<br>screen.availWidth： 屏幕的可用宽度<br>screen.availHeight： 屏幕的可用高度<h3 id=\"DOM\"><a href=\"#DOM\" class=\"headerlink\" title=\"DOM\"></a>DOM</h3>HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。在 HTML DOM 中，所有事物都是节点。DOM 是被视为节点树的 HTML。<br>每个节点都拥有包含着关于节点某些信息的属性。这些属性是：<br>nodeName（节点名称）nodeValue（节点值）nodeType（节点类型）<br>根据W3C的 HTML DOM 标准，HTML 文档中的所有内容都是节点：<br>1). 整个文档是一个文档节点<br>2). 每个 HTML 元素是元素节点<br>4). HTML 元素内的文本是文本节点<br>5). 每个 HTML 属性是属性节点<br>6). 注释是注释节点<h3 id=\"语义化\"><a href=\"#语义化\" class=\"headerlink\" title=\"语义化\"></a>语义化</h3>定义：首先是关于语义（Semantics）和默认样式的区别，默认样式是浏览器设定的一些常用tag的表现形式，语义化的主要目的就是让大家直观的认识标签(markup)和属性(attribute)的用途和作用，很明显Hx系列看起来很像标题，因为拥有粗体和较大的字号。&lt;strong>,&lt;em>用来区别于其他文字，起到了强调的作用。至于列表和表格很明显的告诉你他们是做什么的。<br>优点：语义化的网页的好处，最主要的就是对搜索引擎友好，有了良好的结构和语义你的网页内容自然容易被搜索引擎抓取，你网站的推广便可以省下不少的功夫。语义 Web 技术有助于利用基于开放标准的技术，从数据、文档内容或应用代码中分离出意义。<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3>HTML 4 增加了使事件在浏览器中触发动作的能力，比如当用户点击元素时启动 JavaScript。<br><strong>Window 事件属性</strong><br>针对 window 对象触发的事件（应用到 &lt;body> 标签）：</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onafterprint</td>\n<td>文档打印之后运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onbeforeprint</td>\n<td>文档打印之前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onbeforeunload</td>\n<td>文档卸载之前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>在错误发生时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onhaschange</td>\n<td>当文档已改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>页面结束加载之后触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmessage</td>\n<td>在消息被触发时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onoffline</td>\n<td>当文档离线时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ononline</td>\n<td>当文档上线时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpagehide</td>\n<td>当窗口隐藏时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpageshow</td>\n<td>当窗口成为可见时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpopstate</td>\n<td>当窗口历史记录改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onredo</td>\n<td>当文档执行撤销（redo）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onresize</td>\n<td>当浏览器窗口被调整大小时触发。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onstorage</td>\n<td>在 Web Storage 区域更新后运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onundo</td>\n<td>在文档执行 undo 时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onunload</td>\n<td>一旦页面已下载时触发（或者浏览器窗口已被关闭）。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Form 事件</strong><br>由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中）：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onblur</td>\n<td>元素失去焦点时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onchange</td>\n<td>在元素值被改变时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>oncontextmenu</td>\n<td>当上下文菜单被触发时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>当元素获得焦点时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onformchange</td>\n<td>在表单改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onforminput</td>\n<td>当表单获得用户输入时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oninput</td>\n<td>当元素获得用户输入时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oninvalid</td>\n<td>当元素无效时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onreset</td>\n<td>当表单中的重置按钮被点击时触发。HTML5 中不支持。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onselect</td>\n<td>在元素中文本被选中后触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onsubmit</td>\n<td>在提交表单时触发。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Keyboard 事件</strong></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onkeydown</td>\n<td>在用户按下按键时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onkeypress</td>\n<td>在用户敲击按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onkeyup</td>\n<td>当用户释放按键时触发。</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Mouse 事件</strong><br>由鼠标或类似用户动作触发的事件：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onclick</td>\n<td>元素上发生鼠标点击时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>ondblclick</td>\n<td>元素上发生鼠标双击时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>ondrag</td>\n<td>元素被拖动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragend</td>\n<td>在拖动操作末端运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragenter</td>\n<td>当元素元素已被拖动到有效拖放区域时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragleave</td>\n<td>当元素离开有效拖放目标时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragover</td>\n<td>当元素在有效拖放目标上正在被拖动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondragstart</td>\n<td>在拖动操作开端运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondrop</td>\n<td>当被拖元素正在被拖放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>当元素上按下鼠标按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>当鼠标指针移动到元素上时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>当鼠标指针移出元素时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>当鼠标指针移动到元素上时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>当在元素上释放鼠标按钮时触发。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>onmousewheel</td>\n<td>当鼠标滚轮正在被滚动时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onscroll</td>\n<td>当元素滚动条被滚动时运行的脚本。</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Media 事件</strong><br>由媒介（比如视频、图像和音频）触发的事件（适用于所有 HTML 元素，但常见于媒介元素中，比如 &lt;audio>、&lt;embed>、&lt;img>、&lt;object> 以及 &lt;video>）:</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>描述</th>\n<th>H5新增</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onabort</td>\n<td>在退出时运行的脚本。</td>\n<td>否</td>\n</tr>\n<tr>\n<td>oncanplay</td>\n<td>当文件就绪可以开始播放时运行的脚本（缓冲已足够开始时）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>oncanplaythrough</td>\n<td>当媒介能够无需因缓冲而停止即可播放至结尾时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ondurationchange</td>\n<td>当媒介长度改变时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onemptied</td>\n<td>当发生故障并且文件突然不可用时运行的脚本（比如连接意外断开时）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onended</td>\n<td>当媒介已到达结尾时运行的脚本（可发送类似“感谢观看”之类的消息）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>当在文件加载期间发生错误时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadeddata</td>\n<td>当媒介数据已加载时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadedmetadata</td>\n<td>当元数据（比如分辨率和时长）被加载时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td>在文件开始加载且未实际加载任何数据前运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onpause</td>\n<td>当媒介被用户或程序暂停时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onplay</td>\n<td>当媒介已就绪可以开始播放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onplaying</td>\n<td>当媒介已开始播放时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td>当浏览器正在获取媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onratechange</td>\n<td>每当回放速率改变时运行的脚本（比如当用户切换到慢动作或快进模式）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onreadystatechange</td>\n<td>每当就绪状态改变时运行的脚本（就绪状态监测媒介数据的状态）。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onseeked</td>\n<td>当 seeking 属性设置为 false（指示定位已结束）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onseeking</td>\n<td>当 seeking 属性设置为 true（指示定位是活动的）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onstalled</td>\n<td>在浏览器不论何种原因未能取回媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onsuspend</td>\n<td>在媒介数据完全加载之前不论何种原因终止取回媒介数据时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>ontimeupdate</td>\n<td>当播放位置改变时（比如当用户快进到媒介中一个不同的位置时）运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onvolumechange</td>\n<td>每当音量改变时（包括将音量设置为静音）时运行的脚本。</td>\n<td>是</td>\n</tr>\n<tr>\n<td>onwaiting</td>\n<td>当媒介已停止播放但打算继续播放时（比如当媒介暂停已缓冲更多数据）运行脚本</td>\n<td>否</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><p>浏览器的渲染过程主要包括以下几步:<br>1). 解析HTML生成DOM树。<br>2). 解析CSS生成CSSOM规则树。<br>3). 将DOM树与CSSOM规则树合并在一起生成渲染树。<br>4). 遍历渲染树开始布局，计算每个节点的位置大小信息。<br>5). 将渲染树每个节点绘制到屏幕。</p>\n<h2 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h2><h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</p>\n<table>\n<thead>\n<tr>\n<th>选择器</th>\n<th>例子</th>\n<th>例子描述</th>\n<th>CSS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>.class</td>\n<td>intro</td>\n<td>选择 class=”intro” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>#id</td>\n<td>#firstname</td>\n<td>选择 id=”firstname” 的所有元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>选择所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element</td>\n<td>p</td>\n<td>选择所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element,element</td>\n<td>div,p</td>\n<td>选择所有 &lt;div> 元素和所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element element</td>\n<td>div p</td>\n<td>选择 &lt;div> 元素内部的所有 &lt;p> 元素。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>element&gt;element</td>\n<td>div&gt;p</td>\n<td>选择父元素为 &lt;div> 元素的所有 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element+element</td>\n<td>div+p</td>\n<td>选择紧接在 &lt;div> 元素之后的所有 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute]</td>\n<td>[target]</td>\n<td>选择带有 target 属性所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute=value]</td>\n<td>[target=_blank]</td>\n<td>选择 target=”_blank” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>[attribute~=value]</td>\n<td>[title~=flower]</td>\n<td>选择 title 属性包含单词 “flower” 的所有元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:link</td>\n<td>a:link</td>\n<td>选择所有未被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:visited</td>\n<td>a:visited</td>\n<td>选择所有已被访问的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:active</td>\n<td>a:active</td>\n<td>选择活动链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:hover</td>\n<td>a:hover</td>\n<td>选择鼠标指针位于其上的链接。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:focus</td>\n<td>input:focus</td>\n<td>选择获得焦点的 input 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:first-letter</td>\n<td>p:first-letter</td>\n<td>选择每个 &lt;p> 元素的首字母。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-line</td>\n<td>p:first-line</td>\n<td>选择每个 &lt;p> 元素的首行。</td>\n<td>1</td>\n</tr>\n<tr>\n<td>:first-child</td>\n<td>p:first-child</td>\n<td>选择属于父元素的第一个子元素的每个 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:before</td>\n<td>p:before</td>\n<td>在每个 &lt;p> 元素的内容之前插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:after</td>\n<td>p:after</td>\n<td>在每个 &lt;p> 元素的内容之后插入内容。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>:lang(language)</td>\n<td>p:lang(it)</td>\n<td>选择带有以 “it” 开头的 lang 属性值的每个 &lt;p> 元素。</td>\n<td>2</td>\n</tr>\n<tr>\n<td>element1~element2</td>\n<td>p~ul</td>\n<td>选择前面有 &lt;p> 元素的每个 &lt;ul> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute^=value]</td>\n<td>a[src^=”https”]</td>\n<td>选择其 src 属性值以 “https” 开头的每个 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute$=value]</td>\n<td>a[src$=”.pdf”]</td>\n<td>选择其 src 属性以 “.pdf” 结尾的所有 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>[attribute*=value]</td>\n<td>a[src*=”abc”]</td>\n<td>选择其 src 属性中包含 “abc” 子串的每个 &lt;a> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:first-of-type</td>\n<td>p:first-of-type</td>\n<td>选择属于其父元素的首个 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:last-of-type</td>\n<td>p:last-of-type</td>\n<td>选择属于其父元素的最后 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:only-of-type</td>\n<td>p:only-of-type</td>\n<td>选择属于其父元素唯一的 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:only-child</td>\n<td>p:only-child</td>\n<td>选择属于其父元素的唯一子元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-child(n)</td>\n<td>p:nth-child(2)</td>\n<td>选择属于其父元素的第二个子元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-last-child(n)</td>\n<td>p:nth-last-child(2)</td>\n<td>同上，从最后一个子元素开始计数。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-of-type(n)</td>\n<td>p:nth-of-type(2)</td>\n<td>选择属于其父元素第二个 &lt;p> 元素的每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:nth-last-of-type(n)</td>\n<td>p:nth-last-of-type(2)</td>\n<td>同上，但是从最后一个子元素开始计数。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:last-child</td>\n<td>p:last-child</td>\n<td>选择属于其父元素最后一个子元素每个 &lt;p> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:root</td>\n<td>:root</td>\n<td>选择文档的根元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:empty</td>\n<td>p:empty</td>\n<td>选择没有子元素的每个 &lt;p> 元素（包括文本节点）。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:target</td>\n<td>#news:target</td>\n<td>选择当前活动的 #news 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:enabled</td>\n<td>input:enabled</td>\n<td>选择每个启用的 &lt;input> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:disabled</td>\n<td>input:disabled</td>\n<td>选择每个禁用的 &lt;input> 元素</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:checked</td>\n<td>input:checked</td>\n<td>选择每个被选中的 &lt;input> 元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>:not(selector)</td>\n<td>:not(p)</td>\n<td>选择非 &lt;p> 元素的每个元素。</td>\n<td>3</td>\n</tr>\n<tr>\n<td>::selection</td>\n<td>::selection</td>\n<td>选择被用户选取的元素部分。</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"盒子布局\"><a href=\"#盒子布局\" class=\"headerlink\" title=\"盒子布局\"></a>盒子布局</h3><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。<br>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。<br>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。<br><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。<br><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。<br><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。<br><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</p>\n<h3 id=\"弹性布局（Flex）\"><a href=\"#弹性布局（Flex）\" class=\"headerlink\" title=\"弹性布局（Flex）\"></a>弹性布局（Flex）</h3><p>弹性盒子是 CSS3 的一种新的布局模式。<br>CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。<br>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>\n<h3 id=\"Hack\"><a href=\"#Hack\" class=\"headerlink\" title=\"Hack\"></a>Hack</h3><p>简单的说，CSS hack 的目的就是使你的 CSS 代码兼容不同的浏览器。当然，我们也可以反过来利用 CSS hack 为不同版本的浏览器定制编写不同的 CSS 效果。<br>常用的CSS Hack 方式：<br>1）、条件注释法：</p>\n<ul>\n<li>&lt;!–[if IE]&gt; 只在 IE 下生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE浏览器显示</li>\n<li>&lt;!–[if IE 6]&gt; 只在IE6下生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE6浏览器显示</li>\n<li>&lt;!–[if gte IE 6]&gt; 只在IE6以上版本生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示</li>\n<li>&lt;!–[if ! IE 8]&gt; 只在IE8上不生效</li>\n<li>&lt;![endif]–&gt; 这段文字在非IE8浏览器显示</li>\n<li>&lt;!–[if !IE]&gt; 非IE浏览器生效</li>\n<li>&lt;![endif]–&gt; 这段文字只在非IE浏览器显示</li>\n</ul>\n<p>2）、类内属性前缀法<br>IE浏览器各版本 CSS hack 对照表： </p>\n<table>\n<thead>\n<tr>\n<th>hack</th>\n<th>写法</th>\n<th>IE6(S)</th>\n<th>IE6(Q)</th>\n<th>IE7(S)</th>\n<th>IE7(Q)</th>\n<th>IE8(S)</th>\n<th>IE8(Q)</th>\n<th>IE9(S)</th>\n<th>IE9(Q)</th>\n<th>IE10(S)</th>\n<th>IE10(Q)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td>*color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>+</td>\n<td>+color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>-</td>\n<td>-color</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>_</td>\n<td>_color</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>N</td>\n</tr>\n<tr>\n<td>#</td>\n<td>#color</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>\\0</td>\n<td>color:red\\0</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>\\9\\0</td>\n<td>color:red\\9\\0</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>!important</td>\n<td>color:blue !important;color:green;</td>\n<td>N</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>N</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n</tbody>\n</table>\n<p>说明：在标准模式中:</p>\n<ul>\n<li>“-″减号是IE6专有的hack</li>\n<li>“\\9″ IE6/IE7/IE8/IE9/IE10都生效</li>\n<li>“\\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack</li>\n<li>“\\9\\0″ 只对IE9/IE10生效，是IE9/10的hack</li>\n</ul>\n<p>3）、选择器前缀法<br>选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。</p>\n<ul>\n<li>*html *前缀只对IE6生效</li>\n<li>*+html *+前缀只对IE7生效</li>\n<li>@media screen\\9{…}只对IE6/7生效</li>\n<li>@media \\0screen {body { background: red; }}只对IE8有效</li>\n<li>@media \\0screen\\,screen\\9{body { background: blue; }}只对IE6/7/8有效</li>\n<li>@media screen\\0 {body { background: green; }} 只对IE8/9/10有效</li>\n<li>@media screen and (min-width:0\\0) {body { background: gray; }} 只对IE9/10有效</li>\n<li>@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等</li>\n</ul>\n<h3 id=\"LESS\"><a href=\"#LESS\" class=\"headerlink\" title=\"LESS\"></a>LESS</h3><p>Less （Leaner Style Sheets 的缩写） 是一门向后兼容的 CSS 扩展语言。这里呈现的是 Less 的官方文档（中文版），包含了 Less 语言以及利用 JavaScript 开发的用于将 Less 样式转换成 CSS 样式的 Less.js 工具。</p>\n<h3 id=\"SASS\"><a href=\"#SASS\" class=\"headerlink\" title=\"SASS\"></a>SASS</h3><p>Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p>\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><p>使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。<br><strong>媒体类型：</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>all</td>\n<td>用于所有设备</td>\n</tr>\n<tr>\n<td>aural</td>\n<td>已废弃。用于语音和声音合成器</td>\n</tr>\n<tr>\n<td>braille</td>\n<td>已废弃。 应用于盲文触摸式反馈设备</td>\n</tr>\n<tr>\n<td>embossed</td>\n<td>已废弃。 用于打印的盲人印刷设备</td>\n</tr>\n<tr>\n<td>handheld</td>\n<td>已废弃。 用于掌上设备或更小的装置，如PDA和小型电话</td>\n</tr>\n<tr>\n<td>print</td>\n<td>用于打印机和打印预览</td>\n</tr>\n<tr>\n<td>projection</td>\n<td>已废弃。 用于投影设备</td>\n</tr>\n<tr>\n<td>screen</td>\n<td>用于电脑屏幕，平板电脑，智能手机等。</td>\n</tr>\n<tr>\n<td>speech</td>\n<td>应用于屏幕阅读器等发声设备</td>\n</tr>\n<tr>\n<td>tty</td>\n<td>已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备</td>\n</tr>\n<tr>\n<td>tv</td>\n<td>已废弃。 用于电视和网络电视</td>\n</tr>\n</tbody>\n</table>\n<p><strong>媒体功能</strong></p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>aspect-ratio</td>\n<td>定义输出设备中的页面可见区域宽度与高度的比率</td>\n</tr>\n<tr>\n<td>color</td>\n<td>定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于0</td>\n</tr>\n<tr>\n<td>color-index</td>\n<td>定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于0</td>\n</tr>\n<tr>\n<td>device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的比率。</td>\n</tr>\n<tr>\n<td>device-height</td>\n<td>定义输出设备的屏幕可见高度。</td>\n</tr>\n<tr>\n<td>device-width</td>\n<td>定义输出设备的屏幕可见宽度。</td>\n</tr>\n<tr>\n<td>grid</td>\n<td>用来查询输出设备是否使用栅格或点阵。</td>\n</tr>\n<tr>\n<td>height</td>\n<td>定义输出设备中的页面可见区域高度。</td>\n</tr>\n<tr>\n<td>max-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>\n</tr>\n<tr>\n<td>max-color</td>\n<td>定义输出设备每一组彩色原件的最大个数。</td>\n</tr>\n<tr>\n<td>max-color-index</td>\n<td>定义在输出设备的彩色查询表中的最大条目数。</td>\n</tr>\n<tr>\n<td>max-device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最大比率。</td>\n</tr>\n<tr>\n<td>max-device-height</td>\n<td>定义输出设备的屏幕可见的最大高度。</td>\n</tr>\n<tr>\n<td>max-device-width</td>\n<td>定义输出设备的屏幕最大可见宽度。</td>\n</tr>\n<tr>\n<td>max-height</td>\n<td>定义输出设备中的页面最大可见区域高度。</td>\n</tr>\n<tr>\n<td>max-monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的最大单色原件个数。</td>\n</tr>\n<tr>\n<td>max-resolution</td>\n<td>定义设备的最大分辨率。</td>\n</tr>\n<tr>\n<td>max-width</td>\n<td>定义输出设备中的页面最大可见区域宽度。</td>\n</tr>\n<tr>\n<td>min-aspect-ratio</td>\n<td>定义输出设备中的页面可见区域宽度与高度的最小比率。</td>\n</tr>\n<tr>\n<td>min-color</td>\n<td>定义输出设备每一组彩色原件的最小个数。</td>\n</tr>\n<tr>\n<td>min-color-index</td>\n<td>定义在输出设备的彩色查询表中的最小条目数。</td>\n</tr>\n<tr>\n<td>min-device-aspect-ratio</td>\n<td>定义输出设备的屏幕可见宽度与高度的最小比率。</td>\n</tr>\n<tr>\n<td>min-device-width</td>\n<td>定义输出设备的屏幕最小可见宽度。</td>\n</tr>\n<tr>\n<td>min-device-height</td>\n<td>定义输出设备的屏幕的最小可见高度。</td>\n</tr>\n<tr>\n<td>min-height</td>\n<td>定义输出设备中的页面最小可见区域高度。</td>\n</tr>\n<tr>\n<td>min-monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的最小单色原件个数</td>\n</tr>\n<tr>\n<td>min-resolution</td>\n<td>定义设备的最小分辨率。</td>\n</tr>\n<tr>\n<td>min-width</td>\n<td>定义输出设备中的页面最小可见区域宽度。</td>\n</tr>\n<tr>\n<td>monochrome</td>\n<td>定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于0</td>\n</tr>\n<tr>\n<td>orientation</td>\n<td>定义输出设备中的页面可见区域高度是否大于或等于宽度。</td>\n</tr>\n<tr>\n<td>resolution</td>\n<td>定义设备的分辨率。如：96dpi, 300dpi, 118dpcmscan定义电视类设备的扫描工序。</td>\n</tr>\n<tr>\n<td>width</td>\n<td>定义输出设备中的页面可见区域宽度。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><p>通过 CSS3，我们能够创建动画，这可以在许多网页中取代动画图片、Flash 动画以及 JavaScript。<br><strong>CSS3 @keyframes 规则</strong><br>如需在 CSS3 中创建动画，您需要学习 @keyframes 规则。@keyframes 规则用于创建动画。在 @keyframes 中规定某项 CSS 样式，就能创建由当前样式逐渐改为新样式的动画效果。</p>\n<h2 id=\"ECMAScript-Javascript\"><a href=\"#ECMAScript-Javascript\" class=\"headerlink\" title=\"ECMAScript(Javascript)\"></a>ECMAScript(Javascript)</h2><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，所以它可以理解为是JavaScript的一个标准,但实际上后两者是ECMA-262标准的实现和扩展。<br><strong>ECMAScript 历史</strong></p>\n<blockquote>\n<p>1998年6月，ECMAScript 2.0版发布。<br>1999年12月，ECMAScript 3.0版发布，成为JavaScript的通行标准，得到了广泛支持。<br>2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以Yahoo、Microsoft、Google为首的大公司，反对JavaScript的大幅升级，主张小幅改动；以JavaScript创造者Brendan Eich为首的Mozilla公司，则坚持当前的草案。<br>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。<br>2009年12月，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。<br>2011年6月，ECMAscript 5.1版发布，并且成为ISO国际标准（ISO/IEC 16262:2011）。<br>2013年3月，ECMAScript 6草案冻结，不再添加新功能。新的功能设想将被放到ECMAScript 7。<br>2013年12月，ECMAScript 6草案发布。然后是12个月的讨论期，听取各方反馈。<br>2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015。<br>ECMA的第39号技术专家委员会（Technical Committee 39，简称TC39）负责制订ECMAScript标准，成员包括Microsoft、Mozilla、Google等大公司。TC39的总体考虑是，ES5与ES3基本保持兼容，较大的语法修正和新功能加入，将由JavaScript.next完成。<br>截止发布日期，JavaScript的官方名称是ECMAScript 2015，Ecma国际意在更频繁地发布包含小规模增量更新的新版本，下一版本将于2016年发布，命名为ECMAScript 2016。新版本将按照ECMAScript+年份的形式发布。<br>ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。<br>截止发布日期，没有一款完全支持ES6的JavaScript代理（无论是浏览器环境还是服务器环境），所以热衷于使用语言最新特性的开发者需要将ES6代码转译为ES5代码。等到主流浏览器完全实现ES6特性大概需要一年左右的时间，若想一睹各代理对于ES6特性的支持情况，我们推荐大家参考由 kangax 维护的 ECMAScript Compatibility Table 。<br>ECMAScript 2016的制定工作已经启动，许多 草案 已被提交到委员会，包括以下这些：异步方法、定型对象、并行JavaScript、类修饰符以及observables。虽然委员会正在积极评估这些特性，但我们无法预知它们的未来，其中一些会加入到下一版规范，另一些会加入未来的其它规范，剩下的将最终被遗弃。 TC39进程 解释了新特性从开始到最终被语言采用所经历的各种阶段。</p>\n</blockquote>\n<h3 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h3><h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><p>JS中有七种内置类型，七种内置类型分为两大类：基本类型和对象（Object）。<br>基本类型有六种： <code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>symbol</code>。<br>其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。<br>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型</p>\n<h3 id=\"进阶\"><a href=\"#进阶\" class=\"headerlink\" title=\"进阶\"></a>进阶</h3><h3 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h3><h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><h2 id=\"前端框架\"><a href=\"#前端框架\" class=\"headerlink\" title=\"前端框架\"></a>前端框架</h2><h3 id=\"jQuery\"><a href=\"#jQuery\" class=\"headerlink\" title=\"jQuery\"></a>jQuery</h3><h3 id=\"Anjular\"><a href=\"#Anjular\" class=\"headerlink\" title=\"Anjular\"></a>Anjular</h3><h3 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h3><h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><h3 id=\"bootstrap\"><a href=\"#bootstrap\" class=\"headerlink\" title=\"bootstrap\"></a>bootstrap</h3><h3 id=\"antd\"><a href=\"#antd\" class=\"headerlink\" title=\"antd\"></a>antd</h3><h3 id=\"elementui\"><a href=\"#elementui\" class=\"headerlink\" title=\"elementui\"></a>elementui</h3><h2 id=\"小程序\"><a href=\"#小程序\" class=\"headerlink\" title=\"小程序\"></a>小程序</h2><h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><h3 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h3><h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h3><h3 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h3><h3 id=\"云开发\"><a href=\"#云开发\" class=\"headerlink\" title=\"云开发\"></a>云开发</h3><h3 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h2 id=\"微信公众号\"><a href=\"#微信公众号\" class=\"headerlink\" title=\"微信公众号\"></a>微信公众号</h2><h3 id=\"对接微信服务器\"><a href=\"#对接微信服务器\" class=\"headerlink\" title=\"对接微信服务器\"></a>对接微信服务器</h3><h3 id=\"客服机器人\"><a href=\"#客服机器人\" class=\"headerlink\" title=\"客服机器人\"></a>客服机器人</h3><h3 id=\"jssdk\"><a href=\"#jssdk\" class=\"headerlink\" title=\"jssdk\"></a>jssdk</h3><h3 id=\"实战-1\"><a href=\"#实战-1\" class=\"headerlink\" title=\"实战\"></a>实战</h3><h2 id=\"Typescript\"><a href=\"#Typescript\" class=\"headerlink\" title=\"Typescript\"></a>Typescript</h2><h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><h2 id=\"面试之道\"><a href=\"#面试之道\" class=\"headerlink\" title=\"面试之道\"></a>面试之道</h2><h3 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h3 id=\"职业生涯\"><a href=\"#职业生涯\" class=\"headerlink\" title=\"职业生涯\"></a>职业生涯</h3><h3 id=\"一面-二面-三面\"><a href=\"#一面-二面-三面\" class=\"headerlink\" title=\"一面/二面/三面\"></a>一面/二面/三面</h3><h3 id=\"开源看法、如何开源\"><a href=\"#开源看法、如何开源\" class=\"headerlink\" title=\"开源看法、如何开源\"></a>开源看法、如何开源</h3><h3 id=\"熟悉一门后端\"><a href=\"#熟悉一门后端\" class=\"headerlink\" title=\"熟悉一门后端\"></a>熟悉一门后端</h3><h3 id=\"遇到问题如何解决\"><a href=\"#遇到问题如何解决\" class=\"headerlink\" title=\"遇到问题如何解决\"></a>遇到问题如何解决</h3><h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><h3 id=\"事件机制\"><a href=\"#事件机制\" class=\"headerlink\" title=\"事件机制\"></a>事件机制</h3><h3 id=\"时间循环机制\"><a href=\"#时间循环机制\" class=\"headerlink\" title=\"时间循环机制\"></a>时间循环机制</h3><h3 id=\"渲染机制-1\"><a href=\"#渲染机制-1\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><h3 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h3><h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><h2 id=\"HTTP指南\"><a href=\"#HTTP指南\" class=\"headerlink\" title=\"HTTP指南\"></a>HTTP指南</h2><h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h3 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h3><h3 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h3><h3 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h3><h3 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h3><h3 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h3><h3 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h3><h3 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h3><h3 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h3><h3 id=\"模板方法模式\"><a href=\"#模板方法模式\" class=\"headerlink\" title=\"模板方法模式\"></a>模板方法模式</h3><h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><h3 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h3><h3 id=\"职责链模式\"><a href=\"#职责链模式\" class=\"headerlink\" title=\"职责链模式\"></a>职责链模式</h3><h3 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h3><h3 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h3><h3 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h3><h3 id=\"访问者模式\"><a href=\"#访问者模式\" class=\"headerlink\" title=\"访问者模式\"></a>访问者模式</h3><h3 id=\"中介者模式\"><a href=\"#中介者模式\" class=\"headerlink\" title=\"中介者模式\"></a>中介者模式</h3><h3 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h3><h2 id=\"工程化\"><a href=\"#工程化\" class=\"headerlink\" title=\"工程化\"></a>工程化</h2><h3 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h3><h3 id=\"mock\"><a href=\"#mock\" class=\"headerlink\" title=\"mock\"></a>mock</h3><h3 id=\"webpack\"><a href=\"#webpack\" class=\"headerlink\" title=\"webpack\"></a>webpack</h3><h3 id=\"gulp\"><a href=\"#gulp\" class=\"headerlink\" title=\"gulp\"></a>gulp</h3><h3 id=\"npm-scripts\"><a href=\"#npm-scripts\" class=\"headerlink\" title=\"npm scripts\"></a>npm scripts</h3><h3 id=\"xxx-cli\"><a href=\"#xxx-cli\" class=\"headerlink\" title=\"xxx-cli\"></a>xxx-cli</h3><h2 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h2><h2 id=\"前端安全\"><a href=\"#前端安全\" class=\"headerlink\" title=\"前端安全\"></a>前端安全</h2><h3 id=\"漏洞\"><a href=\"#漏洞\" class=\"headerlink\" title=\"漏洞\"></a>漏洞</h3><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3><h3 id=\"持久化攻击\"><a href=\"#持久化攻击\" class=\"headerlink\" title=\"持久化攻击\"></a>持久化攻击</h3><h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><h3 id=\"爬虫对抗\"><a href=\"#爬虫对抗\" class=\"headerlink\" title=\"爬虫对抗\"></a>爬虫对抗</h3><h2 id=\"自动化测试\"><a href=\"#自动化测试\" class=\"headerlink\" title=\"自动化测试\"></a>自动化测试</h2><h3 id=\"puppeteer\"><a href=\"#puppeteer\" class=\"headerlink\" title=\"puppeteer\"></a>puppeteer</h3><h3 id=\"cypress\"><a href=\"#cypress\" class=\"headerlink\" title=\"cypress\"></a>cypress</h3><h2 id=\"工具调试\"><a href=\"#工具调试\" class=\"headerlink\" title=\"工具调试\"></a>工具调试</h2><h3 id=\"编辑器IDE\"><a href=\"#编辑器IDE\" class=\"headerlink\" title=\"编辑器IDE\"></a>编辑器IDE</h3><h3 id=\"chrome\"><a href=\"#chrome\" class=\"headerlink\" title=\"chrome\"></a>chrome</h3><h2 id=\"算法与数据结构\"><a href=\"#算法与数据结构\" class=\"headerlink\" title=\"算法与数据结构\"></a>算法与数据结构</h2><h3 id=\"基础知识-1\"><a href=\"#基础知识-1\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h3><h3 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h3><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><h3 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h3><h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3>"},{"title":"vuex学习","date":"2019-09-30T01:13:15.000Z","_content":"\nVuex 学习， 内容摘抄自[Vuex](https://vuex.vuejs.org/zh/)\n<!-- more -->\n\n## 什么是 Vuex？\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n“单向数据流” 示意图如下：\n![单向数据流示意图](./flow.png)\n* state：驱动应用的数据源\n* view：以声明方式将 state 映射到视图\n* actions：响应在 view 上的用户输入导致的状态变化\n\nVuex 的基本思想是通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，使我们的代码变得更结构化且易维护。\n\nVuex 示意图如下：\n![vuex](./vuex.png)\n\n## 什么情况下我应该使用 Vuex？\n如果应用足够简单，不需要开发大型单页应用，则不需要使用Vuex。\n如果打算构建一个中大型单页应用，则需要考虑如何更好地在组件外部管理状态，这时，Vuex将是一个很好的选择。\n\n## 核心 Store\n每一个 Vuex 应用的核心就是 Store（仓库）。“Store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。\n\nVuex 和单纯的全局对象有以下两点不同：\n1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n## 最简单的 Store\n```\n// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\nstore.commit('increment')\nconsole.log(store.state.count) // -> 1\n```\n\n# State\n## 单一状态树\nVuex 使用**单一状态树**，用一个对象包含全部应用层级状态。每个应用仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n\n## 如何在 Vue 组件中获取 Vuex 的状态\n1. 通过计算属性返回状态\n由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n```\n// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n每当 ```store.state.count``` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。\n然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。\n\n2. 通过 store 选项\nVuex 通过 ```store``` 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 ```Vue.use(Vuex)```）：\n```\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n通过在根实例中注册 ```store``` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 ```this.$store``` 访问到。让我们更新下 ```Counter``` 的实现：\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n3. ```mapState``` 辅助函数\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 ```mapState``` 辅助函数帮助我们生成计算属性，让你少按几次键：\n```\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n当映射的计算属性的名称与 ```state``` 的子节点名称相同时，我们也可以给 ```mapState``` 传一个字符串数组。\n```\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n## 对象展开运算符\n```mapState``` 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 ```computed``` 属性。但是自从有了对象展开运算符（现处于 ECMAScript 提案 stage-4 阶段），我们可以极大地简化写法：\n\n## 组件仍然保有局部状态\n使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。\n\n# Getter\n有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 接受 state 作为其第一个参数：\n```\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n## 如何访问 Getter\n1. 通过属性访问\nGetter 会暴露为 ```store.getters``` 对象，你可以以属性的形式访问这些值：\n```\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\nGetter 也可以接受其他 getter 作为第二个参数：\n```\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n```\n```\nstore.getters.doneTodosCount // -> 1\n```\n我们可以很容易地在任何组件中使用它：\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\n2. 通过方法访问\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\n```\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n```\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n\n3. ```mapGetters``` 辅助函数\n```mapGetters``` 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n```\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n# Mutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 ```store.commit``` 方法：\n```\nstore.commit('increment')\n```\n\n## 提交载荷（Payload）\n你可以向 store.commit 传入额外的参数，即 mutation 的 **载荷（payload）**：\n```\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n```\nstore.commit('increment', 10)\n```\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读:\n```\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n```\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n## 对象风格的提交方式\n提交 mutation 的另一种方式是直接使用包含 type 属性的对象：\n```\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n```\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n## Mutation 需遵守 Vue 的响应规则\n既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\n1. 最好提前在你的 store 中初始化好所有所需属性。\n2. 当需要在对象上添加新属性时，你应该\n    * 使用 Vue.set(obj, 'newProp', 123), 或者\n    * 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：\n    ```\n    state.obj = { ...state.obj, newProp: 123 }\n    ```\n\n## 使用常量替代 Mutation 事件类型\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n```\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。\n\n## Mutation 必须是同步函数\n一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：\n```\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n## 如何在组件中提交 Mutation\n你可以在组件中使用 ```this.$store.commit('xxx')``` 提交 mutation，或者使用 ```mapMutations``` 辅助函数将组件中的 methods 映射为 ```store.commit``` 调用（需要在根节点注入 ```store```）。\n```\nimport { mapMutations } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n# Action\nAction 类似于 mutation，不同在于：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n让我们来注册一个简单的 action：\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 ```context.commit``` 提交一个 mutation，或者通过 ```context.state``` 和 ```context.getters``` 来获取 state 和 getters。\n\n实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 ```commit``` 很多次的时候）：\n```\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n## 分发 Action\nAction 通过 ```store.dispatch``` 方法触发：\n```\nstore.dispatch('increment')\n```\n乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation **必须同步执行**这个限制么？Action 就不受约束！我们可以在 action 内部执行**异步**操作：\n```\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\nActions 支持同样的载荷方式和对象方式进行分发：\n```\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n来看一个更加实际的购物车示例，涉及到**调用异步 API** 和**分发多重 mutation**：\n```\nactions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。\n\n## 如何在组件中分发 Action\n你在组件中使用 ```this.$store.dispatch('xxx')``` 分发 action，或者使用 ```mapActions``` 辅助函数将组件的 methods 映射为 ```store.dispatch``` 调用（需要先在根节点注入 store）：\n```\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n## 组合 Action\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n首先，你需要明白 ```store.dispatch``` 可以处理被触发的 action 的处理函数返回的 Promise，并且 ```store.dispatch``` 仍旧返回 Promise：\n```\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n现在你可以：\n```\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n在另外一个 action 中也可以：\n```\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n最后，如果我们利用 async / await，我们可以如下组合 action：\n```\n// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n> 一个 ```store.dispatch``` 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n\n# Module\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成```模块（module）```。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n## 模块的局部状态\n对于模块内部的 mutation 和 getter，接收的第一个参数是```模块的局部状态对象```。\n```\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n同样，对于模块内部的 action，局部状态通过 ```context.state``` 暴露出来，根节点状态则为 ```context.rootState```：\n```\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n```\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n## 命名空间\n默认情况下，模块内部的 action、mutation 和 getter 是注册在```全局命名空间```的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n```\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n启用了命名空间的 getter 和 action 会收到局部化的 ```getter```，```dispatch``` 和 ```commit```。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 ```namespaced``` 属性后不需要修改模块内的代码。\n\n## 在带命名空间的模块内访问全局内容（Global Assets）\n如果你希望使用全局 ```state``` 和 ```getter```，```rootState``` 和 ```rootGetters``` 会作为第三和第四参数传入 getter，也会通过 ```context``` 对象的属性传入 action。\n\n若需要在全局命名空间内分发 action 或提交 mutation，将 ```{ root: true } ```作为第三参数传给 dispatch 或 commit 即可。\n```\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n## 在带命名空间的模块注册全局 action\n若需要在带命名空间的模块注册全局 action，你可添加 ```root: true```，并将这个 action 的定义放在函数 handler 中。例如：\n```\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n## 带命名空间的绑定函数\n当使用 ```mapState```, ```mapGetters```, ```mapActions``` 和 ```mapMutations``` 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：\n```\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：\n```\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n而且，你可以通过使用 ```createNamespacedHelpers``` 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：\n```\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```","source":"_posts/vuex学习.md","raw":"---\ntitle: vuex学习\ndate: 2019-09-30 09:13:15\ntags: vue\ncategories: JS\n---\n\nVuex 学习， 内容摘抄自[Vuex](https://vuex.vuejs.org/zh/)\n<!-- more -->\n\n## 什么是 Vuex？\n\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\n“单向数据流” 示意图如下：\n![单向数据流示意图](./flow.png)\n* state：驱动应用的数据源\n* view：以声明方式将 state 映射到视图\n* actions：响应在 view 上的用户输入导致的状态变化\n\nVuex 的基本思想是通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，使我们的代码变得更结构化且易维护。\n\nVuex 示意图如下：\n![vuex](./vuex.png)\n\n## 什么情况下我应该使用 Vuex？\n如果应用足够简单，不需要开发大型单页应用，则不需要使用Vuex。\n如果打算构建一个中大型单页应用，则需要考虑如何更好地在组件外部管理状态，这时，Vuex将是一个很好的选择。\n\n## 核心 Store\n每一个 Vuex 应用的核心就是 Store（仓库）。“Store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。\n\nVuex 和单纯的全局对象有以下两点不同：\n1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\n\n## 最简单的 Store\n```\n// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\nstore.commit('increment')\nconsole.log(store.state.count) // -> 1\n```\n\n# State\n## 单一状态树\nVuex 使用**单一状态树**，用一个对象包含全部应用层级状态。每个应用仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。\n\n## 如何在 Vue 组件中获取 Vuex 的状态\n1. 通过计算属性返回状态\n由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n```\n// 创建一个 Counter 组件\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return store.state.count\n    }\n  }\n}\n```\n每当 ```store.state.count``` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。\n然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。\n\n2. 通过 store 选项\nVuex 通过 ```store``` 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 ```Vue.use(Vuex)```）：\n```\nconst app = new Vue({\n  el: '#app',\n  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\n  store,\n  components: { Counter },\n  template: `\n    <div class=\"app\">\n      <counter></counter>\n    </div>\n  `\n})\n```\n通过在根实例中注册 ```store``` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 ```this.$store``` 访问到。让我们更新下 ```Counter``` 的实现：\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n3. ```mapState``` 辅助函数\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 ```mapState``` 辅助函数帮助我们生成计算属性，让你少按几次键：\n```\n// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n\n    // 传字符串参数 'count' 等同于 `state => state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n```\n当映射的计算属性的名称与 ```state``` 的子节点名称相同时，我们也可以给 ```mapState``` 传一个字符串数组。\n```\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])\n```\n\n## 对象展开运算符\n```mapState``` 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 ```computed``` 属性。但是自从有了对象展开运算符（现处于 ECMAScript 提案 stage-4 阶段），我们可以极大地简化写法：\n\n## 组件仍然保有局部状态\n使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。\n\n# Getter\n有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n```\n如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。\n\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nGetter 接受 state 作为其第一个参数：\n```\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: '...', done: true },\n      { id: 2, text: '...', done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n```\n\n## 如何访问 Getter\n1. 通过属性访问\nGetter 会暴露为 ```store.getters``` 对象，你可以以属性的形式访问这些值：\n```\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\n```\nGetter 也可以接受其他 getter 作为第二个参数：\n```\ngetters: {\n  // ...\n  doneTodosCount: (state, getters) => {\n    return getters.doneTodos.length\n  }\n}\n```\n```\nstore.getters.doneTodosCount // -> 1\n```\n我们可以很容易地在任何组件中使用它：\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.doneTodosCount\n  }\n}\n```\n注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。\n\n2. 通过方法访问\n你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。\n```\ngetters: {\n  // ...\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n```\n```\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\n```\n注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。\n\n3. ```mapGetters``` 辅助函数\n```mapGetters``` 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：\n```\nimport { mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n```\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```\nmapGetters({\n  // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n# Mutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 **事件类型 (type)** 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n```\n你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 ```store.commit``` 方法：\n```\nstore.commit('increment')\n```\n\n## 提交载荷（Payload）\n你可以向 store.commit 传入额外的参数，即 mutation 的 **载荷（payload）**：\n```\n// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n```\n```\nstore.commit('increment', 10)\n```\n在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读:\n```\n// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n```\nstore.commit('increment', {\n  amount: 10\n})\n```\n\n## 对象风格的提交方式\n提交 mutation 的另一种方式是直接使用包含 type 属性的对象：\n```\nstore.commit({\n  type: 'increment',\n  amount: 10\n})\n```\n当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：\n```\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n```\n\n## Mutation 需遵守 Vue 的响应规则\n既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：\n1. 最好提前在你的 store 中初始化好所有所需属性。\n2. 当需要在对象上添加新属性时，你应该\n    * 使用 Vue.set(obj, 'newProp', 123), 或者\n    * 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：\n    ```\n    state.obj = { ...state.obj, newProp: 123 }\n    ```\n\n## 使用常量替代 Mutation 事件类型\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n```\n// mutation-types.js\nexport const SOME_MUTATION = 'SOME_MUTATION'\n```\n```\n// store.js\nimport Vuex from 'vuex'\nimport { SOME_MUTATION } from './mutation-types'\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n```\n用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。\n\n## Mutation 必须是同步函数\n一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：\n```\nmutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() => {\n      state.count++\n    })\n  }\n}\n```\n现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\n\n## 如何在组件中提交 Mutation\n你可以在组件中使用 ```this.$store.commit('xxx')``` 提交 mutation，或者使用 ```mapMutations``` 辅助函数将组件中的 methods 映射为 ```store.commit``` 调用（需要在根节点注入 ```store```）。\n```\nimport { mapMutations } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\n    ]),\n    ...mapMutations({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n    })\n  }\n}\n```\n\n# Action\nAction 类似于 mutation，不同在于：\n* Action 提交的是 mutation，而不是直接变更状态。\n* Action 可以包含任意异步操作。\n让我们来注册一个简单的 action：\n```\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) {\n      context.commit('increment')\n    }\n  }\n})\n```\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 ```context.commit``` 提交一个 mutation，或者通过 ```context.state``` 和 ```context.getters``` 来获取 state 和 getters。\n\n实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 ```commit``` 很多次的时候）：\n```\nactions: {\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n## 分发 Action\nAction 通过 ```store.dispatch``` 方法触发：\n```\nstore.dispatch('increment')\n```\n乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation **必须同步执行**这个限制么？Action 就不受约束！我们可以在 action 内部执行**异步**操作：\n```\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\nActions 支持同样的载荷方式和对象方式进行分发：\n```\n// 以载荷形式分发\nstore.dispatch('incrementAsync', {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n来看一个更加实际的购物车示例，涉及到**调用异步 API** 和**分发多重 mutation**：\n```\nactions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () => commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () => commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n```\n注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。\n\n## 如何在组件中分发 Action\n你在组件中使用 ```this.$store.dispatch('xxx')``` 分发 action，或者使用 ```mapActions``` 辅助函数将组件的 methods 映射为 ```store.dispatch``` 调用（需要先在根节点注入 store）：\n```\nimport { mapActions } from 'vuex'\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n\n      // `mapActions` 也支持载荷：\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\n    ]),\n    ...mapActions({\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n    })\n  }\n}\n```\n\n## 组合 Action\nAction 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？\n\n首先，你需要明白 ```store.dispatch``` 可以处理被触发的 action 的处理函数返回的 Promise，并且 ```store.dispatch``` 仍旧返回 Promise：\n```\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n```\n现在你可以：\n```\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n```\n在另外一个 action 中也可以：\n```\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n最后，如果我们利用 async / await，我们可以如下组合 action：\n```\n// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n> 一个 ```store.dispatch``` 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n\n# Module\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成```模块（module）```。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n```\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n## 模块的局部状态\n对于模块内部的 mutation 和 getter，接收的第一个参数是```模块的局部状态对象```。\n```\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n```\n同样，对于模块内部的 action，局部状态通过 ```context.state``` 暴露出来，根节点状态则为 ```context.rootState```：\n```\nconst moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n```\nconst moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n## 命名空间\n默认情况下，模块内部的 action、mutation 和 getter 是注册在```全局命名空间```的——这样使得多个模块能够对同一 mutation 或 action 作出响应。\n\n如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：\n```\nconst store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -> getters['account/isAdmin']\n      },\n      actions: {\n        login () { ... } // -> dispatch('account/login')\n      },\n      mutations: {\n        login () { ... } // -> commit('account/login')\n      },\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -> getters['account/profile']\n          }\n        },\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n          state: { ... },\n          getters: {\n            popular () { ... } // -> getters['account/posts/popular']\n          }\n        }\n      }\n    }\n  }\n})\n```\n启用了命名空间的 getter 和 action 会收到局部化的 ```getter```，```dispatch``` 和 ```commit```。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 ```namespaced``` 属性后不需要修改模块内的代码。\n\n## 在带命名空间的模块内访问全局内容（Global Assets）\n如果你希望使用全局 ```state``` 和 ```getter```，```rootState``` 和 ```rootGetters``` 会作为第三和第四参数传入 getter，也会通过 ```context``` 对象的属性传入 action。\n\n若需要在全局命名空间内分发 action 或提交 mutation，将 ```{ root: true } ```作为第三参数传给 dispatch 或 commit 即可。\n```\nmodules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -> 'foo/someOtherGetter'\n        rootGetters.someOtherGetter // -> 'someOtherGetter'\n      },\n      someOtherGetter: state => { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -> 'foo/someGetter'\n        rootGetters.someGetter // -> 'someGetter'\n\n        dispatch('someOtherAction') // -> 'foo/someOtherAction'\n        dispatch('someOtherAction', null, { root: true }) // -> 'someOtherAction'\n\n        commit('someMutation') // -> 'foo/someMutation'\n        commit('someMutation', null, { root: true }) // -> 'someMutation'\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n```\n\n## 在带命名空间的模块注册全局 action\n若需要在带命名空间的模块注册全局 action，你可添加 ```root: true```，并将这个 action 的定义放在函数 handler 中。例如：\n```\n{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch('someAction')\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -> 'someAction'\n        }\n      }\n    }\n  }\n}\n```\n\n## 带命名空间的绑定函数\n当使用 ```mapState```, ```mapGetters```, ```mapActions``` 和 ```mapMutations``` 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：\n```\ncomputed: {\n  ...mapState({\n    a: state => state.some.nested.module.a,\n    b: state => state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    'some/nested/module/foo', // -> this['some/nested/module/foo']()\n    'some/nested/module/bar' // -> this['some/nested/module/bar']()\n  ])\n}\n```\n对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：\n```\ncomputed: {\n  ...mapState('some/nested/module', {\n    a: state => state.a,\n    b: state => state.b\n  })\n},\nmethods: {\n  ...mapActions('some/nested/module', [\n    'foo', // -> this.foo()\n    'bar' // -> this.bar()\n  ])\n}\n```\n而且，你可以通过使用 ```createNamespacedHelpers``` 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：\n```\nimport { createNamespacedHelpers } from 'vuex'\n\nconst { mapState, mapActions } = createNamespacedHelpers('some/nested/module')\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state => state.a,\n      b: state => state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      'foo',\n      'bar'\n    ])\n  }\n}\n```","slug":"vuex学习","published":1,"updated":"2019-10-08T09:00:15.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck1jzmx97001zegqnk5s9i00e","content":"<p>Vuex 学习， 内容摘抄自<a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vuex</a><br><a id=\"more\"></a></p>\n<h2 id=\"什么是-Vuex？\"><a href=\"#什么是-Vuex？\" class=\"headerlink\" title=\"什么是 Vuex？\"></a>什么是 Vuex？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>“单向数据流” 示意图如下：<br><img src=\"./flow.png\" alt=\"单向数据流示意图\"></p>\n<ul>\n<li>state：驱动应用的数据源</li>\n<li>view：以声明方式将 state 映射到视图</li>\n<li>actions：响应在 view 上的用户输入导致的状态变化</li>\n</ul>\n<p>Vuex 的基本思想是通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，使我们的代码变得更结构化且易维护。</p>\n<p>Vuex 示意图如下：<br><img src=\"./vuex.png\" alt=\"vuex\"></p>\n<h2 id=\"什么情况下我应该使用-Vuex？\"><a href=\"#什么情况下我应该使用-Vuex？\" class=\"headerlink\" title=\"什么情况下我应该使用 Vuex？\"></a>什么情况下我应该使用 Vuex？</h2><p>如果应用足够简单，不需要开发大型单页应用，则不需要使用Vuex。<br>如果打算构建一个中大型单页应用，则需要考虑如何更好地在组件外部管理状态，这时，Vuex将是一个很好的选择。</p>\n<h2 id=\"核心-Store\"><a href=\"#核心-Store\" class=\"headerlink\" title=\"核心 Store\"></a>核心 Store</h2><p>每一个 Vuex 应用的核心就是 Store（仓库）。“Store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。</p>\n<p>Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n<h2 id=\"最简单的-Store\"><a href=\"#最简单的-Store\" class=\"headerlink\" title=\"最简单的 Store\"></a>最简单的 Store</h2><pre><code>// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\nstore.commit(&#39;increment&#39;)\nconsole.log(store.state.count) // -&gt; 1\n</code></pre><h1 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h1><h2 id=\"单一状态树\"><a href=\"#单一状态树\" class=\"headerlink\" title=\"单一状态树\"></a>单一状态树</h2><p>Vuex 使用<strong>单一状态树</strong>，用一个对象包含全部应用层级状态。每个应用仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>\n<h2 id=\"如何在-Vue-组件中获取-Vuex-的状态\"><a href=\"#如何在-Vue-组件中获取-Vuex-的状态\" class=\"headerlink\" title=\"如何在 Vue 组件中获取 Vuex 的状态\"></a>如何在 Vue 组件中获取 Vuex 的状态</h2><ol>\n<li><p>通过计算属性返回状态<br>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p>\n<pre><code>// 创建一个 Counter 组件\nconst Counter = {\ntemplate: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\ncomputed: {\n count () {\n   return store.state.count\n }\n}\n}\n</code></pre><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。<br>然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>\n</li>\n<li><p>通过 store 选项<br>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p>\n<pre><code>const app = new Vue({\nel: &#39;#app&#39;,\n// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\nstore,\ncomponents: { Counter },\ntemplate: `\n &lt;div class=&quot;app&quot;&gt;\n   &lt;counter&gt;&lt;/counter&gt;\n &lt;/div&gt;\n`\n})\n</code></pre><p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 <code>Counter</code> 的实现：</p>\n<pre><code>const Counter = {\ntemplate: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\ncomputed: {\n count () {\n   return this.$store.state.count\n }\n}\n}\n</code></pre></li>\n<li><p><code>mapState</code> 辅助函数<br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>\n<pre><code>// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from &#39;vuex&#39;\nexport default {\n// ...\ncomputed: mapState({\n // 箭头函数可使代码更简练\n count: state =&gt; state.count,\n\n // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`\n countAlias: &#39;count&#39;,\n\n // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n countPlusLocalState (state) {\n   return state.count + this.localCount\n }\n})\n}\n</code></pre><p>当映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>\n<pre><code>computed: mapState([\n// 映射 this.count 为 store.state.count\n&#39;count&#39;\n])\n</code></pre></li>\n</ol>\n<h2 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h2><p><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是自从有了对象展开运算符（现处于 ECMAScript 提案 stage-4 阶段），我们可以极大地简化写法：</p>\n<h2 id=\"组件仍然保有局部状态\"><a href=\"#组件仍然保有局部状态\" class=\"headerlink\" title=\"组件仍然保有局部状态\"></a>组件仍然保有局部状态</h2><p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>\n<h1 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h1><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre><code>computed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo =&gt; todo.done).length\n  }\n}\n</code></pre><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>Getter 接受 state 作为其第一个参数：</p>\n<pre><code>const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n</code></pre><h2 id=\"如何访问-Getter\"><a href=\"#如何访问-Getter\" class=\"headerlink\" title=\"如何访问 Getter\"></a>如何访问 Getter</h2><ol>\n<li><p>通过属性访问<br>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &#39;...&#39;, done: true }]\n</code></pre><p>Getter 也可以接受其他 getter 作为第二个参数：</p>\n<pre><code>getters: {\n// ...\ndoneTodosCount: (state, getters) =&gt; {\n return getters.doneTodos.length\n}\n}\n</code></pre><pre><code>store.getters.doneTodosCount // -&gt; 1\n</code></pre><p>我们可以很容易地在任何组件中使用它：</p>\n<pre><code>computed: {\ndoneTodosCount () {\n return this.$store.getters.doneTodosCount\n}\n}\n</code></pre><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n</li>\n<li><p>通过方法访问<br>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<pre><code>getters: {\n// ...\ngetTodoById: (state) =&gt; (id) =&gt; {\n return state.todos.find(todo =&gt; todo.id === id)\n}\n}\n</code></pre><pre><code>store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }\n</code></pre><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n</li>\n<li><p><code>mapGetters</code> 辅助函数<br><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<pre><code>import { mapGetters } from &#39;vuex&#39;\nexport default {\n// ...\ncomputed: {\n// 使用对象展开运算符将 getter 混入 computed 对象中\n ...mapGetters([\n   &#39;doneTodosCount&#39;,\n   &#39;anotherGetter&#39;,\n   // ...\n ])\n}\n}\n</code></pre><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<pre><code>mapGetters({\n// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\ndoneCount: &#39;doneTodosCount&#39;\n})\n</code></pre></li>\n</ol>\n<h1 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h1><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre><code>const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n</code></pre><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <code>store.commit</code> 方法：</p>\n<pre><code>store.commit(&#39;increment&#39;)\n</code></pre><h2 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h2><p>你可以向 store.commit 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n</code></pre><pre><code>store.commit(&#39;increment&#39;, 10)\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读:</p>\n<pre><code>// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre><pre><code>store.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre><h2 id=\"对象风格的提交方式\"><a href=\"#对象风格的提交方式\" class=\"headerlink\" title=\"对象风格的提交方式\"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</p>\n<pre><code>store.commit({\n  type: &#39;increment&#39;,\n  amount: 10\n})\n</code></pre><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>\n<pre><code>mutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre><h2 id=\"Mutation-需遵守-Vue-的响应规则\"><a href=\"#Mutation-需遵守-Vue-的响应规则\" class=\"headerlink\" title=\"Mutation 需遵守 Vue 的响应规则\"></a>Mutation 需遵守 Vue 的响应规则</h2><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>\n<ol>\n<li>最好提前在你的 store 中初始化好所有所需属性。</li>\n<li>当需要在对象上添加新属性时，你应该<ul>\n<li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li>\n<li>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：<pre><code>state.obj = { ...state.obj, newProp: 123 }\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用常量替代-Mutation-事件类型\"><a href=\"#使用常量替代-Mutation-事件类型\" class=\"headerlink\" title=\"使用常量替代 Mutation 事件类型\"></a>使用常量替代 Mutation 事件类型</h2><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<pre><code>// mutation-types.js\nexport const SOME_MUTATION = &#39;SOME_MUTATION&#39;\n</code></pre><pre><code>// store.js\nimport Vuex from &#39;vuex&#39;\nimport { SOME_MUTATION } from &#39;./mutation-types&#39;\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n</code></pre><p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>\n<h2 id=\"Mutation-必须是同步函数\"><a href=\"#Mutation-必须是同步函数\" class=\"headerlink\" title=\"Mutation 必须是同步函数\"></a>Mutation 必须是同步函数</h2><p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>\n<pre><code>mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() =&gt; {\n      state.count++\n    })\n  }\n}\n</code></pre><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h2 id=\"如何在组件中提交-Mutation\"><a href=\"#如何在组件中提交-Mutation\" class=\"headerlink\" title=\"如何在组件中提交 Mutation\"></a>如何在组件中提交 Mutation</h2><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>\n<pre><code>import { mapMutations } from &#39;vuex&#39;\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n\n      // `mapMutations` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapMutations({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h1 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h1><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。<br>让我们来注册一个简单的 action：<pre><code>const store = new Vuex.Store({\nstate: {\n  count: 0\n},\nmutations: {\n  increment (state) {\n    state.count++\n  }\n},\nactions: {\n  increment (context) {\n    context.commit(&#39;increment&#39;)\n  }\n}\n})\n</code></pre>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</li>\n</ul>\n<p>实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre><code>actions: {\n  increment ({ commit }) {\n    commit(&#39;increment&#39;)\n  }\n}\n</code></pre><h2 id=\"分发-Action\"><a href=\"#分发-Action\" class=\"headerlink\" title=\"分发 Action\"></a>分发 Action</h2><p>Action 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre><code>store.dispatch(&#39;increment&#39;)\n</code></pre><p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation <strong>必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p>\n<pre><code>actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() =&gt; {\n      commit(&#39;increment&#39;)\n    }, 1000)\n  }\n}\n</code></pre><p>Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<pre><code>// 以载荷形式分发\nstore.dispatch(&#39;incrementAsync&#39;, {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: &#39;incrementAsync&#39;,\n  amount: 10\n})\n</code></pre><p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和<strong>分发多重 mutation</strong>：</p>\n<pre><code>actions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () =&gt; commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n</code></pre><p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>\n<h2 id=\"如何在组件中分发-Action\"><a href=\"#如何在组件中分发-Action\" class=\"headerlink\" title=\"如何在组件中分发 Action\"></a>如何在组件中分发 Action</h2><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）：</p>\n<pre><code>import { mapActions } from &#39;vuex&#39;\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n\n      // `mapActions` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapActions({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h2 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h2><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<pre><code>actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        commit(&#39;someMutation&#39;)\n        resolve()\n      }, 1000)\n    })\n  }\n}\n</code></pre><p>现在你可以：</p>\n<pre><code>store.dispatch(&#39;actionA&#39;).then(() =&gt; {\n  // ...\n})\n</code></pre><p>在另外一个 action 中也可以：</p>\n<pre><code>actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch(&#39;actionA&#39;).then(() =&gt; {\n      commit(&#39;someOtherMutation&#39;)\n    })\n  }\n}\n</code></pre><p>最后，如果我们利用 async / await，我们可以如下组合 action：</p>\n<pre><code>// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit(&#39;gotData&#39;, await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成\n    commit(&#39;gotOtherData&#39;, await getOtherData())\n  }\n}\n</code></pre><blockquote>\n<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>\n</blockquote>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<code>模块（module）</code>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre><code>const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre><h2 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h2><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<code>模块的局部状态对象</code>。</p>\n<pre><code>const moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n</code></pre><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre><code>const moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit(&#39;increment&#39;)\n      }\n    }\n  }\n}\n</code></pre><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre><code>const moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n</code></pre><h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<code>全局命名空间</code>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre><code>const store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -&gt; getters[&#39;account/isAdmin&#39;]\n      },\n      actions: {\n        login () { ... } // -&gt; dispatch(&#39;account/login&#39;)\n      },\n      mutations: {\n        login () { ... } // -&gt; commit(&#39;account/login&#39;)\n      },\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -&gt; getters[&#39;account/profile&#39;]\n          }\n        },\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n          state: { ... },\n          getters: {\n            popular () { ... } // -&gt; getters[&#39;account/posts/popular&#39;]\n          }\n        }\n      }\n    }\n  }\n})\n</code></pre><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>\n<h2 id=\"在带命名空间的模块内访问全局内容（Global-Assets）\"><a href=\"#在带命名空间的模块内访问全局内容（Global-Assets）\" class=\"headerlink\" title=\"在带命名空间的模块内访问全局内容（Global Assets）\"></a>在带命名空间的模块内访问全局内容（Global Assets）</h2><p>如果你希望使用全局 <code>state</code> 和 <code>getter</code>，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p>\n<p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code>作为第三参数传给 dispatch 或 commit 即可。</p>\n<pre><code>modules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -&gt; &#39;foo/someOtherGetter&#39;\n        rootGetters.someOtherGetter // -&gt; &#39;someOtherGetter&#39;\n      },\n      someOtherGetter: state =&gt; { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -&gt; &#39;foo/someGetter&#39;\n        rootGetters.someGetter // -&gt; &#39;someGetter&#39;\n\n        dispatch(&#39;someOtherAction&#39;) // -&gt; &#39;foo/someOtherAction&#39;\n        dispatch(&#39;someOtherAction&#39;, null, { root: true }) // -&gt; &#39;someOtherAction&#39;\n\n        commit(&#39;someMutation&#39;) // -&gt; &#39;foo/someMutation&#39;\n        commit(&#39;someMutation&#39;, null, { root: true }) // -&gt; &#39;someMutation&#39;\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n</code></pre><h2 id=\"在带命名空间的模块注册全局-action\"><a href=\"#在带命名空间的模块注册全局-action\" class=\"headerlink\" title=\"在带命名空间的模块注册全局 action\"></a>在带命名空间的模块注册全局 action</h2><p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 handler 中。例如：</p>\n<pre><code>{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch(&#39;someAction&#39;)\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -&gt; &#39;someAction&#39;\n        }\n      }\n    }\n  }\n}\n</code></pre><h2 id=\"带命名空间的绑定函数\"><a href=\"#带命名空间的绑定函数\" class=\"headerlink\" title=\"带命名空间的绑定函数\"></a>带命名空间的绑定函数</h2><p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre><code>computed: {\n  ...mapState({\n    a: state =&gt; state.some.nested.module.a,\n    b: state =&gt; state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    &#39;some/nested/module/foo&#39;, // -&gt; this[&#39;some/nested/module/foo&#39;]()\n    &#39;some/nested/module/bar&#39; // -&gt; this[&#39;some/nested/module/bar&#39;]()\n  ])\n}\n</code></pre><p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre><code>computed: {\n  ...mapState(&#39;some/nested/module&#39;, {\n    a: state =&gt; state.a,\n    b: state =&gt; state.b\n  })\n},\nmethods: {\n  ...mapActions(&#39;some/nested/module&#39;, [\n    &#39;foo&#39;, // -&gt; this.foo()\n    &#39;bar&#39; // -&gt; this.bar()\n  ])\n}\n</code></pre><p>而且，你可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre><code>import { createNamespacedHelpers } from &#39;vuex&#39;\n\nconst { mapState, mapActions } = createNamespacedHelpers(&#39;some/nested/module&#39;)\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state =&gt; state.a,\n      b: state =&gt; state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      &#39;foo&#39;,\n      &#39;bar&#39;\n    ])\n  }\n}\n</code></pre>","site":{"data":{"melody":{"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories"},"favicon":"/img/my-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"darker","social":{"github fa":"https://github.com/daialihexiaoniu"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":false},"mathjax":{"enable":false,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"fireworks":false,"baidu_analytics":null,"google_analytics":"UA-141300443-1","google_adsense":{"enable":true,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-9138439391803182","enable_page_level_ads":true},"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"},"js":{"anime":"/js/third-party/anime.min.js","jquery":"/js/third-party/jquery.min.js","fancybox":"/js/third-party/jquery.fancybox.min.js","velocity":"/js/third-party/velocity.min.js","velocity-ui":"/js/third-party/velocity.ui.min.js"}},"avatar":"/img/avatar.jpg","top_img":"/img/sky.jpg","post_meta":{"date_type":"updated","categories":true,"tags":true},"wordcount":{"enable":false},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"/img/微信打赏.png","text":"喜欢的话支持一下？"}},{"itemlist":{"img":"/img/支付宝打赏.png","text":"喜欢的话支持一下？"}}],"addThis":{"enable":false},"disqus":{"enable":false},"since":2018,"footer_custom_text":"QQ：397698632  微信：lxl_cwy <br> 欢迎来咨询~","ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null}}}},"excerpt":"<p>Vuex 学习， 内容摘抄自<a href=\"https://vuex.vuejs.org/zh/\" target=\"_blank\" rel=\"noopener\">Vuex</a><br>","more":"</p>\n<h2 id=\"什么是-Vuex？\"><a href=\"#什么是-Vuex？\" class=\"headerlink\" title=\"什么是 Vuex？\"></a>什么是 Vuex？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>\n<p>“单向数据流” 示意图如下：<br><img src=\"./flow.png\" alt=\"单向数据流示意图\"></p>\n<ul>\n<li>state：驱动应用的数据源</li>\n<li>view：以声明方式将 state 映射到视图</li>\n<li>actions：响应在 view 上的用户输入导致的状态变化</li>\n</ul>\n<p>Vuex 的基本思想是通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，使我们的代码变得更结构化且易维护。</p>\n<p>Vuex 示意图如下：<br><img src=\"./vuex.png\" alt=\"vuex\"></p>\n<h2 id=\"什么情况下我应该使用-Vuex？\"><a href=\"#什么情况下我应该使用-Vuex？\" class=\"headerlink\" title=\"什么情况下我应该使用 Vuex？\"></a>什么情况下我应该使用 Vuex？</h2><p>如果应用足够简单，不需要开发大型单页应用，则不需要使用Vuex。<br>如果打算构建一个中大型单页应用，则需要考虑如何更好地在组件外部管理状态，这时，Vuex将是一个很好的选择。</p>\n<h2 id=\"核心-Store\"><a href=\"#核心-Store\" class=\"headerlink\" title=\"核心 Store\"></a>核心 Store</h2><p>每一个 Vuex 应用的核心就是 Store（仓库）。“Store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。</p>\n<p>Vuex 和单纯的全局对象有以下两点不同：</p>\n<ol>\n<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>\n<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>\n</ol>\n<h2 id=\"最简单的-Store\"><a href=\"#最简单的-Store\" class=\"headerlink\" title=\"最简单的 Store\"></a>最简单的 Store</h2><pre><code>// 如果在模块化构建系统中，请确保在开头调用了 Vue.use(Vuex)\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  }\n})\nstore.commit(&#39;increment&#39;)\nconsole.log(store.state.count) // -&gt; 1\n</code></pre><h1 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h1><h2 id=\"单一状态树\"><a href=\"#单一状态树\" class=\"headerlink\" title=\"单一状态树\"></a>单一状态树</h2><p>Vuex 使用<strong>单一状态树</strong>，用一个对象包含全部应用层级状态。每个应用仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p>\n<h2 id=\"如何在-Vue-组件中获取-Vuex-的状态\"><a href=\"#如何在-Vue-组件中获取-Vuex-的状态\" class=\"headerlink\" title=\"如何在 Vue 组件中获取 Vuex 的状态\"></a>如何在 Vue 组件中获取 Vuex 的状态</h2><ol>\n<li><p>通过计算属性返回状态<br>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</p>\n<pre><code>// 创建一个 Counter 组件\nconst Counter = {\ntemplate: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\ncomputed: {\n count () {\n   return store.state.count\n }\n}\n}\n</code></pre><p>每当 <code>store.state.count</code> 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。<br>然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。</p>\n</li>\n<li><p>通过 store 选项<br>Vuex 通过 <code>store</code> 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 <code>Vue.use(Vuex)</code>）：</p>\n<pre><code>const app = new Vue({\nel: &#39;#app&#39;,\n// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件\nstore,\ncomponents: { Counter },\ntemplate: `\n &lt;div class=&quot;app&quot;&gt;\n   &lt;counter&gt;&lt;/counter&gt;\n &lt;/div&gt;\n`\n})\n</code></pre><p>通过在根实例中注册 <code>store</code> 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 <code>this.$store</code> 访问到。让我们更新下 <code>Counter</code> 的实现：</p>\n<pre><code>const Counter = {\ntemplate: `&lt;div&gt;{{ count }}&lt;/div&gt;`,\ncomputed: {\n count () {\n   return this.$store.state.count\n }\n}\n}\n</code></pre></li>\n<li><p><code>mapState</code> 辅助函数<br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 <code>mapState</code> 辅助函数帮助我们生成计算属性，让你少按几次键：</p>\n<pre><code>// 在单独构建的版本中辅助函数为 Vuex.mapState\nimport { mapState } from &#39;vuex&#39;\nexport default {\n// ...\ncomputed: mapState({\n // 箭头函数可使代码更简练\n count: state =&gt; state.count,\n\n // 传字符串参数 &#39;count&#39; 等同于 `state =&gt; state.count`\n countAlias: &#39;count&#39;,\n\n // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n countPlusLocalState (state) {\n   return state.count + this.localCount\n }\n})\n}\n</code></pre><p>当映射的计算属性的名称与 <code>state</code> 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>\n<pre><code>computed: mapState([\n// 映射 this.count 为 store.state.count\n&#39;count&#39;\n])\n</code></pre></li>\n</ol>\n<h2 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h2><p><code>mapState</code> 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 <code>computed</code> 属性。但是自从有了对象展开运算符（现处于 ECMAScript 提案 stage-4 阶段），我们可以极大地简化写法：</p>\n<h2 id=\"组件仍然保有局部状态\"><a href=\"#组件仍然保有局部状态\" class=\"headerlink\" title=\"组件仍然保有局部状态\"></a>组件仍然保有局部状态</h2><p>使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。</p>\n<h1 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h1><p>有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：</p>\n<pre><code>computed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo =&gt; todo.done).length\n  }\n}\n</code></pre><p>如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。</p>\n<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<p>Getter 接受 state 作为其第一个参数：</p>\n<pre><code>const store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: &#39;...&#39;, done: true },\n      { id: 2, text: &#39;...&#39;, done: false }\n    ]\n  },\n  getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }\n})\n</code></pre><h2 id=\"如何访问-Getter\"><a href=\"#如何访问-Getter\" class=\"headerlink\" title=\"如何访问 Getter\"></a>如何访问 Getter</h2><ol>\n<li><p>通过属性访问<br>Getter 会暴露为 <code>store.getters</code> 对象，你可以以属性的形式访问这些值：</p>\n<pre><code>store.getters.doneTodos // -&gt; [{ id: 1, text: &#39;...&#39;, done: true }]\n</code></pre><p>Getter 也可以接受其他 getter 作为第二个参数：</p>\n<pre><code>getters: {\n// ...\ndoneTodosCount: (state, getters) =&gt; {\n return getters.doneTodos.length\n}\n}\n</code></pre><pre><code>store.getters.doneTodosCount // -&gt; 1\n</code></pre><p>我们可以很容易地在任何组件中使用它：</p>\n<pre><code>computed: {\ndoneTodosCount () {\n return this.$store.getters.doneTodosCount\n}\n}\n</code></pre><p>注意，getter 在通过属性访问时是作为 Vue 的响应式系统的一部分缓存其中的。</p>\n</li>\n<li><p>通过方法访问<br>你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。</p>\n<pre><code>getters: {\n// ...\ngetTodoById: (state) =&gt; (id) =&gt; {\n return state.todos.find(todo =&gt; todo.id === id)\n}\n}\n</code></pre><pre><code>store.getters.getTodoById(2) // -&gt; { id: 2, text: &#39;...&#39;, done: false }\n</code></pre><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>\n</li>\n<li><p><code>mapGetters</code> 辅助函数<br><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>\n<pre><code>import { mapGetters } from &#39;vuex&#39;\nexport default {\n// ...\ncomputed: {\n// 使用对象展开运算符将 getter 混入 computed 对象中\n ...mapGetters([\n   &#39;doneTodosCount&#39;,\n   &#39;anotherGetter&#39;,\n   // ...\n ])\n}\n}\n</code></pre><p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>\n<pre><code>mapGetters({\n// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\ndoneCount: &#39;doneTodosCount&#39;\n})\n</code></pre></li>\n</ol>\n<h1 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h1><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong>。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>\n<pre><code>const store = new Vuex.Store({\n  state: {\n    count: 1\n  },\n  mutations: {\n    increment (state) {\n      // 变更状态\n      state.count++\n    }\n  }\n})\n</code></pre><p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 <code>store.commit</code> 方法：</p>\n<pre><code>store.commit(&#39;increment&#39;)\n</code></pre><h2 id=\"提交载荷（Payload）\"><a href=\"#提交载荷（Payload）\" class=\"headerlink\" title=\"提交载荷（Payload）\"></a>提交载荷（Payload）</h2><p>你可以向 store.commit 传入额外的参数，即 mutation 的 <strong>载荷（payload）</strong>：</p>\n<pre><code>// ...\nmutations: {\n  increment (state, n) {\n    state.count += n\n  }\n}\n</code></pre><pre><code>store.commit(&#39;increment&#39;, 10)\n</code></pre><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读:</p>\n<pre><code>// ...\nmutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre><pre><code>store.commit(&#39;increment&#39;, {\n  amount: 10\n})\n</code></pre><h2 id=\"对象风格的提交方式\"><a href=\"#对象风格的提交方式\" class=\"headerlink\" title=\"对象风格的提交方式\"></a>对象风格的提交方式</h2><p>提交 mutation 的另一种方式是直接使用包含 type 属性的对象：</p>\n<pre><code>store.commit({\n  type: &#39;increment&#39;,\n  amount: 10\n})\n</code></pre><p>当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>\n<pre><code>mutations: {\n  increment (state, payload) {\n    state.count += payload.amount\n  }\n}\n</code></pre><h2 id=\"Mutation-需遵守-Vue-的响应规则\"><a href=\"#Mutation-需遵守-Vue-的响应规则\" class=\"headerlink\" title=\"Mutation 需遵守 Vue 的响应规则\"></a>Mutation 需遵守 Vue 的响应规则</h2><p>既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：</p>\n<ol>\n<li>最好提前在你的 store 中初始化好所有所需属性。</li>\n<li>当需要在对象上添加新属性时，你应该<ul>\n<li>使用 Vue.set(obj, ‘newProp’, 123), 或者</li>\n<li>以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：<pre><code>state.obj = { ...state.obj, newProp: 123 }\n</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"使用常量替代-Mutation-事件类型\"><a href=\"#使用常量替代-Mutation-事件类型\" class=\"headerlink\" title=\"使用常量替代 Mutation 事件类型\"></a>使用常量替代 Mutation 事件类型</h2><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<pre><code>// mutation-types.js\nexport const SOME_MUTATION = &#39;SOME_MUTATION&#39;\n</code></pre><pre><code>// store.js\nimport Vuex from &#39;vuex&#39;\nimport { SOME_MUTATION } from &#39;./mutation-types&#39;\n\nconst store = new Vuex.Store({\n  state: { ... },\n  mutations: {\n    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n    [SOME_MUTATION] (state) {\n      // mutate state\n    }\n  }\n})\n</code></pre><p>用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>\n<h2 id=\"Mutation-必须是同步函数\"><a href=\"#Mutation-必须是同步函数\" class=\"headerlink\" title=\"Mutation 必须是同步函数\"></a>Mutation 必须是同步函数</h2><p>一条重要的原则就是要记住 mutation 必须是同步函数。为什么？请参考下面的例子：</p>\n<pre><code>mutations: {\n  someMutation (state) {\n    api.callAsyncMethod(() =&gt; {\n      state.count++\n    })\n  }\n}\n</code></pre><p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>\n<h2 id=\"如何在组件中提交-Mutation\"><a href=\"#如何在组件中提交-Mutation\" class=\"headerlink\" title=\"如何在组件中提交 Mutation\"></a>如何在组件中提交 Mutation</h2><p>你可以在组件中使用 <code>this.$store.commit(&#39;xxx&#39;)</code> 提交 mutation，或者使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 <code>store.commit</code> 调用（需要在根节点注入 <code>store</code>）。</p>\n<pre><code>import { mapMutations } from &#39;vuex&#39;\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n\n      // `mapMutations` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapMutations({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.commit(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h1 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h1><p>Action 类似于 mutation，不同在于：</p>\n<ul>\n<li>Action 提交的是 mutation，而不是直接变更状态。</li>\n<li>Action 可以包含任意异步操作。<br>让我们来注册一个简单的 action：<pre><code>const store = new Vuex.Store({\nstate: {\n  count: 0\n},\nmutations: {\n  increment (state) {\n    state.count++\n  }\n},\nactions: {\n  increment (context) {\n    context.commit(&#39;increment&#39;)\n  }\n}\n})\n</code></pre>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</li>\n</ul>\n<p>实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 <code>commit</code> 很多次的时候）：</p>\n<pre><code>actions: {\n  increment ({ commit }) {\n    commit(&#39;increment&#39;)\n  }\n}\n</code></pre><h2 id=\"分发-Action\"><a href=\"#分发-Action\" class=\"headerlink\" title=\"分发 Action\"></a>分发 Action</h2><p>Action 通过 <code>store.dispatch</code> 方法触发：</p>\n<pre><code>store.dispatch(&#39;increment&#39;)\n</code></pre><p>乍一眼看上去感觉多此一举，我们直接分发 mutation 岂不更方便？实际上并非如此，还记得 mutation <strong>必须同步执行</strong>这个限制么？Action 就不受约束！我们可以在 action 内部执行<strong>异步</strong>操作：</p>\n<pre><code>actions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() =&gt; {\n      commit(&#39;increment&#39;)\n    }, 1000)\n  }\n}\n</code></pre><p>Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<pre><code>// 以载荷形式分发\nstore.dispatch(&#39;incrementAsync&#39;, {\n  amount: 10\n})\n\n// 以对象形式分发\nstore.dispatch({\n  type: &#39;incrementAsync&#39;,\n  amount: 10\n})\n</code></pre><p>来看一个更加实际的购物车示例，涉及到<strong>调用异步 API</strong> 和<strong>分发多重 mutation</strong>：</p>\n<pre><code>actions: {\n  checkout ({ commit, state }, products) {\n    // 把当前购物车的物品备份起来\n    const savedCartItems = [...state.cart.added]\n    // 发出结账请求，然后乐观地清空购物车\n    commit(types.CHECKOUT_REQUEST)\n    // 购物 API 接受一个成功回调和一个失败回调\n    shop.buyProducts(\n      products,\n      // 成功操作\n      () =&gt; commit(types.CHECKOUT_SUCCESS),\n      // 失败操作\n      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)\n    )\n  }\n}\n</code></pre><p>注意我们正在进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）。</p>\n<h2 id=\"如何在组件中分发-Action\"><a href=\"#如何在组件中分发-Action\" class=\"headerlink\" title=\"如何在组件中分发 Action\"></a>如何在组件中分发 Action</h2><p>你在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store）：</p>\n<pre><code>import { mapActions } from &#39;vuex&#39;\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      &#39;increment&#39;, // 将 `this.increment()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n\n      // `mapActions` 也支持载荷：\n      &#39;incrementBy&#39; // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#39;incrementBy&#39;, amount)`\n    ]),\n    ...mapActions({\n      add: &#39;increment&#39; // 将 `this.add()` 映射为 `this.$store.dispatch(&#39;increment&#39;)`\n    })\n  }\n}\n</code></pre><h2 id=\"组合-Action\"><a href=\"#组合-Action\" class=\"headerlink\" title=\"组合 Action\"></a>组合 Action</h2><p>Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p>\n<p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p>\n<pre><code>actions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) =&gt; {\n      setTimeout(() =&gt; {\n        commit(&#39;someMutation&#39;)\n        resolve()\n      }, 1000)\n    })\n  }\n}\n</code></pre><p>现在你可以：</p>\n<pre><code>store.dispatch(&#39;actionA&#39;).then(() =&gt; {\n  // ...\n})\n</code></pre><p>在另外一个 action 中也可以：</p>\n<pre><code>actions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch(&#39;actionA&#39;).then(() =&gt; {\n      commit(&#39;someOtherMutation&#39;)\n    })\n  }\n}\n</code></pre><p>最后，如果我们利用 async / await，我们可以如下组合 action：</p>\n<pre><code>// 假设 getData() 和 getOtherData() 返回的是 Promise\nactions: {\n  async actionA ({ commit }) {\n    commit(&#39;gotData&#39;, await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch(&#39;actionA&#39;) // 等待 actionA 完成\n    commit(&#39;gotOtherData&#39;, await getOtherData())\n  }\n}\n</code></pre><blockquote>\n<p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>\n</blockquote>\n<h1 id=\"Module\"><a href=\"#Module\" class=\"headerlink\" title=\"Module\"></a>Module</h1><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割成<code>模块（module）</code>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>\n<pre><code>const moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -&gt; moduleA 的状态\nstore.state.b // -&gt; moduleB 的状态\n</code></pre><h2 id=\"模块的局部状态\"><a href=\"#模块的局部状态\" class=\"headerlink\" title=\"模块的局部状态\"></a>模块的局部状态</h2><p>对于模块内部的 mutation 和 getter，接收的第一个参数是<code>模块的局部状态对象</code>。</p>\n<pre><code>const moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态\n      state.count++\n    }\n  },\n  getters: {\n    doubleCount (state) {\n      return state.count * 2\n    }\n  }\n}\n</code></pre><p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>\n<pre><code>const moduleA = {\n  // ...\n  actions: {\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit(&#39;increment&#39;)\n      }\n    }\n  }\n}\n</code></pre><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre><code>const moduleA = {\n  // ...\n  getters: {\n    sumWithRootCount (state, getters, rootState) {\n      return state.count + rootState.count\n    }\n  }\n}\n</code></pre><h2 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h2><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<code>全局命名空间</code>的——这样使得多个模块能够对同一 mutation 或 action 作出响应。</p>\n<p>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>\n<pre><code>const store = new Vuex.Store({\n  modules: {\n    account: {\n      namespaced: true,\n      // 模块内容（module assets）\n      state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响\n      getters: {\n        isAdmin () { ... } // -&gt; getters[&#39;account/isAdmin&#39;]\n      },\n      actions: {\n        login () { ... } // -&gt; dispatch(&#39;account/login&#39;)\n      },\n      mutations: {\n        login () { ... } // -&gt; commit(&#39;account/login&#39;)\n      },\n      // 嵌套模块\n      modules: {\n        // 继承父模块的命名空间\n        myPage: {\n          state: { ... },\n          getters: {\n            profile () { ... } // -&gt; getters[&#39;account/profile&#39;]\n          }\n        },\n        // 进一步嵌套命名空间\n        posts: {\n          namespaced: true,\n          state: { ... },\n          getters: {\n            popular () { ... } // -&gt; getters[&#39;account/posts/popular&#39;]\n          }\n        }\n      }\n    }\n  }\n})\n</code></pre><p>启用了命名空间的 getter 和 action 会收到局部化的 <code>getter</code>，<code>dispatch</code> 和 <code>commit</code>。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 <code>namespaced</code> 属性后不需要修改模块内的代码。</p>\n<h2 id=\"在带命名空间的模块内访问全局内容（Global-Assets）\"><a href=\"#在带命名空间的模块内访问全局内容（Global-Assets）\" class=\"headerlink\" title=\"在带命名空间的模块内访问全局内容（Global Assets）\"></a>在带命名空间的模块内访问全局内容（Global Assets）</h2><p>如果你希望使用全局 <code>state</code> 和 <code>getter</code>，<code>rootState</code> 和 <code>rootGetters</code> 会作为第三和第四参数传入 getter，也会通过 <code>context</code> 对象的属性传入 action。</p>\n<p>若需要在全局命名空间内分发 action 或提交 mutation，将 <code>{ root: true }</code>作为第三参数传给 dispatch 或 commit 即可。</p>\n<pre><code>modules: {\n  foo: {\n    namespaced: true,\n\n    getters: {\n      // 在这个模块的 getter 中，`getters` 被局部化了\n      // 你可以使用 getter 的第四个参数来调用 `rootGetters`\n      someGetter (state, getters, rootState, rootGetters) {\n        getters.someOtherGetter // -&gt; &#39;foo/someOtherGetter&#39;\n        rootGetters.someOtherGetter // -&gt; &#39;someOtherGetter&#39;\n      },\n      someOtherGetter: state =&gt; { ... }\n    },\n\n    actions: {\n      // 在这个模块中， dispatch 和 commit 也被局部化了\n      // 他们可以接受 `root` 属性以访问根 dispatch 或 commit\n      someAction ({ dispatch, commit, getters, rootGetters }) {\n        getters.someGetter // -&gt; &#39;foo/someGetter&#39;\n        rootGetters.someGetter // -&gt; &#39;someGetter&#39;\n\n        dispatch(&#39;someOtherAction&#39;) // -&gt; &#39;foo/someOtherAction&#39;\n        dispatch(&#39;someOtherAction&#39;, null, { root: true }) // -&gt; &#39;someOtherAction&#39;\n\n        commit(&#39;someMutation&#39;) // -&gt; &#39;foo/someMutation&#39;\n        commit(&#39;someMutation&#39;, null, { root: true }) // -&gt; &#39;someMutation&#39;\n      },\n      someOtherAction (ctx, payload) { ... }\n    }\n  }\n}\n</code></pre><h2 id=\"在带命名空间的模块注册全局-action\"><a href=\"#在带命名空间的模块注册全局-action\" class=\"headerlink\" title=\"在带命名空间的模块注册全局 action\"></a>在带命名空间的模块注册全局 action</h2><p>若需要在带命名空间的模块注册全局 action，你可添加 <code>root: true</code>，并将这个 action 的定义放在函数 handler 中。例如：</p>\n<pre><code>{\n  actions: {\n    someOtherAction ({dispatch}) {\n      dispatch(&#39;someAction&#39;)\n    }\n  },\n  modules: {\n    foo: {\n      namespaced: true,\n\n      actions: {\n        someAction: {\n          root: true,\n          handler (namespacedContext, payload) { ... } // -&gt; &#39;someAction&#39;\n        }\n      }\n    }\n  }\n}\n</code></pre><h2 id=\"带命名空间的绑定函数\"><a href=\"#带命名空间的绑定函数\" class=\"headerlink\" title=\"带命名空间的绑定函数\"></a>带命名空间的绑定函数</h2><p>当使用 <code>mapState</code>, <code>mapGetters</code>, <code>mapActions</code> 和 <code>mapMutations</code> 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>\n<pre><code>computed: {\n  ...mapState({\n    a: state =&gt; state.some.nested.module.a,\n    b: state =&gt; state.some.nested.module.b\n  })\n},\nmethods: {\n  ...mapActions([\n    &#39;some/nested/module/foo&#39;, // -&gt; this[&#39;some/nested/module/foo&#39;]()\n    &#39;some/nested/module/bar&#39; // -&gt; this[&#39;some/nested/module/bar&#39;]()\n  ])\n}\n</code></pre><p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>\n<pre><code>computed: {\n  ...mapState(&#39;some/nested/module&#39;, {\n    a: state =&gt; state.a,\n    b: state =&gt; state.b\n  })\n},\nmethods: {\n  ...mapActions(&#39;some/nested/module&#39;, [\n    &#39;foo&#39;, // -&gt; this.foo()\n    &#39;bar&#39; // -&gt; this.bar()\n  ])\n}\n</code></pre><p>而且，你可以通过使用 <code>createNamespacedHelpers</code> 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>\n<pre><code>import { createNamespacedHelpers } from &#39;vuex&#39;\n\nconst { mapState, mapActions } = createNamespacedHelpers(&#39;some/nested/module&#39;)\n\nexport default {\n  computed: {\n    // 在 `some/nested/module` 中查找\n    ...mapState({\n      a: state =&gt; state.a,\n      b: state =&gt; state.b\n    })\n  },\n  methods: {\n    // 在 `some/nested/module` 中查找\n    ...mapActions([\n      &#39;foo&#39;,\n      &#39;bar&#39;\n    ])\n  }\n}\n</code></pre>"}],"PostAsset":[{"_id":"source/_posts/BFC及其应用/01.png","slug":"01.png","post":"ck1jzmx6j0004egqnu7nuyjt3","modified":0,"renderable":0},{"_id":"source/_posts/gittalk安装使用教程/01.png","slug":"01.png","post":"ck1jzmx6p000aegqnr2ynd53l","modified":0,"renderable":0},{"_id":"source/_posts/gittalk安装使用教程/02.png","slug":"02.png","post":"ck1jzmx6p000aegqnr2ynd53l","modified":0,"renderable":0},{"_id":"source/_posts/gittalk安装使用教程/03.png","slug":"03.png","post":"ck1jzmx6p000aegqnr2ynd53l","modified":0,"renderable":0},{"_id":"source/_posts/gittalk安装使用教程/04.png","slug":"04.png","post":"ck1jzmx6p000aegqnr2ynd53l","modified":0,"renderable":0},{"_id":"source/_posts/vuex学习/flow.png","slug":"flow.png","post":"ck1jzmx97001zegqnk5s9i00e","modified":0,"renderable":0},{"_id":"source/_posts/vuex学习/vuex.png","slug":"vuex.png","post":"ck1jzmx97001zegqnk5s9i00e","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck1jzmx690000egqno7r1g2ae","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx6t000cegqnrqhlronw"},{"post_id":"ck1jzmx6l0006egqn7lwo5g3x","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx6u000fegqnc0klf8ps"},{"post_id":"ck1jzmx6p000aegqnr2ynd53l","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx6v000hegqn57cbfjty"},{"post_id":"ck1jzmx6f0001egqn9t2ndkhq","category_id":"ck1jzmx6n0007egqn9wo3qf6n","_id":"ck1jzmx6w000jegqngxo2zs21"},{"post_id":"ck1jzmx6r000begqn367l1la9","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx6x000legqntvsnppmy"},{"post_id":"ck1jzmx6j0004egqnu7nuyjt3","category_id":"ck1jzmx6t000degqneq5ujw9q","_id":"ck1jzmx6x000negqnlizjeh4s"},{"post_id":"ck1jzmx7g000segqnf128givu","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx7x0010egqn2xzabuji"},{"post_id":"ck1jzmx7l000uegqncjxoljlb","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx810013egqnabwdwt3i"},{"post_id":"ck1jzmx7s000xegqnebq9rb6r","category_id":"ck1jzmx6t000degqneq5ujw9q","_id":"ck1jzmx840017egqnx6s6xerz"},{"post_id":"ck1jzmx7v000zegqnszp9u3un","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx860019egqn8ypn8vcg"},{"post_id":"ck1jzmx7z0012egqnsxztr2ky","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx89001cegqnt62acvw9"},{"post_id":"ck1jzmx830016egqn9xkikmhy","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8b001fegqn7d5edq5m"},{"post_id":"ck1jzmx850018egqni4nkpwl1","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8d001jegqn10y2qxhr"},{"post_id":"ck1jzmx87001begqnoc1a8jym","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8f001legqntc9u8mtr"},{"post_id":"ck1jzmx8a001eegqnx23iehg5","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8g001oegqndhy00kzl"},{"post_id":"ck1jzmx8c001iegqnbdvv48yr","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8h001qegqnoiekcg84"},{"post_id":"ck1jzmx8o001vegqnpb5g9dzh","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx8w001xegqnaqlj7lr5"},{"post_id":"ck1jzmx94001yegqn89jngwcr","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx9a0022egqnedqxxuta"},{"post_id":"ck1jzmx97001zegqnk5s9i00e","category_id":"ck1jzmx6h0002egqnnofxcri8","_id":"ck1jzmx9b0023egqnpksa38i5"}],"PostTag":[{"post_id":"ck1jzmx690000egqno7r1g2ae","tag_id":"ck1jzmx6i0003egqn0h30wkjc","_id":"ck1jzmx6p0009egqnzl0kj1v4"},{"post_id":"ck1jzmx6f0001egqn9t2ndkhq","tag_id":"ck1jzmx6n0008egqn6k30zo7t","_id":"ck1jzmx6u000gegqnqw5g7wmx"},{"post_id":"ck1jzmx6j0004egqnu7nuyjt3","tag_id":"ck1jzmx6u000eegqnxnvwei1s","_id":"ck1jzmx6w000kegqndcjxfxx4"},{"post_id":"ck1jzmx6l0006egqn7lwo5g3x","tag_id":"ck1jzmx6v000iegqndkujpoa5","_id":"ck1jzmx6z000oegqng83duqpj"},{"post_id":"ck1jzmx6p000aegqnr2ynd53l","tag_id":"ck1jzmx6v000iegqndkujpoa5","_id":"ck1jzmx6z000qegqn827e614p"},{"post_id":"ck1jzmx6r000begqn367l1la9","tag_id":"ck1jzmx6z000pegqnzuj328ep","_id":"ck1jzmx70000regqnxf0t2fzp"},{"post_id":"ck1jzmx7s000xegqnebq9rb6r","tag_id":"ck1jzmx6u000eegqnxnvwei1s","_id":"ck1jzmx7z0011egqnlanz02hl"},{"post_id":"ck1jzmx7g000segqnf128givu","tag_id":"ck1jzmx7r000wegqnczbd4t8a","_id":"ck1jzmx820015egqnse1qixok"},{"post_id":"ck1jzmx7l000uegqncjxoljlb","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx89001degqnt9eb3bic"},{"post_id":"ck1jzmx850018egqni4nkpwl1","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx8b001gegqn9eajstzg"},{"post_id":"ck1jzmx87001begqnoc1a8jym","tag_id":"ck1jzmx6v000iegqndkujpoa5","_id":"ck1jzmx8d001kegqn2t84t73e"},{"post_id":"ck1jzmx7v000zegqnszp9u3un","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx8f001megqnxr82z8qw"},{"post_id":"ck1jzmx8a001eegqnx23iehg5","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx8g001pegqn0iiqxrue"},{"post_id":"ck1jzmx7z0012egqnsxztr2ky","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx8h001regqn4kt9xefs"},{"post_id":"ck1jzmx830016egqn9xkikmhy","tag_id":"ck1jzmx8g001negqnev4amafe","_id":"ck1jzmx8i001tegqnv7jap0oh"},{"post_id":"ck1jzmx8c001iegqnbdvv48yr","tag_id":"ck1jzmx8h001segqnyks3yuho","_id":"ck1jzmx8i001uegqnnu17of6i"},{"post_id":"ck1jzmx8o001vegqnpb5g9dzh","tag_id":"ck1jzmx8h001segqnyks3yuho","_id":"ck1jzmx8u001wegqnb603vifm"},{"post_id":"ck1jzmx94001yegqn89jngwcr","tag_id":"ck1jzmx810014egqn72wtvpy4","_id":"ck1jzmx980020egqndczfya7z"},{"post_id":"ck1jzmx97001zegqnk5s9i00e","tag_id":"ck1jzmx8h001segqnyks3yuho","_id":"ck1jzmx9a0021egqn5cutu0qm"}],"Tag":[{"name":"ES10","_id":"ck1jzmx6i0003egqn0h30wkjc"},{"name":"杂记","_id":"ck1jzmx6n0008egqn6k30zo7t"},{"name":"CSS","_id":"ck1jzmx6u000eegqnxnvwei1s"},{"name":"hexo","_id":"ck1jzmx6v000iegqndkujpoa5"},{"name":"JS","_id":"ck1jzmx6z000pegqnzuj328ep"},{"name":"算法","_id":"ck1jzmx7r000wegqnczbd4t8a"},{"name":"js知识","_id":"ck1jzmx810014egqn72wtvpy4"},{"name":"正则","_id":"ck1jzmx8g001negqnev4amafe"},{"name":"vue","_id":"ck1jzmx8h001segqnyks3yuho"},{"name":"ES6","_id":"ck1jzn9kf0024egqnct9jxyhb"},{"name":"ES6、ES2015","_id":"ck1jzzq7z0027egqn40b13m7q"},{"name":"ES6 ES2015","_id":"ck1jzzyea0029egqn8i0wnkzt"}]}}